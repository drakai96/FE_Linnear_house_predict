import {
  createElementBlock,
  normalizeStyle,
  openBlock
} from "./chunk-3ULN2RVK.js";
import {
  __commonJS,
  __toESM
} from "./chunk-HUBM7RA2.js";

// node_modules/@canvasjs/stockcharts/canvasjs.stock.min.js
var require_canvasjs_stock_min = __commonJS({
  "node_modules/@canvasjs/stockcharts/canvasjs.stock.min.js"(exports, module) {
    (function() {
      function ga(k2, w) {
        k2.prototype = ob(w.prototype);
        k2.prototype.constructor = k2;
        k2.base = w.prototype;
      }
      function ob(k2) {
        function w() {
        }
        w.prototype = k2;
        return new w();
      }
      function cb(k2, w, f3) {
        "millisecond" === f3 ? k2.setMilliseconds(k2.getMilliseconds() + 1 * w) : "second" === f3 ? k2.setSeconds(k2.getSeconds() + 1 * w) : "minute" === f3 ? k2.setMinutes(k2.getMinutes() + 1 * w) : "hour" === f3 ? k2.setHours(k2.getHours() + 1 * w) : "day" === f3 ? k2.setDate(k2.getDate() + 1 * w) : "week" === f3 ? k2.setDate(k2.getDate() + 7 * w) : "month" === f3 ? k2.setMonth(k2.getMonth() + 1 * w) : "year" === f3 && k2.setFullYear(k2.getFullYear() + 1 * w);
        return k2;
      }
      function na(k2, w) {
        var f3 = false;
        0 > k2 && (f3 = true, k2 *= -1);
        k2 = "" + k2;
        for (w = w ? w : 1; k2.length < w; )
          k2 = "0" + k2;
        return f3 ? "-" + k2 : k2;
      }
      function Pa(k2) {
        if (!k2)
          return k2;
        k2 = k2.replace(/^\s\s*/, "");
        for (var w = /\s/, f3 = k2.length; w.test(k2.charAt(--f3)); )
          ;
        return k2.slice(0, f3 + 1);
      }
      function Da(k2) {
        k2.roundRect = function(k3, f3, r2, Z, P, A, x2, D2) {
          x2 && (this.fillStyle = x2);
          D2 && (this.strokeStyle = D2);
          "undefined" === typeof P && (P = 5);
          this.lineWidth = A;
          this.beginPath();
          this.moveTo(k3 + P, f3);
          this.lineTo(k3 + r2 - P, f3);
          this.quadraticCurveTo(k3 + r2, f3, k3 + r2, f3 + P);
          this.lineTo(k3 + r2, f3 + Z - P);
          this.quadraticCurveTo(k3 + r2, f3 + Z, k3 + r2 - P, f3 + Z);
          this.lineTo(k3 + P, f3 + Z);
          this.quadraticCurveTo(k3, f3 + Z, k3, f3 + Z - P);
          this.lineTo(k3, f3 + P);
          this.quadraticCurveTo(k3, f3, k3 + P, f3);
          this.closePath();
          x2 && this.fill();
          D2 && 0 < A && this.stroke();
        };
      }
      function Ya(k2, w) {
        return k2 - w;
      }
      function db(k2, w, f3) {
        if (k2 && w && f3) {
          f3 = f3 + "." + w;
          var r2 = "image/" + w;
          k2 = k2.toDataURL(r2);
          var Z = false, P = document.createElement("a");
          P.download = f3;
          P.href = k2;
          if ("undefined" !== typeof Blob && new Blob()) {
            for (var A = k2.replace(/^data:[a-z\/]*;base64,/, ""), A = atob(A), x2 = new ArrayBuffer(A.length), x2 = new Uint8Array(x2), D2 = 0; D2 < A.length; D2++)
              x2[D2] = A.charCodeAt(D2);
            w = new Blob([x2.buffer], { type: "image/" + w });
            try {
              window.navigator.msSaveBlob(w, f3), Z = true;
            } catch (Q) {
              P.dataset.downloadurl = [r2, P.download, P.href].join(":"), P.href = window.URL.createObjectURL(w);
            }
          }
          if (!Z)
            try {
              event = document.createEvent("MouseEvents"), event.initMouseEvent("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null), P.dispatchEvent ? P.dispatchEvent(event) : P.fireEvent && P.fireEvent("onclick");
            } catch (F2) {
              w = window.open(), w.document.write("<img src='" + k2 + "'></img><div>Please right click on the image and save it to your device</div>"), w.document.close();
            }
        }
      }
      function V(k2) {
        var w = ((k2 & 16711680) >> 16).toString(16), f3 = ((k2 & 65280) >> 8).toString(16);
        k2 = ((k2 & 255) >> 0).toString(16);
        w = 2 > w.length ? "0" + w : w;
        f3 = 2 > f3.length ? "0" + f3 : f3;
        k2 = 2 > k2.length ? "0" + k2 : k2;
        return "#" + w + f3 + k2;
      }
      function pb(k2, w) {
        var f3 = this.length >>> 0, r2 = Number(w) || 0, r2 = 0 > r2 ? Math.ceil(r2) : Math.floor(r2);
        for (0 > r2 && (r2 += f3); r2 < f3; r2++)
          if (r2 in this && this[r2] === k2)
            return r2;
        return -1;
      }
      function f2(k2) {
        return null === k2 || "undefined" === typeof k2;
      }
      function Ea(k2) {
        k2.indexOf || (k2.indexOf = pb);
        return k2;
      }
      function qb(k2) {
        if (Ba.fSDec)
          k2[wa("`eeDwdouMhrudods")](
            wa("e`u`@ohl`uhnoHuds`uhnoDoe"),
            function() {
              Ba._fTWm && Ba._fTWm(k2);
            }
          );
      }
      function eb(k2, w, f3) {
        f3 = f3 || "normal";
        var r2 = k2 + "_" + w + "_" + f3, Z = fb[r2];
        if (isNaN(Z)) {
          try {
            if (!Fa) {
              var P = document.body;
              Fa = document.createElement("span");
              Fa.innerHTML = "";
              var A = document.createTextNode("Mpgyi");
              Fa.appendChild(A);
              P.appendChild(Fa);
            }
            Fa.style.display = "";
            O(Fa, { position: "absolute", left: "0px", top: "-20000px", padding: "0px", margin: "0px", border: "none", whiteSpace: "pre", lineHeight: "normal", fontFamily: k2, fontSize: w + "px", fontWeight: f3 });
            Z = Math.round(Fa.offsetHeight);
            Fa.style.display = "none";
          } catch (x2) {
            Z = Math.ceil(1.1 * w);
          }
          Z = Math.max(Z, w);
          fb[r2] = Z;
        }
        return Z;
      }
      function R(k2, w) {
        var f3 = [];
        if (f3 = { solid: [], shortDash: [3, 1], shortDot: [1, 1], shortDashDot: [3, 1, 1, 1], shortDashDotDot: [3, 1, 1, 1, 1, 1], dot: [1, 2], dash: [4, 2], dashDot: [4, 2, 1, 2], longDash: [8, 2], longDashDot: [8, 2, 1, 2], longDashDotDot: [8, 2, 1, 2, 1, 2] }[k2 || "solid"])
          for (var r2 = 0; r2 < f3.length; r2++)
            f3[r2] *= w;
        else
          f3 = [];
        return f3;
      }
      function D(k2, w, K, r2, Z) {
        r2 = r2 || [];
        Z = f2(Z) ? rb ? { passive: false, capture: false } : false : Z;
        r2.push([k2, w, K, Z]);
        return k2.addEventListener ? (k2.addEventListener(
          w,
          K,
          Z
        ), K) : k2.attachEvent ? (r2 = function(w2) {
          w2 = w2 || window.event;
          w2.preventDefault = w2.preventDefault || function() {
            w2.returnValue = false;
          };
          w2.stopPropagation = w2.stopPropagation || function() {
            w2.cancelBubble = true;
          };
          K.call(k2, w2);
        }, k2.attachEvent("on" + w, r2), r2) : false;
      }
      function gb(k2, w, f3, r2) {
        r2 = r2 || false;
        if (k2.removeEventListener)
          k2.removeEventListener(w, f3, r2);
        else if (k2.detachEvent)
          k2.detachEvent("on" + w, f3);
        else
          return false;
      }
      function hb(k2, w) {
        if ("createEvent" in document) {
          var f3 = document.createEvent("HTMLEvents");
          f3.initEvent(w, false, true);
          k2.dispatchEvent(f3);
        } else
          k2.fireEvent("on" + w);
      }
      function ib(k2) {
        if (k2._menuButton)
          k2.exportEnabled ? (O(k2._menuButton, { backgroundColor: k2.toolbar.itemBackgroundColor, color: k2.toolbar.fontColor }), Ta(k2._menuButton), xa(k2, k2._menuButton, "menu")) : ya(k2._menuButton);
        else if (k2.exportEnabled && r) {
          var w = false;
          k2._menuButton = document.createElement("button");
          xa(k2, k2._menuButton, "menu");
          k2._toolBar.appendChild(k2._menuButton);
          D(k2._menuButton, "touchstart", function(k3) {
            w = true;
          }, k2.allDOMEventHandlers);
          D(k2._menuButton, "click", function() {
            "none" !== k2._dropdownMenu.style.display || k2._dropDownCloseTime && 500 >= new Date().getTime() - k2._dropDownCloseTime.getTime() || (k2._dropdownMenu.style.display = "block", k2._menuButton.blur(), k2._dropdownMenu.focus());
          }, k2.allDOMEventHandlers, true);
          D(k2._menuButton, "mousemove", function() {
            w || (O(k2._menuButton, { backgroundColor: k2.toolbar.itemBackgroundColorOnHover, color: k2.toolbar.fontColorOnHover }), 0 >= navigator.userAgent.search("MSIE") && O(k2._menuButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" }));
          }, k2.allDOMEventHandlers, true);
          D(
            k2._menuButton,
            "mouseout",
            function() {
              w || (O(k2._menuButton, { backgroundColor: k2.toolbar.itemBackgroundColor, color: k2.toolbar.fontColor }), 0 >= navigator.userAgent.search("MSIE") && O(k2._menuButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" }));
            },
            k2.allDOMEventHandlers,
            true
          );
        }
        if (k2.exportEnabled && k2._dropdownMenu) {
          O(k2._dropdownMenu, { backgroundColor: k2.toolbar.itemBackgroundColor, color: k2.toolbar.fontColor });
          for (var f3 = k2._dropdownMenu.childNodes, J = [k2._cultureInfo.printText, k2._cultureInfo.saveJPGText, k2._cultureInfo.savePNGText], Z = 0; Z < J.length; Z++)
            O(f3[Z], { backgroundColor: k2.toolbar.itemBackgroundColor, color: k2.toolbar.fontColor }), f3[Z].innerHTML = J[Z];
        } else
          !k2._dropdownMenu && (k2.exportEnabled && r) && (w = false, k2._dropdownMenu = document.createElement("div"), k2._dropdownMenu.setAttribute("tabindex", -1), f3 = -1 !== k2.theme.indexOf("dark") ? "black" : "#888888", O(k2._dropdownMenu, {
            position: "absolute",
            zIndex: 1,
            userSelect: "none",
            MozUserSeelct: "none",
            WebkitUserSelect: "none",
            msUserSelect: "none",
            cursor: "pointer",
            right: "0px",
            top: "25px",
            minWidth: "120px",
            outline: 0,
            fontSize: "14px",
            fontFamily: "Arial, Helvetica, sans-serif",
            padding: "5px 0px 5px 0px",
            textAlign: "left",
            lineHeight: "10px",
            backgroundColor: k2.toolbar.itemBackgroundColor,
            boxShadow: "2px 2px 10px" + f3
          }), k2._dropdownMenu.style.display = "none", k2._toolBar.appendChild(k2._dropdownMenu), D(k2._dropdownMenu, "blur", function() {
            ya(k2._dropdownMenu);
            k2._dropDownCloseTime = new Date();
          }, k2.allDOMEventHandlers, true), f3 = document.createElement("div"), O(f3, { padding: "12px 8px 12px 8px" }), f3.innerHTML = k2._cultureInfo.printText, f3.style.backgroundColor = k2.toolbar.itemBackgroundColor, f3.style.color = k2.toolbar.fontColor, k2._dropdownMenu.appendChild(f3), D(f3, "touchstart", function(k3) {
            w = true;
          }, k2.allDOMEventHandlers), D(f3, "mousemove", function() {
            w || (this.style.backgroundColor = k2.toolbar.itemBackgroundColorOnHover, this.style.color = k2.toolbar.fontColorOnHover);
          }, k2.allDOMEventHandlers, true), D(f3, "mouseout", function() {
            w || (this.style.backgroundColor = k2.toolbar.itemBackgroundColor, this.style.color = k2.toolbar.fontColor);
          }, k2.allDOMEventHandlers, true), D(f3, "click", function() {
            k2.print();
            ya(k2._dropdownMenu);
          }, k2.allDOMEventHandlers, true), f3 = document.createElement("div"), O(f3, { padding: "12px 8px 12px 8px" }), f3.innerHTML = k2._cultureInfo.saveJPGText, f3.style.backgroundColor = k2.toolbar.itemBackgroundColor, f3.style.color = k2.toolbar.fontColor, k2._dropdownMenu.appendChild(f3), D(f3, "touchstart", function(k3) {
            w = true;
          }, k2.allDOMEventHandlers), D(f3, "mousemove", function() {
            w || (this.style.backgroundColor = k2.toolbar.itemBackgroundColorOnHover, this.style.color = k2.toolbar.fontColorOnHover);
          }, k2.allDOMEventHandlers, true), D(
            f3,
            "mouseout",
            function() {
              w || (this.style.backgroundColor = k2.toolbar.itemBackgroundColor, this.style.color = k2.toolbar.fontColor);
            },
            k2.allDOMEventHandlers,
            true
          ), D(f3, "click", function() {
            k2.exportChart({ format: "jpeg", fileName: k2.exportFileName });
            ya(k2._dropdownMenu);
          }, k2.allDOMEventHandlers, true), f3 = document.createElement("div"), O(f3, { padding: "12px 8px 12px 8px" }), f3.innerHTML = k2._cultureInfo.savePNGText, f3.style.backgroundColor = k2.toolbar.itemBackgroundColor, f3.style.color = k2.toolbar.fontColor, k2._dropdownMenu.appendChild(f3), D(
            f3,
            "touchstart",
            function(k3) {
              w = true;
            },
            k2.allDOMEventHandlers
          ), D(f3, "mousemove", function() {
            w || (this.style.backgroundColor = k2.toolbar.itemBackgroundColorOnHover, this.style.color = k2.toolbar.fontColorOnHover);
          }, k2.allDOMEventHandlers, true), D(f3, "mouseout", function() {
            w || (this.style.backgroundColor = k2.toolbar.itemBackgroundColor, this.style.color = k2.toolbar.fontColor);
          }, k2.allDOMEventHandlers, true), D(f3, "click", function() {
            k2.exportChart({ format: "png", fileName: k2.exportFileName });
            ya(k2._dropdownMenu);
          }, k2.allDOMEventHandlers, true));
      }
      function jb(k2, f3, r2) {
        k2 *= ja;
        f3 *= ja;
        k2 = r2.getImageData(k2, f3, 2, 2).data;
        f3 = true;
        for (r2 = 0; 4 > r2; r2++)
          if (k2[r2] !== k2[r2 + 4] | k2[r2] !== k2[r2 + 8] | k2[r2] !== k2[r2 + 12]) {
            f3 = false;
            break;
          }
        return f3 ? k2[0] << 16 | k2[1] << 8 | k2[2] : 0;
      }
      function qa(k2, f3, r2) {
        return k2 in f3 ? f3[k2] : r2[k2];
      }
      function Ua(k2, w, K, J) {
        r && kb ? (J = !f2(J) && J ? k2.getContext("2d", { willReadFrequently: true }) : k2.getContext("2d"), Va = J.webkitBackingStorePixelRatio || J.mozBackingStorePixelRatio || J.msBackingStorePixelRatio || J.oBackingStorePixelRatio || J.backingStorePixelRatio || 1, ja = Za / Va, k2.width = w * ja, k2.height = K * ja, Za !== Va && (k2.style.width = w + "px", k2.style.height = K + "px", J.scale(ja, ja))) : (k2.width = w, k2.height = K);
      }
      function sb(k2) {
        if (!tb) {
          var f3 = false, r2 = false;
          "undefined" === typeof ia.Chart.creditHref ? (k2.creditHref = wa("iuuqr;..b`ow`rkr/bnl."), k2.creditText = wa("B`ow`rKR/bnl")) : (f3 = k2.updateOption("creditText"), r2 = k2.updateOption("creditHref"));
          if (k2.creditHref && k2.creditText) {
            k2._creditLink || (k2._creditLink = document.createElement("a"), k2._creditLink.setAttribute("class", "canvasjs-chart-credit"), k2._creditLink.setAttribute("title", "JavaScript Charts"), O(
              k2._creditLink,
              { outline: "none", margin: "0px", position: "absolute", right: "2px", top: k2.height - 14 + "px", color: "dimgrey", textDecoration: "none", fontSize: "11px", fontFamily: "Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif" }
            ), k2._creditLink.setAttribute("tabIndex", -1), k2._creditLink.setAttribute("target", "_blank"));
            if (0 === k2.renderCount || f3 || r2)
              k2._creditLink.setAttribute("href", k2.creditHref), k2._creditLink.innerHTML = k2.creditText;
            k2._creditLink && k2.creditHref && k2.creditText ? (k2._creditLink.parentElement || k2._canvasJSContainer.appendChild(k2._creditLink), k2._creditLink.style.top = k2.height - 14 + "px") : k2._creditLink.parentElement && k2._canvasJSContainer.removeChild(k2._creditLink);
          }
        }
      }
      function ra(k2, f3, K) {
        Ma && (this.canvasCount |= 0, window.console.log(++this.canvasCount));
        var J = document.createElement("canvas");
        J.setAttribute("class", "canvasjs-chart-canvas");
        Ua(J, k2, f3, K);
        r || "undefined" === typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(J);
        return J;
      }
      function O(k2, f3) {
        for (var r2 in f3)
          k2.style[r2] = f3[r2];
      }
      function xa(k2, f3, r2) {
        f3.getAttribute("state") || (f3.style.backgroundColor = k2.toolbar.itemBackgroundColor, f3.style.color = k2.toolbar.fontColor, f3.style.border = "none", O(f3, { WebkitUserSelect: "none", MozUserSelect: "none", msUserSelect: "none", userSelect: "none" }));
        f3.getAttribute("state") !== r2 && (f3.setAttribute("state", r2), f3.setAttribute("type", "button"), O(f3, { padding: "5px 12px", cursor: "pointer", "float": "left", width: "40px", height: "25px", outline: "0px", verticalAlign: "baseline", lineHeight: "0" }), f3.innerHTML = "<img src='" + ub[r2].image + "' alt='" + k2._cultureInfo[r2 + "Text"] + "' />", O(
          f3.childNodes[0],
          { height: "95%", pointerEvents: "none" }
        ));
        f3.setAttribute("title", k2._cultureInfo[r2 + "Text"]);
      }
      function Ta() {
        for (var k2 = null, f3 = 0; f3 < arguments.length; f3++)
          k2 = arguments[f3], k2.style && (k2.style.display = "inline");
      }
      function ya() {
        for (var k2 = null, f3 = 0; f3 < arguments.length; f3++)
          (k2 = arguments[f3]) && k2.style && (k2.style.display = "none");
      }
      function $a(k2) {
        if (null === k2 || "object" !== typeof k2)
          return k2;
        if (k2 instanceof Date)
          return new Date(k2.getTime());
        Array.isArray || (Array.isArray = function(k3) {
          return "[object Array]" === Object.prototype.toString.call(k3);
        });
        if (Array.isArray(k2)) {
          for (var f3 = [], r2 = 0; r2 < k2.length; r2++)
            f3.push($a(k2[r2]));
          return f3;
        }
        f3 = new k2.constructor();
        for (r2 in k2)
          k2.hasOwnProperty(r2) && (f3[r2] = $a(k2[r2]));
        return f3;
      }
      function Wa(k2, f3, r2, J, Z) {
        if (null === k2 || "undefined" === typeof k2)
          return "undefined" === typeof r2 ? f3 : r2;
        k2 = parseFloat(k2.toString()) * (0 <= k2.toString().indexOf("%") ? f3 / 100 : 1);
        "undefined" !== typeof J && (k2 = Math.min(J, k2), "undefined" !== typeof Z && (k2 = Math.max(Z, k2)));
        return !isNaN(k2) && k2 <= f3 && 0 <= k2 ? k2 : "undefined" === typeof r2 ? f3 : r2;
      }
      function $(k2, w, r2, J, Z) {
        this._defaultsKey = k2;
        this._themeOptionsKey = w;
        this._index = J;
        this.parent = Z;
        this._eventListeners = [];
        k2 = {};
        this.theme && f2(this.parent) && f2(w) && f2(J) ? k2 = f2(this.predefinedThemes[this.theme]) ? this.predefinedThemes.light1 : this.predefinedThemes[this.theme] : this.parent && (this.parent.themeOptions && this.parent.themeOptions[w]) && (null === J ? k2 = this.parent.themeOptions[w] : 0 < this.parent.themeOptions[w].length && (J = Math.min(this.parent.themeOptions[w].length - 1, J), k2 = this.parent.themeOptions[w][J]));
        this.themeOptions = k2;
        this.options = r2 ? r2 : { _isPlaceholder: true };
        this.setOptions(
          this.options,
          k2
        );
      }
      function Ka(k2, f3, r2, J, Z) {
        "undefined" === typeof Z && (Z = 0);
        this._padding = Z;
        this._x1 = k2;
        this._y1 = f3;
        this._x2 = r2;
        this._y2 = J;
        this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding;
      }
      function ma(k2, f3) {
        ma.base.constructor.call(this, "TextBlock", null, f3, null, null);
        this.ctx = k2;
        this._isDirty = true;
        this._wrappedText = null;
        this._initialize();
      }
      function Xa(k2, f3) {
        Xa.base.constructor.call(this, "Toolbar", "toolbar", f3, null, k2);
        this.chart = k2;
        this.canvas = k2.canvas;
        this.ctx = this.chart.ctx;
        this.optionsName = "toolbar";
      }
      function Ha(k2, w) {
        Ha.base.constructor.call(this, "Title", "title", w, null, k2);
        this.chart = k2;
        this.canvas = k2.canvas;
        this.ctx = this.chart.ctx;
        this.optionsName = "title";
        if (f2(this.options.margin) && k2.options.subtitles) {
          for (var r2 = k2.options.subtitles, J = 0; J < r2.length; J++)
            if ((f2(r2[J].horizontalAlign) && "center" === this.horizontalAlign || r2[J].horizontalAlign === this.horizontalAlign) && (f2(r2[J].verticalAlign) && "top" === this.verticalAlign || r2[J].verticalAlign === this.verticalAlign) && !r2[J].dockInsidePlotArea === !this.dockInsidePlotArea) {
              this.margin = 0;
              break;
            }
        }
        "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
        this.height = this.width = null;
        this.bounds = { x1: null, y1: null, x2: null, y2: null };
      }
      function Na(k2, f3, r2) {
        Na.base.constructor.call(this, "Subtitle", "subtitles", f3, r2, k2);
        this.chart = k2;
        this.canvas = k2.canvas;
        this.ctx = this.chart.ctx;
        this.optionsName = "subtitles";
        this.isOptionsInArray = true;
        "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
        this.height = this.width = null;
        this.bounds = { x1: null, y1: null, x2: null, y2: null };
      }
      function ab() {
        this.pool = [];
      }
      function Oa(k2) {
        var f3;
        k2 && Qa[k2] && (f3 = Qa[k2]);
        Oa.base.constructor.call(this, "CultureInfo", null, f3, null, null);
      }
      var Ma = false, Ba = {}, r = !!document.createElement("canvas").getContext, ia = { Chart: {
        width: 500,
        height: 400,
        zoomEnabled: false,
        zoomType: "x",
        backgroundColor: "white",
        theme: "light1",
        animationEnabled: false,
        animationDuration: 1200,
        dataPointWidth: null,
        dataPointMinWidth: null,
        dataPointMaxWidth: null,
        colorSet: "colorSet1",
        culture: "en",
        creditText: "CanvasJS",
        interactivityEnabled: true,
        exportEnabled: false,
        exportFileName: "Chart",
        rangeChanging: null,
        rangeChanged: null,
        publicProperties: { title: "readWrite", subtitles: "readWrite", toolbar: "readWrite", toolTip: "readWrite", legend: "readWrite", axisX: "readWrite", axisY: "readWrite", axisX2: "readWrite", axisY2: "readWrite", data: "readWrite", options: "readWrite", bounds: "readOnly", container: "readOnly", selectedColorSet: "readOnly" }
      }, Title: {
        padding: 0,
        text: null,
        verticalAlign: "top",
        horizontalAlign: "center",
        fontSize: 20,
        fontFamily: "Calibri",
        fontWeight: "normal",
        fontColor: "black",
        fontStyle: "normal",
        borderThickness: 0,
        borderColor: "black",
        cornerRadius: 0,
        backgroundColor: r ? "transparent" : null,
        margin: 5,
        wrap: true,
        maxWidth: null,
        dockInsidePlotArea: false,
        publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" }
      }, Subtitle: {
        padding: 0,
        text: null,
        verticalAlign: "top",
        horizontalAlign: "center",
        fontSize: 14,
        fontFamily: "Calibri",
        fontWeight: "normal",
        fontColor: "black",
        fontStyle: "normal",
        borderThickness: 0,
        borderColor: "black",
        cornerRadius: 0,
        backgroundColor: null,
        margin: 2,
        wrap: true,
        maxWidth: null,
        dockInsidePlotArea: false,
        publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" }
      }, Toolbar: { itemBackgroundColor: "white", itemBackgroundColorOnHover: "#2196f3", buttonBorderColor: "#2196f3", buttonBorderThickness: 1, fontColor: "black", fontColorOnHover: "white", publicProperties: { options: "readWrite", chart: "readOnly" } }, Legend: {
        name: null,
        verticalAlign: "center",
        horizontalAlign: "right",
        fontSize: 14,
        fontFamily: "calibri",
        fontWeight: "normal",
        fontColor: "black",
        fontStyle: "normal",
        cursor: null,
        itemmouseover: null,
        itemmouseout: null,
        itemmousemove: null,
        itemclick: null,
        dockInsidePlotArea: false,
        reversed: false,
        backgroundColor: r ? "transparent" : null,
        borderColor: r ? "transparent" : null,
        borderThickness: 0,
        cornerRadius: 0,
        maxWidth: null,
        maxHeight: null,
        markerMargin: null,
        itemMaxWidth: null,
        itemWidth: null,
        itemWrap: true,
        itemTextFormatter: null,
        publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" }
      }, ToolTip: {
        enabled: true,
        shared: false,
        animationEnabled: true,
        content: null,
        contentFormatter: null,
        reversed: false,
        backgroundColor: r ? "rgba(255,255,255,.9)" : "rgb(255,255,255)",
        borderColor: null,
        borderThickness: 2,
        cornerRadius: 5,
        fontSize: 14,
        fontColor: "black",
        fontFamily: "Calibri, Arial, Georgia, serif;",
        fontWeight: "normal",
        fontStyle: "italic",
        updated: null,
        hidden: null,
        publicProperties: { options: "readWrite", chart: "readOnly" }
      }, Axis: {
        minimum: null,
        maximum: null,
        viewportMinimum: null,
        viewportMaximum: null,
        interval: null,
        intervalType: null,
        reversed: false,
        logarithmic: false,
        logarithmBase: 10,
        title: null,
        titleFontColor: "black",
        titleFontSize: 20,
        titleFontFamily: "arial",
        titleFontWeight: "normal",
        titleFontStyle: "normal",
        titleWrap: true,
        titleMaxWidth: null,
        titleBackgroundColor: r ? "transparent" : null,
        titleBorderColor: r ? "transparent" : null,
        titleBorderThickness: 0,
        titleCornerRadius: 0,
        labelAngle: 0,
        labelFontFamily: "arial",
        labelFontColor: "black",
        labelFontSize: 12,
        labelFontWeight: "normal",
        labelFontStyle: "normal",
        labelAutoFit: true,
        labelWrap: true,
        labelMaxWidth: null,
        labelFormatter: null,
        labelBackgroundColor: r ? "transparent" : null,
        labelBorderColor: r ? "transparent" : null,
        labelBorderThickness: 0,
        labelCornerRadius: 0,
        labelPlacement: "outside",
        labelTextAlign: "left",
        prefix: "",
        suffix: "",
        includeZero: false,
        tickLength: 5,
        tickColor: "black",
        tickThickness: 1,
        tickPlacement: "outside",
        lineColor: "black",
        lineThickness: 1,
        lineDashType: "solid",
        gridColor: "#A0A0A0",
        gridThickness: 0,
        gridDashType: "solid",
        interlacedColor: r ? "transparent" : null,
        valueFormatString: null,
        margin: 2,
        publicProperties: {
          options: "readWrite",
          stripLines: "readWrite",
          scaleBreaks: "readWrite",
          crosshair: "readWrite",
          bounds: "readOnly",
          chart: "readOnly"
        }
      }, StripLine: { value: null, startValue: null, endValue: null, color: "orange", opacity: null, thickness: 2, lineDashType: "solid", label: "", labelPlacement: "inside", labelAlign: "far", labelWrap: true, labelMaxWidth: null, labelBackgroundColor: null, labelBorderColor: r ? "transparent" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelFontFamily: "arial", labelFontColor: "orange", labelFontSize: 12, labelFontWeight: "normal", labelFontStyle: "normal", labelFormatter: null, showOnTop: false, publicProperties: {
        options: "readWrite",
        axis: "readOnly",
        bounds: "readOnly",
        chart: "readOnly"
      } }, ScaleBreaks: { autoCalculate: false, collapsibleThreshold: "25%", maxNumberOfAutoBreaks: 2, spacing: 8, type: "straight", color: "#FFFFFF", fillOpacity: 0.9, lineThickness: 2, lineColor: "#E16E6E", lineDashType: "solid", publicProperties: { options: "readWrite", customBreaks: "readWrite", axis: "readOnly", autoBreaks: "readOnly", bounds: "readOnly", chart: "readOnly" } }, Break: {
        startValue: null,
        endValue: null,
        spacing: 8,
        type: "straight",
        color: "#FFFFFF",
        fillOpacity: 0.9,
        lineThickness: 2,
        lineColor: "#E16E6E",
        lineDashType: "solid",
        publicProperties: { options: "readWrite", scaleBreaks: "readOnly", bounds: "readOnly", chart: "readOnly" }
      }, Crosshair: {
        enabled: false,
        snapToDataPoint: false,
        color: "grey",
        opacity: null,
        thickness: 2,
        lineDashType: "solid",
        label: "",
        labelWrap: true,
        labelMaxWidth: null,
        labelBackgroundColor: r ? "grey" : null,
        labelBorderColor: r ? "grey" : null,
        labelBorderThickness: 0,
        labelCornerRadius: 0,
        labelFontFamily: r ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri",
        labelFontSize: 12,
        labelFontColor: "#fff",
        labelFontWeight: "normal",
        labelFontStyle: "normal",
        labelFormatter: null,
        valueFormatString: null,
        updated: null,
        hidden: null,
        publicProperties: { options: "readWrite", axis: "readOnly", bounds: "readOnly", chart: "readOnly" }
      }, DataSeries: {
        name: null,
        dataPoints: null,
        label: "",
        bevelEnabled: false,
        highlightEnabled: true,
        cursor: "default",
        indexLabel: "",
        indexLabelPlacement: "auto",
        indexLabelOrientation: "horizontal",
        indexLabelTextAlign: "left",
        indexLabelFontColor: "black",
        indexLabelFontSize: 12,
        indexLabelFontStyle: "normal",
        indexLabelFontFamily: "Arial",
        indexLabelFontWeight: "normal",
        indexLabelBackgroundColor: null,
        indexLabelLineColor: "gray",
        indexLabelLineThickness: 1,
        indexLabelLineDashType: "solid",
        indexLabelMaxWidth: null,
        indexLabelWrap: true,
        indexLabelFormatter: null,
        lineThickness: 2,
        lineDashType: "solid",
        connectNullData: false,
        nullDataLineDashType: "dash",
        color: null,
        lineColor: null,
        risingColor: "white",
        fallingColor: "red",
        fillOpacity: null,
        startAngle: 0,
        radius: null,
        innerRadius: null,
        neckHeight: null,
        neckWidth: null,
        reversed: false,
        valueRepresents: null,
        linkedDataSeriesIndex: null,
        whiskerThickness: 2,
        whiskerDashType: "solid",
        whiskerColor: null,
        whiskerLength: null,
        stemThickness: 2,
        stemColor: null,
        stemDashType: "solid",
        upperBoxColor: "white",
        lowerBoxColor: "white",
        type: "column",
        xValueType: "number",
        axisXType: "primary",
        axisYType: "primary",
        axisXIndex: 0,
        axisYIndex: 0,
        xValueFormatString: null,
        yValueFormatString: null,
        zValueFormatString: null,
        percentFormatString: null,
        showInLegend: null,
        legendMarkerType: null,
        legendMarkerColor: null,
        legendText: null,
        legendMarkerBorderColor: r ? "transparent" : null,
        legendMarkerBorderThickness: 0,
        markerType: "circle",
        markerColor: null,
        markerSize: null,
        markerBorderColor: r ? "transparent" : null,
        markerBorderThickness: 0,
        mouseover: null,
        mouseout: null,
        mousemove: null,
        click: null,
        toolTipContent: null,
        visible: true,
        publicProperties: { options: "readWrite", axisX: "readWrite", axisY: "readWrite", chart: "readOnly" }
      }, TextBlock: {
        x: 0,
        y: 0,
        width: null,
        height: null,
        maxWidth: null,
        maxHeight: null,
        padding: 0,
        angle: 0,
        text: "",
        horizontalAlign: "center",
        textAlign: "left",
        fontSize: 12,
        fontFamily: "calibri",
        fontWeight: "normal",
        fontColor: "black",
        fontStyle: "normal",
        borderThickness: 0,
        borderColor: "black",
        cornerRadius: 0,
        backgroundColor: null,
        textBaseline: "top"
      }, CultureInfo: {
        decimalSeparator: ".",
        digitGroupSeparator: ",",
        zoomText: "Zoom",
        panText: "Pan",
        resetText: "Reset",
        menuText: "More Options",
        saveJPGText: "Save as JPEG",
        savePNGText: "Save as PNG",
        printText: "Print",
        days: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
        shortDays: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
        months: "January February March April May June July August September October November December".split(" "),
        shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ")
      } }, Qa = { en: {} }, x = r ? "Trebuchet MS, Helvetica, sans-serif" : "Arial", za = r ? "Impact, Charcoal, sans-serif" : "Arial", sa = { colorSet1: "#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #7F6084 #77A033 #33558B #E59566".split(" "), colorSet2: "#6D78AD #51CDA0 #DF7970 #4C9CA0 #AE7D99 #C9D45C #5592AD #DF874D #52BCA8 #8E7AA3 #E3CB64 #C77B85 #C39762 #8DD17E #B57952 #FCC26C".split(" "), colorSet3: "#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970".split(" ") }, L, T, M, X, ta;
      T = "#333333";
      M = "#000000";
      L = "#666666";
      ta = X = "#000000";
      var la = 20, F = 14, Ga = { colorSet: "colorSet1", backgroundColor: "#FFFFFF", title: { fontFamily: za, fontSize: 32, fontColor: T, fontWeight: "normal", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: za, fontSize: F, fontColor: T, fontWeight: "normal", verticalAlign: "top", margin: 5 }], data: [{ indexLabelFontFamily: x, indexLabelFontSize: F, indexLabelFontColor: T, indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }], axisX: [{
        titleFontFamily: x,
        titleFontSize: la,
        titleFontColor: T,
        titleFontWeight: "normal",
        labelFontFamily: x,
        labelFontSize: F,
        labelFontColor: M,
        labelFontWeight: "normal",
        lineThickness: 1,
        lineColor: L,
        tickThickness: 1,
        tickColor: L,
        gridThickness: 0,
        gridColor: L,
        stripLines: [{ labelFontFamily: x, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
        crosshair: { labelFontFamily: x, labelFontSize: F, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: ta, color: X, thickness: 1, lineDashType: "dash" },
        scaleBreaks: {
          type: "zigzag",
          spacing: "2%",
          lineColor: "#BBBBBB",
          lineThickness: 1,
          lineDashType: "solid"
        }
      }], axisX2: [{ titleFontFamily: x, titleFontSize: la, titleFontColor: T, titleFontWeight: "normal", labelFontFamily: x, labelFontSize: F, labelFontColor: M, labelFontWeight: "normal", lineThickness: 1, lineColor: L, tickThickness: 1, tickColor: L, gridThickness: 0, gridColor: L, stripLines: [{ labelFontFamily: x, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
        labelFontFamily: x,
        labelFontSize: F,
        labelFontColor: "#EEEEEE",
        labelFontWeight: "normal",
        labelBackgroundColor: ta,
        color: X,
        thickness: 1,
        lineDashType: "dash"
      }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], axisY: [{ titleFontFamily: x, titleFontSize: la, titleFontColor: T, titleFontWeight: "normal", labelFontFamily: x, labelFontSize: F, labelFontColor: M, labelFontWeight: "normal", lineThickness: 1, lineColor: L, tickThickness: 1, tickColor: L, gridThickness: 1, gridColor: L, stripLines: [{
        labelFontFamily: x,
        labelFontSize: F,
        labelFontColor: "#FF7300",
        labelFontWeight: "normal",
        labelBackgroundColor: null,
        color: "#FF7300",
        thickness: 1
      }], crosshair: { labelFontFamily: x, labelFontSize: F, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: ta, color: X, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], axisY2: [{
        titleFontFamily: x,
        titleFontSize: la,
        titleFontColor: T,
        titleFontWeight: "normal",
        labelFontFamily: x,
        labelFontSize: F,
        labelFontColor: M,
        labelFontWeight: "normal",
        lineThickness: 1,
        lineColor: L,
        tickThickness: 1,
        tickColor: L,
        gridThickness: 1,
        gridColor: L,
        stripLines: [{ labelFontFamily: x, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
        crosshair: { labelFontFamily: x, labelFontSize: F, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: ta, color: X, thickness: 1, lineDashType: "dash" },
        scaleBreaks: {
          type: "zigzag",
          spacing: "2%",
          lineColor: "#BBBBBB",
          lineThickness: 1,
          lineDashType: "solid"
        }
      }], legend: { fontFamily: x, fontSize: 14, fontColor: T, fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: { fontFamily: x, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1 }, toolbar: { itemBackgroundColor: "white", itemBackgroundColorOnHover: "#2196f3", buttonBorderColor: "#2196f3", buttonBorderThickness: 1, fontColor: "black", fontColorOnHover: "white" } };
      L = "#2A2A2A";
      M = T = "#F5F5F5";
      L = "#FFFFFF";
      X = "#40BAF1";
      ta = "#F5F5F5";
      var la = 20, F = 14, Ia = { colorSet: "colorSet2", title: {
        fontFamily: x,
        fontSize: 33,
        fontColor: "#3A3A3A",
        fontWeight: "bold",
        verticalAlign: "top",
        margin: 5
      }, subtitles: [{ fontFamily: x, fontSize: F, fontColor: "#3A3A3A", fontWeight: "normal", verticalAlign: "top", margin: 5 }], data: [{ indexLabelFontFamily: x, indexLabelFontSize: F, indexLabelFontColor: "#666666", indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }], axisX: [{
        titleFontFamily: x,
        titleFontSize: la,
        titleFontColor: "#666666",
        titleFontWeight: "normal",
        labelFontFamily: x,
        labelFontSize: F,
        labelFontColor: "#666666",
        labelFontWeight: "normal",
        lineThickness: 1,
        lineColor: "#BBBBBB",
        tickThickness: 1,
        tickColor: "#BBBBBB",
        gridThickness: 1,
        gridColor: "#BBBBBB",
        stripLines: [{ labelFontFamily: x, labelFontSize: F, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }],
        crosshair: { labelFontFamily: x, labelFontSize: F, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" },
        scaleBreaks: {
          type: "zigzag",
          spacing: "2%",
          lineColor: "#BBBBBB",
          lineThickness: 1,
          lineDashType: "solid"
        }
      }], axisX2: [{ titleFontFamily: x, titleFontSize: la, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: x, labelFontSize: F, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 1, lineColor: "#BBBBBB", tickColor: "#BBBBBB", tickThickness: 1, gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{ labelFontFamily: x, labelFontSize: F, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }], crosshair: {
        labelFontFamily: x,
        labelFontSize: F,
        labelFontColor: "#EEEEEE",
        labelFontWeight: "normal",
        labelBackgroundColor: "black",
        color: "black",
        thickness: 1,
        lineDashType: "dot"
      }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], axisY: [{
        titleFontFamily: x,
        titleFontSize: la,
        titleFontColor: "#666666",
        titleFontWeight: "normal",
        labelFontFamily: x,
        labelFontSize: F,
        labelFontColor: "#666666",
        labelFontWeight: "normal",
        lineThickness: 0,
        lineColor: "#BBBBBB",
        tickColor: "#BBBBBB",
        tickThickness: 1,
        gridThickness: 1,
        gridColor: "#BBBBBB",
        stripLines: [{ labelFontFamily: x, labelFontSize: F, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }],
        crosshair: { labelFontFamily: x, labelFontSize: F, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" },
        scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
      }], axisY2: [{
        titleFontFamily: x,
        titleFontSize: la,
        titleFontColor: "#666666",
        titleFontWeight: "normal",
        labelFontFamily: x,
        labelFontSize: F,
        labelFontColor: "#666666",
        labelFontWeight: "normal",
        lineThickness: 0,
        lineColor: "#BBBBBB",
        tickColor: "#BBBBBB",
        tickThickness: 1,
        gridThickness: 1,
        gridColor: "#BBBBBB",
        stripLines: [{ labelFontFamily: x, labelFontSize: F, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }],
        crosshair: { labelFontFamily: x, labelFontSize: F, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" },
        scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
      }], legend: { fontFamily: x, fontSize: 14, fontColor: "#3A3A3A", fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: { fontFamily: x, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1 }, toolbar: { itemBackgroundColor: "white", itemBackgroundColorOnHover: "#2196f3", buttonBorderColor: "#2196f3", buttonBorderThickness: 1, fontColor: "black", fontColorOnHover: "white" } };
      M = T = "#F5F5F5";
      L = "#FFFFFF";
      X = "#40BAF1";
      ta = "#F5F5F5";
      la = 20;
      F = 14;
      za = { colorSet: "colorSet12", backgroundColor: "#2A2A2A", title: { fontFamily: za, fontSize: 32, fontColor: T, fontWeight: "normal", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: za, fontSize: F, fontColor: T, fontWeight: "normal", verticalAlign: "top", margin: 5 }], toolbar: { itemBackgroundColor: "#666666", itemBackgroundColorOnHover: "#FF7372", buttonBorderColor: "#FF7372", buttonBorderThickness: 1, fontColor: "#F5F5F5", fontColorOnHover: "#F5F5F5" }, data: [{
        indexLabelFontFamily: x,
        indexLabelFontSize: F,
        indexLabelFontColor: M,
        indexLabelFontWeight: "normal",
        indexLabelLineThickness: 1
      }], axisX: [{ titleFontFamily: x, titleFontSize: la, titleFontColor: M, titleFontWeight: "normal", labelFontFamily: x, labelFontSize: F, labelFontColor: M, labelFontWeight: "normal", lineThickness: 1, lineColor: L, tickThickness: 1, tickColor: L, gridThickness: 0, gridColor: L, stripLines: [{ labelFontFamily: x, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
        labelFontFamily: x,
        labelFontSize: F,
        labelFontColor: "#000000",
        labelFontWeight: "normal",
        labelBackgroundColor: ta,
        color: X,
        thickness: 1,
        lineDashType: "dash"
      }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], axisX2: [{ titleFontFamily: x, titleFontSize: la, titleFontColor: M, titleFontWeight: "normal", labelFontFamily: x, labelFontSize: F, labelFontColor: M, labelFontWeight: "normal", lineThickness: 1, lineColor: L, tickThickness: 1, tickColor: L, gridThickness: 0, gridColor: L, stripLines: [{
        labelFontFamily: x,
        labelFontSize: F,
        labelFontColor: "#FF7300",
        labelFontWeight: "normal",
        labelBackgroundColor: null,
        color: "#FF7300",
        thickness: 1
      }], crosshair: { labelFontFamily: x, labelFontSize: F, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ta, color: X, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], axisY: [{
        titleFontFamily: x,
        titleFontSize: la,
        titleFontColor: M,
        titleFontWeight: "normal",
        labelFontFamily: x,
        labelFontSize: F,
        labelFontColor: M,
        labelFontWeight: "normal",
        lineThickness: 1,
        lineColor: L,
        tickThickness: 1,
        tickColor: L,
        gridThickness: 1,
        gridColor: L,
        stripLines: [{ labelFontFamily: x, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
        crosshair: { labelFontFamily: x, labelFontSize: F, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ta, color: X, thickness: 1, lineDashType: "dash" },
        scaleBreaks: {
          type: "zigzag",
          spacing: "2%",
          lineColor: "#777777",
          lineThickness: 1,
          lineDashType: "solid",
          color: "#111111"
        }
      }], axisY2: [{ titleFontFamily: x, titleFontSize: la, titleFontColor: M, titleFontWeight: "normal", labelFontFamily: x, labelFontSize: F, labelFontColor: M, labelFontWeight: "normal", lineThickness: 1, lineColor: L, tickThickness: 1, tickColor: L, gridThickness: 1, gridColor: L, stripLines: [{ labelFontFamily: x, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
        labelFontFamily: x,
        labelFontSize: F,
        labelFontColor: "#000000",
        labelFontWeight: "normal",
        labelBackgroundColor: ta,
        color: X,
        thickness: 1,
        lineDashType: "dash"
      }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], legend: { fontFamily: x, fontSize: 14, fontColor: T, fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: { fontFamily: x, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1, fontColor: M, backgroundColor: "rgba(0, 0, 0, .7)" } };
      L = "#FFFFFF";
      M = T = "#FAFAFA";
      X = "#40BAF1";
      ta = "#F5F5F5";
      la = 20;
      F = 14;
      X = { colorSet: "colorSet2", backgroundColor: "#32373A", title: { fontFamily: x, fontSize: 32, fontColor: T, fontWeight: "normal", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: x, fontSize: F, fontColor: T, fontWeight: "normal", verticalAlign: "top", margin: 5 }], toolbar: { itemBackgroundColor: "#666666", itemBackgroundColorOnHover: "#FF7372", buttonBorderColor: "#FF7372", buttonBorderThickness: 1, fontColor: "#F5F5F5", fontColorOnHover: "#F5F5F5" }, data: [{
        indexLabelFontFamily: x,
        indexLabelFontSize: F,
        indexLabelFontColor: M,
        indexLabelFontWeight: "normal",
        indexLabelLineThickness: 1
      }], axisX: [{ titleFontFamily: x, titleFontSize: la, titleFontColor: M, titleFontWeight: "normal", labelFontFamily: x, labelFontSize: F, labelFontColor: M, labelFontWeight: "normal", lineThickness: 1, lineColor: L, tickThickness: 1, tickColor: L, gridThickness: 0, gridColor: L, stripLines: [{ labelFontFamily: x, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
        labelFontFamily: x,
        labelFontSize: F,
        labelFontColor: "#000000",
        labelFontWeight: "normal",
        labelBackgroundColor: ta,
        color: X,
        thickness: 1,
        lineDashType: "dash"
      }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], axisX2: [{ titleFontFamily: x, titleFontSize: la, titleFontColor: M, titleFontWeight: "normal", labelFontFamily: x, labelFontSize: F, labelFontColor: M, labelFontWeight: "normal", lineThickness: 1, lineColor: L, tickThickness: 1, tickColor: L, gridThickness: 0, gridColor: L, stripLines: [{
        labelFontFamily: x,
        labelFontSize: F,
        labelFontColor: "#FF7300",
        labelFontWeight: "normal",
        labelBackgroundColor: null,
        color: "#FF7300",
        thickness: 1
      }], crosshair: { labelFontFamily: x, labelFontSize: F, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ta, color: X, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], axisY: [{
        titleFontFamily: x,
        titleFontSize: la,
        titleFontColor: M,
        titleFontWeight: "normal",
        labelFontFamily: x,
        labelFontSize: F,
        labelFontColor: M,
        labelFontWeight: "normal",
        lineThickness: 0,
        lineColor: L,
        tickThickness: 1,
        tickColor: L,
        gridThickness: 1,
        gridColor: L,
        stripLines: [{ labelFontFamily: x, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
        crosshair: { labelFontFamily: x, labelFontSize: F, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ta, color: X, thickness: 1, lineDashType: "dash" },
        scaleBreaks: {
          type: "zigzag",
          spacing: "2%",
          lineColor: "#777777",
          lineThickness: 1,
          lineDashType: "solid",
          color: "#111111"
        }
      }], axisY2: [{ titleFontFamily: x, titleFontSize: la, titleFontColor: M, titleFontWeight: "normal", labelFontFamily: x, labelFontSize: F, labelFontColor: M, labelFontWeight: "normal", lineThickness: 0, lineColor: L, tickThickness: 1, tickColor: L, gridThickness: 1, gridColor: L, stripLines: [{ labelFontFamily: x, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
        labelFontFamily: x,
        labelFontSize: F,
        labelFontColor: "#000000",
        labelFontWeight: "normal",
        labelBackgroundColor: ta,
        color: X,
        thickness: 1,
        lineDashType: "dash"
      }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }], legend: { fontFamily: x, fontSize: 14, fontColor: T, fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: { fontFamily: x, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1, fontColor: M, backgroundColor: "rgba(0, 0, 0, .7)" } };
      var Ra = {
        light1: Ga,
        light2: Ia,
        dark1: za,
        dark2: X,
        theme1: Ga,
        theme2: Ia,
        theme3: Ga
      }, aa = { numberDuration: 1, yearDuration: 314496e5, monthDuration: 2592e6, weekDuration: 6048e5, dayDuration: 864e5, hourDuration: 36e5, minuteDuration: 6e4, secondDuration: 1e3, millisecondDuration: 1, dayOfWeekFromInt: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ") };
      (function() {
        Ba.fSDec = function(k2) {
          for (var f3 = "", r2 = 0; r2 < k2.length; r2++)
            f3 += String.fromCharCode(Math.ceil(k2.length / 57 / 5) ^ k2.charCodeAt(r2));
          return f3;
        };
        delete ia[Ba.fSDec("Bi`su")][Ba.fSDec("bsdehuIsdg")];
        Ba.pro = { sCH: ia[Ba.fSDec("Bi`su")][Ba.fSDec("bsdehuIsdg")] };
      })();
      var rb = function() {
        var k2 = false;
        try {
          var f3 = Object.defineProperty && Object.defineProperty({}, "passive", { get: function() {
            k2 = true;
            return false;
          } });
          window.addEventListener && (window.addEventListener("test", null, f3), window.removeEventListener("test", null, f3));
        } catch (r2) {
          k2 = false;
        }
        return k2;
      }(), fb = {}, Fa = null, lb = function(k2) {
        var w = 0, r2 = 0;
        this.options.width ? w = this.width : this.width = w = 0 < this.container.clientWidth ? this.container.clientWidth : this.width;
        f2(this.stockChart) || f2(this.index) ? this.options.height ? r2 = this.height : this.height = r2 = 0 < this.container.clientHeight ? this.container.clientHeight : this.height : r2 = this.height = this.stockChart._chartsHeight[this.index];
        if (this.canvas.width !== w * ja || this.canvas.height !== r2 * ja) {
          for (var J = 0; J < k2.length; J++)
            Ua(k2[J], w, r2);
          this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height, width: this.width, height: this.height };
          return true;
        }
        return false;
      }, mb = function() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.backgroundColor && (this.ctx.fillStyle = this.backgroundColor, this.ctx.fillRect(0, 0, this.width, this.height));
      }, Ca = function(k2) {
        k2.width = 1;
        k2.height = 1;
        k2.getContext("2d") && k2.getContext("2d").clearRect(0, 0, 1, 1);
      }, nb = function(k2, f3, r2) {
        f3 = Math.min(this.width, this.height);
        return Math.max("theme4" === this.theme ? 0 : 300 <= f3 ? 12 : 11, Math.round(f3 * (k2 / 400)));
      }, ea = function() {
        var k2 = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|"[^"]*"|'[^']*'/g, f3 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), r2 = "Sun Mon Tue Wed Thu Fri Sat".split(" "), J = "January February March April May June July August September October November December".split(" "), Z = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), x2 = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g, A = /[^-+\dA-Z]/g;
        return function(D2, F2, Q) {
          var L2 = Q ? Q.days : f3, R2 = Q ? Q.months : J, M2 = Q ? Q.shortDays : r2, V2 = Q ? Q.shortMonths : Z;
          Q = "";
          var d2 = false;
          D2 = D2 && D2.getTime ? D2 : D2 ? new Date(D2) : new Date();
          if (isNaN(D2))
            throw SyntaxError("invalid date");
          "UTC:" === F2.slice(0, 4) && (F2 = F2.slice(4), d2 = true);
          Q = d2 ? "getUTC" : "get";
          var u2 = D2[Q + "Date"](), s = D2[Q + "Day"](), v = D2[Q + "Month"](), a = D2[Q + "FullYear"](), h2 = D2[Q + "Hours"](), c2 = D2[Q + "Minutes"](), b = D2[Q + "Seconds"](), e = D2[Q + "Milliseconds"](), l2 = d2 ? 0 : D2.getTimezoneOffset();
          return Q = F2.replace(k2, function(C2) {
            switch (C2) {
              case "D":
                return u2;
              case "DD":
                return na(u2, 2);
              case "DDD":
                return M2[s];
              case "DDDD":
                return L2[s];
              case "M":
                return v + 1;
              case "MM":
                return na(v + 1, 2);
              case "MMM":
                return V2[v];
              case "MMMM":
                return R2[v];
              case "Y":
                return parseInt(String(a).slice(-2));
              case "YY":
                return na(String(a).slice(-2), 2);
              case "YYY":
                return na(
                  String(a).slice(-3),
                  3
                );
              case "YYYY":
                return na(a, 4);
              case "h":
                return h2 % 12 || 12;
              case "hh":
                return na(h2 % 12 || 12, 2);
              case "H":
                return h2;
              case "HH":
                return na(h2, 2);
              case "m":
                return c2;
              case "mm":
                return na(c2, 2);
              case "s":
                return b;
              case "ss":
                return na(b, 2);
              case "f":
                return na(String(e), 3).slice(0, 1);
              case "ff":
                return na(String(e), 3).slice(0, 2);
              case "fff":
                return na(String(e), 3).slice(0, 3);
              case "t":
                return 12 > h2 ? "a" : "p";
              case "tt":
                return 12 > h2 ? "am" : "pm";
              case "T":
                return 12 > h2 ? "A" : "P";
              case "TT":
                return 12 > h2 ? "AM" : "PM";
              case "K":
                return d2 ? "UTC" : (String(D2).match(x2) || [""]).pop().replace(A, "");
              case "z":
                return (0 < l2 ? "-" : "+") + Math.floor(Math.abs(l2) / 60);
              case "zz":
                return (0 < l2 ? "-" : "+") + na(Math.floor(Math.abs(l2) / 60), 2);
              case "zzz":
                return (0 < l2 ? "-" : "+") + na(Math.floor(Math.abs(l2) / 60), 2) + na(Math.abs(l2) % 60, 2);
              default:
                return C2.slice(1, C2.length - 1);
            }
          });
        };
      }(), vb = function(k2) {
        var f3 = 0 > k2;
        if (1 > Math.abs(k2)) {
          var r2 = parseInt(k2.toString().split("e-")[1]);
          r2 && (k2 = (f3 ? -1 * k2 : k2) * Math.pow(10, r2 - 1), k2 = "0." + Array(r2).join("0") + k2.toString().substring(2), k2 = f3 ? "-" + k2 : k2);
        } else
          r2 = parseInt(k2.toString().split("+")[1]), 20 < r2 && (r2 -= 20, k2 /= Math.pow(10, r2), k2 = k2.toString() + Array(r2 + 1).join("0"));
        return String(k2);
      }, da = function(k2, f3, r2) {
        if (null === k2)
          return "";
        if (!isFinite(k2))
          return k2;
        k2 = Number(k2);
        var J = 0 > k2 ? true : false;
        J && (k2 *= -1);
        var Z = r2 ? r2.decimalSeparator : ".", x2 = r2 ? r2.digitGroupSeparator : ",", A = "";
        f3 = String(f3);
        var A = 1, D2 = r2 = "", F2 = -1, Q = [], L2 = [], R2 = 0, M2 = 0, V2 = 0, d2 = false, u2 = 0, D2 = f3.match(/"[^"]*"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\u2030|./g);
        f3 = null;
        for (var s = 0; D2 && s < D2.length; s++)
          if (f3 = D2[s], "." === f3 && 0 > F2)
            F2 = s;
          else {
            if ("%" === f3)
              A *= 100;
            else if ("\u2030" === f3) {
              A *= 1e3;
              continue;
            } else if ("," === f3[0] && "." === f3[f3.length - 1]) {
              A /= Math.pow(1e3, f3.length - 1);
              F2 = s + f3.length - 1;
              continue;
            } else
              "E" !== f3[0] && "e" !== f3[0] || "0" !== f3[f3.length - 1] || (d2 = true);
            0 > F2 ? (Q.push(f3), "#" === f3 || "0" === f3 ? R2++ : "," === f3 && V2++) : (L2.push(f3), "#" !== f3 && "0" !== f3 || M2++);
          }
        d2 && (f3 = Math.floor(k2), D2 = -Math.floor(Math.log(k2) / Math.LN10 + 1), u2 = 0 === k2 ? 0 : 0 === f3 ? -(R2 + D2) : vb(f3).length - R2, A /= Math.pow(10, u2));
        0 > F2 && (F2 = s);
        A = (k2 * A).toFixed(M2);
        f3 = A.split(".");
        A = (f3[0] + "").split("");
        k2 = (f3[1] + "").split("");
        A && "0" === A[0] && A.shift();
        for (d2 = D2 = s = M2 = F2 = 0; 0 < Q.length; )
          if (f3 = Q.pop(), "#" === f3 || "0" === f3)
            if (F2++, F2 === R2) {
              var v = A, A = [];
              if ("0" === f3)
                for (f3 = R2 - M2 - (v ? v.length : 0); 0 < f3; )
                  v.unshift("0"), f3--;
              for (; 0 < v.length; )
                r2 = v.pop() + r2, d2++, 0 === d2 % D2 && (s === V2 && 0 < v.length) && (r2 = x2 + r2);
            } else
              0 < A.length ? (r2 = A.pop() + r2, M2++, d2++) : "0" === f3 && (r2 = "0" + r2, M2++, d2++), 0 === d2 % D2 && (s === V2 && 0 < A.length) && (r2 = x2 + r2);
          else
            "E" !== f3[0] && "e" !== f3[0] || "0" !== f3[f3.length - 1] || !/[eE][+-]*[0]+/.test(f3) ? "," === f3 ? (s++, D2 = d2, d2 = 0, 0 < A.length && (r2 = x2 + r2)) : r2 = 1 < f3.length && ('"' === f3[0] && '"' === f3[f3.length - 1] || "'" === f3[0] && "'" === f3[f3.length - 1]) ? f3.slice(1, f3.length - 1) + r2 : f3 + r2 : (f3 = 0 > u2 ? f3.replace(
              "+",
              ""
            ).replace("-", "") : f3.replace("-", ""), r2 += f3.replace(/[0]+/, function(a) {
              return na(u2, a.length);
            }));
        x2 = "";
        for (Q = false; 0 < L2.length; )
          f3 = L2.shift(), "#" === f3 || "0" === f3 ? 0 < k2.length && 0 !== Number(k2.join("")) ? (x2 += k2.shift(), Q = true) : "0" === f3 && (x2 += "0", Q = true) : 1 < f3.length && ('"' === f3[0] && '"' === f3[f3.length - 1] || "'" === f3[0] && "'" === f3[f3.length - 1]) ? x2 += f3.slice(1, f3.length - 1) : "E" !== f3[0] && "e" !== f3[0] || "0" !== f3[f3.length - 1] || !/[eE][+-]*[0]+/.test(f3) ? x2 += f3 : (f3 = 0 > u2 ? f3.replace("+", "").replace("-", "") : f3.replace("-", ""), x2 += f3.replace(/[0]+/, function(a) {
            return na(
              u2,
              a.length
            );
          }));
        r2 += (Q ? Z : "") + x2;
        return J ? "-" + r2 : r2;
      }, Aa = function(f3) {
        var r2 = 0, K = 0;
        f3 = f3 || window.event;
        f3.offsetX || 0 === f3.offsetX ? (r2 = f3.offsetX, K = f3.offsetY) : f3.layerX || 0 == f3.layerX ? (r2 = f3.layerX, K = f3.layerY) : (r2 = f3.pageX - f3.target.offsetLeft, K = f3.pageY - f3.target.offsetTop);
        return { x: r2, y: K };
      }, kb = true, Za = window.devicePixelRatio || 1, Va = 1, ja = kb ? Za / Va : 1, ba = function(f3, r2, K, J, x2, D2, A, F2, L2, Q, R2, M2, V2) {
        "undefined" === typeof V2 && (V2 = 1);
        A = A || 0;
        F2 = F2 || "black";
        var O2 = 15 < J - r2 && 15 < x2 - K ? 8 : 0.35 * Math.min(J - r2, x2 - K);
        f3.beginPath();
        f3.moveTo(r2, K);
        f3.save();
        f3.fillStyle = D2;
        f3.globalAlpha = V2;
        f3.fillRect(r2, K, J - r2, x2 - K);
        f3.globalAlpha = 1;
        0 < A && (V2 = 0 === A % 2 ? 0 : 0.5, f3.beginPath(), f3.lineWidth = A, f3.strokeStyle = F2, f3.moveTo(r2, K), f3.rect(r2 - V2, K - V2, J - r2 + 2 * V2, x2 - K + 2 * V2), f3.stroke());
        f3.restore();
        true === L2 && (f3.save(), f3.beginPath(), f3.moveTo(r2, K), f3.lineTo(r2 + O2, K + O2), f3.lineTo(J - O2, K + O2), f3.lineTo(J, K), f3.closePath(), A = f3.createLinearGradient((J + r2) / 2, K + O2, (J + r2) / 2, K), A.addColorStop(0, D2), A.addColorStop(1, "rgba(255, 255, 255, .4)"), f3.fillStyle = A, f3.fill(), f3.restore());
        true === Q && (f3.save(), f3.beginPath(), f3.moveTo(r2, x2), f3.lineTo(r2 + O2, x2 - O2), f3.lineTo(J - O2, x2 - O2), f3.lineTo(J, x2), f3.closePath(), A = f3.createLinearGradient((J + r2) / 2, x2 - O2, (J + r2) / 2, x2), A.addColorStop(0, D2), A.addColorStop(1, "rgba(255, 255, 255, .4)"), f3.fillStyle = A, f3.fill(), f3.restore());
        true === R2 && (f3.save(), f3.beginPath(), f3.moveTo(r2, K), f3.lineTo(r2 + O2, K + O2), f3.lineTo(r2 + O2, x2 - O2), f3.lineTo(r2, x2), f3.closePath(), A = f3.createLinearGradient(r2 + O2, (x2 + K) / 2, r2, (x2 + K) / 2), A.addColorStop(0, D2), A.addColorStop(1, "rgba(255, 255, 255, 0.1)"), f3.fillStyle = A, f3.fill(), f3.restore());
        true === M2 && (f3.save(), f3.beginPath(), f3.moveTo(
          J,
          K
        ), f3.lineTo(J - O2, K + O2), f3.lineTo(J - O2, x2 - O2), f3.lineTo(J, x2), A = f3.createLinearGradient(J - O2, (x2 + K) / 2, J, (x2 + K) / 2), A.addColorStop(0, D2), A.addColorStop(1, "rgba(255, 255, 255, 0.1)"), f3.fillStyle = A, A.addColorStop(0, D2), A.addColorStop(1, "rgba(255, 255, 255, 0.1)"), f3.fillStyle = A, f3.fill(), f3.closePath(), f3.restore());
      }, wa = function(f3) {
        for (var r2 = "", K = 0; K < f3.length; K++)
          r2 += String.fromCharCode(Math.ceil(f3.length / 57 / 5) ^ f3.charCodeAt(K));
        return r2;
      }, tb = window && (window[wa("mnb`uhno")] && window[wa("mnb`uhno")].href && window[wa("mnb`uhno")].href.indexOf && (-1 !== window[wa("mnb`uhno")].href.indexOf(wa("b`ow`rkr/bnl")) || -1 !== window[wa("mnb`uhno")].href.indexOf(wa("gdonqhy/bnl")) || -1 !== window[wa("mnb`uhno")].href.indexOf(wa("gheemd")))) && -1 === window[wa("mnb`uhno")].href.indexOf(wa("gheemd")), ub = {
        reset: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAeCAYAAABJ/8wUAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPjSURBVFhHxVdJaFNRFP1J/jwkP5MxsbaC1WJEglSxOFAXIsFpVRE3ggi1K90obioRRBA33XXnQnciirhQcMCdorgQxBkXWlREkFKsWkv5npvckp/XnzRpKh64kLw733fffe9L/wrL0+mVUdO8uTSZ3MBL/we2qg4rkuSpodCELstXE46ziVkLQ6FQcGOmeSSq6wd4aV50d3drWjj8kQKZJTUc9kxFGenv79dZrDksTSTWWJp2QYtEPiErysyzdX0LsxsCQR8keX8gs6RHIk8ysdgKFg2G53mhuOPsshTlBjKaFo1g7SqLNoShKLdFXT8huQ/paLSbxatYnc2mHMM4hr18Vi8TIvCmXF3vYrW6cF23gGTOk0M1wA4RKvOmq6vLZRVJipvmSWT6tZ6CSEYkco5V50VPT4+D7RwOqi6RiSZm0fJ+vggSqkeoypdsNmuyelNwbXsbgvkWYMtzDWNvWaijoyOBqE+hVK8abcssUeXQ/YfKyi0gFYv1Ipgfoj34fYGTJLOYJA0ODirok32GLN8XhUWCwSes1hIwBg6LydJ/tEeRRapAdUp+wSAiZchtZZWWgAZ+JNpD8peYXQVK9UwUxNpzOK8pq97kURZhYTCKBwPD7h2zK+js7Myi7D8Fod+0TkMI8+EMAngLGc/WtBFWawkFHFnoj/t9KLgGmF0B3QfkxC+EarxkdhnFYlFLY06USqUwL7UMjICHfh/wOc2sCqhpxGbCkLvL7EUDbF73+6DkmVWB6zi7xUDQSLeYvWjAILvm9zEnkJhlbRcDQZcv6Kg2AipyT/Axw6wKlqVSqxDdjF8Izfod13qURdrG/nxehY+xGh+h0CSzKygGvSNQIcc097BI24jb9hax6kj2E7OrMFX1il+ICEf2NrPbhiXLl+fYl+U7zK4iYdsDcyLGf+ofFlkwcN+s10KhmpuYhhtm0hCLVIFL0MDsqNlDIqy9x2CLs1jL6OvrI7vPRbtohXG6eFmsFnHDGAp6n9AgyuVySRZrGvROxRgIfLXhzjrNYnNBUxNX/dMgRWT1mt4XLDovaApD53E9W3ilNX5M55LJHpRtIsgAvciR4WWcgK2Dvb1YqgXevmF8z2zEBTcKG39EfSKsT9EbhVUaI2FZO+oZIqImxol6j66/hcAu4sSN4vc1ZPoKeoE6RGhYL2YYA+ymOSSi0Z0wWntbtkGUWCvfSDXIxONraZ/FY90KUfNTpfC5spnNLgxoYNnR9RO4F8ofXEHOgogCQE99w+fF2Xw+b7O59rEOsyRqGEfpVoaDMQQ1CZrG46bcM6AZ0C/wPqNfHliqejyTySxh9TqQpL+xmbIlkB9SlAAAAABJRU5ErkJggg==" },
        pan: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAICSURBVEhLxZbPahNRGMUn/5MpuAiBEAIufQGfzr5E40YptBXajYzudCEuGqS+gGlrFwquDGRTutBdYfydzJ3LzeQmJGZue+Dw/Z17Mnfmu5Pof9Hr9Z61Wq0bWZMKj263O6xWq99wU9lOpzPMKgEhEcRucNOcioOK+0RzBhNvt9tPV4nmVF19+OWhVqt9xXgFXZq+8lCv119UKpUJ7iX2FmvFTKz8RH34YdBsNk8wVtjE4fGYwm8wrrDi3WBG5oKXZGRSS9hGuNFojLTe2lFz5xThWZIktayyiE2FdT3rzXBXz7krKiL8c17wAKFDjCus2AvW+YGZ9y2JF0VFRuMPfI//rsCE/C+s26s4gQu9ul7r4NteKx7H8XOC724xNNGbaNu++IrBqbOV7Tj3FgMRvc/YKOr3+3sE47wgEt/Bl/gaK5cHbNU11vYSXylfpK7XOvjuumPp4Wcoipu30Qsez2uMXYz4lfI+mOmwothY+SLiXJy7mKVpWs3Si0CoOMfeI9Od43Wic+jO+ZVv+crsm9QSNhUW9LXSeoPBYLXopthGuFQgdIxxhY+UDwlt1x5CZ1hX+NTUdt/OIvjKaDSmuOJfaIVNPKX+W18j/PLA2/kR44p5Sd8HbHngT/yTfNRWUXX14ZcL3wmX0+TLf8YO7CGT8yFE5zB3/gney25/OETRP9CtPDFe5jShAAAAAElFTkSuQmCC" },
        zoom: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALWSURBVEhLvZZLaBNRFIabyftBIgEfqCCBoCC6MYqiXYiIj4U76U4X7sUHbhQhUBfixhZEUBDB16YuFERaUaQLK7ooCOJj4UKtYEFU0EptShO/A9Ph3js3k8lo/eHnP7n3nP/M3LlzMz1hkUwmNziOcyKRSFyFt+LxeD/c2Wq1Ym7Kv0M2m11Os1OxWGycn1OwZXCGuXfwIhezkd9/jRgNT2L4ldhs1pbkX5OLJe4euVxuGQaPCa3mnUjtJx7BDuKusJTCV6jVVGHTMuYRjxma7yIOhTgFY6jNaAKew2xPKpVay9ganmkvj+M448/MfJdT5K5Gg4HJacRngPFgqVRaRNwW1B4i7yehWfsEDdz1K+A01AoxPIqGAiuwGfkOTY8+1A6u7AyiFTB2Hu0KPIrdiOnzHLWDybeImvy+Wq2mZa5bUHsD0Zpz+KxHdWQymV6kAb1ElqeORgJLvgnRdj1+R1AfzkIvSUjxVjQSarVakrueIPT8+H1F5jSUy+WXiJrUYBVWyVxU4PEU8TzhfaijUqnMIWrjaY492eWRwdKOIqrnIxnXwLLeRLwk2GQzrEMjg0avEbXxkIxr4OoOImpj2QwyFgms1koa/SZUG8s+0iGnEhNfCNXEhzIXBVz0McTzEvJ+70P9oNFtxEzei3aFYrFYxmuSUPWSv9Yi9IMm2xE1We56Mp1OV4nDwqFmBDV9gk9AEh4gZtFHNt8W4kAUCoXF5MorY9Z/kDni9nDv7hc0i2fhgLvTtX8a99PoMPPagTFPxofRzmDJ9yM+AyEmTfgGysYbQcfhDzPPJDmX0c7gDg4gs9BqFIWhm/Nct5H8gtBq1I7UfIbtvmIuoaGQcp+fdpbbSM43eEH5wrwLbXmhm/fU63VHXjcuok7hEByFY/AeHGC8L5/PL3HT5xGH1uYwfPOICGo+CBcU0vwO1BqzUqILDl/z/9VYIMfpddiAc47jDP8BsUpb13wOLRwAAAAASUVORK5CYII=" },
        menu: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAeCAYAAABE4bxTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADoSURBVFhH7dc9CsJAFATgRxIIBCwCqZKATX5sbawsY2MvWOtF9AB6AU8gguAJbD2AnZ2VXQT/Ko2TYGCL2OYtYQc+BuYA+1hCtnCVwMm27SGaXpDJIAiCvCkVR05hGOZNN3HkFMdx3nQRR06+76/R1IcFLJlNQEWlmWlBTwJtKLKHynehZqnjOGM0PYWRVXk61C37p7xlZ3Hk5HneCk1dmMH811xGoKLSzDiQwIBZB4ocoPJdqNkDt2yKlueWRVGUtzy3rPwo3sWRU3nLjuLI6OO67oZM00wMw3hrmpZx0XU9syxrR0T0BeMpb9dneSR2AAAAAElFTkSuQmCC" }
      };
      $.prototype.setOptions = function(f3, r2) {
        if (ia[this._defaultsKey]) {
          var K = ia[this._defaultsKey], J;
          for (J in K)
            "publicProperties" !== J && K.hasOwnProperty(J) && (this[J] = f3 && J in f3 ? f3[J] : r2 && J in r2 ? r2[J] : K[J]);
        } else
          Ma && window.console && console.log("defaults not set");
      };
      $.prototype.get = function(f3) {
        var r2 = ia[this._defaultsKey];
        if ("options" === f3)
          return this.options && this.options._isPlaceholder ? null : this.options;
        if (r2.hasOwnProperty(f3) || r2.publicProperties && r2.publicProperties.hasOwnProperty(f3))
          return this[f3];
        window.console && window.console.log('Property "' + f3 + `" doesn't exist. Please check for typo.`);
      };
      $.prototype.set = function(f3, r2, K) {
        K = "undefined" === typeof K ? true : K;
        var J = ia[this._defaultsKey];
        if ("options" === f3)
          this.createUserOptions(r2);
        else if (J.hasOwnProperty(f3) || J.publicProperties && J.publicProperties.hasOwnProperty(f3) && "readWrite" === J.publicProperties[f3])
          this.options._isPlaceholder && this.createUserOptions(), this.options[f3] = r2;
        else {
          window.console && (J.publicProperties && J.publicProperties.hasOwnProperty(f3) && "readOnly" === J.publicProperties[f3] ? window.console.log('Property "' + f3 + '" is read-only.') : window.console.log('Property "' + f3 + `" doesn't exist. Please check for typo.`));
          return;
        }
        K && (this.stockChart || this.chart || this).render();
      };
      $.prototype.addTo = function(f3, r2, K, J) {
        J = "undefined" === typeof J ? true : J;
        var x2 = ia[this._defaultsKey];
        x2.hasOwnProperty(f3) || x2.publicProperties && x2.publicProperties.hasOwnProperty(f3) && "readWrite" === x2.publicProperties[f3] ? (this.options._isPlaceholder && this.createUserOptions(), "undefined" === typeof this.options[f3] && (this.options[f3] = []), f3 = this.options[f3], K = "undefined" === typeof K || null === K ? f3.length : K, f3.splice(K, 0, r2), J && (this.stockChart || this.chart || this).render()) : window.console && (x2.publicProperties && x2.publicProperties.hasOwnProperty(f3) && "readOnly" === x2.publicProperties[f3] ? window.console.log('Property "' + f3 + '" is read-only.') : window.console.log('Property "' + f3 + `" doesn't exist. Please check for typo.`));
      };
      $.prototype.createUserOptions = function(f3) {
        if ("undefined" !== typeof f3 || this.options._isPlaceholder)
          if (this.parent.options._isPlaceholder && this.parent.createUserOptions(), this.isOptionsInArray) {
            this.parent.options[this.optionsName] || (this.parent.options[this.optionsName] = []);
            var r2 = this.parent.options[this.optionsName], K = r2.length;
            this.options._isPlaceholder || (Ea(r2), K = r2.indexOf(this.options));
            this.options = "undefined" === typeof f3 ? {} : f3;
            r2[K] = this.options;
          } else
            this.options = "undefined" === typeof f3 ? {} : f3, f3 = this.parent.options, this.optionsName ? r2 = this.optionsName : (r2 = this._defaultsKey) && 0 !== r2.length ? (K = r2.charAt(0).toLowerCase(), 1 < r2.length && (K = K.concat(r2.slice(1))), r2 = K) : r2 = void 0, f3[r2] = this.options;
      };
      $.prototype.remove = function(f3) {
        f3 = "undefined" === typeof f3 ? true : f3;
        if (this.isOptionsInArray) {
          var r2 = this.parent.options[this.optionsName];
          Ea(r2);
          var K = r2.indexOf(this.options);
          0 <= K && r2.splice(K, 1);
        } else
          delete this.parent.options[this.optionsName];
        f3 && (this.stockChart || this.chart || this).render();
      };
      $.prototype.updateOption = function(k2) {
        !ia[this._defaultsKey] && (Ma && window.console) && console.log("defaults not set");
        var r2 = ia[this._defaultsKey], K = {}, x2 = this[k2], D2 = this._themeOptionsKey, F2 = this._index;
        this.theme && f2(this.parent) && f2(D2) && f2(F2) ? K = f2(this.predefinedThemes[this.theme]) ? this.predefinedThemes.light1 : this.predefinedThemes[this.theme] : this.parent && this.parent.themeOptions && (this.options.theme && Ra[this.options.theme] ? K = Ra[this.options.theme] : this.parent.themeOptions[D2] && (null === F2 ? K = this.parent.themeOptions[D2] : 0 < this.parent.themeOptions[D2].length && (K = Math.min(this.parent.themeOptions[D2].length - 1, F2), K = this.parent.themeOptions[D2][K])));
        this.themeOptions = K;
        k2 in r2 && (x2 = k2 in this.options ? this.options[k2] : K && k2 in K ? K[k2] : r2[k2]);
        if (x2 === this[k2])
          return false;
        this[k2] = x2;
        return true;
      };
      $.prototype.trackChanges = function(f3) {
        if (!this.sessionVariables)
          throw "Session Variable Store not set";
        this.sessionVariables[f3] = this.options[f3];
      };
      $.prototype.isBeingTracked = function(f3) {
        this.options._oldOptions || (this.options._oldOptions = {});
        return this.options._oldOptions[f3] ? true : false;
      };
      $.prototype.hasOptionChanged = function(f3) {
        if (!this.sessionVariables)
          throw "Session Variable Store not set";
        return this.sessionVariables[f3] !== this.options[f3];
      };
      $.prototype.addEventListener = function(f3, r2, K) {
        f3 && r2 && (this._eventListeners[f3] = this._eventListeners[f3] || [], this._eventListeners[f3].push({ context: K || this, eventHandler: r2 }));
      };
      $.prototype.removeEventListener = function(f3, r2) {
        if (f3 && r2 && this._eventListeners[f3]) {
          for (var K = this._eventListeners[f3], x2 = 0; x2 < K.length; x2++)
            if (K[x2].eventHandler === r2) {
              K[x2].splice(x2, 1);
              break;
            }
        }
      };
      $.prototype.removeAllEventListeners = function() {
        this._eventListeners = [];
      };
      $.prototype.dispatchEvent = function(f3, r2, K) {
        if (f3 && this._eventListeners[f3]) {
          r2 = r2 || {};
          for (var x2 = this._eventListeners[f3], D2 = 0; D2 < x2.length; D2++)
            x2[D2].eventHandler.call(x2[D2].context, r2);
        }
        "function" === typeof this[f3] && this[f3].call(K || this.chart, r2);
      };
      Ka.prototype.registerSpace = function(f3, r2) {
        "top" === f3 ? this._topOccupied += r2.height : "bottom" === f3 ? this._bottomOccupied += r2.height : "left" === f3 ? this._leftOccupied += r2.width : "right" === f3 && (this._rightOccupied += r2.width);
      };
      Ka.prototype.unRegisterSpace = function(f3, r2) {
        "top" === f3 ? this._topOccupied -= r2.height : "bottom" === f3 ? this._bottomOccupied -= r2.height : "left" === f3 ? this._leftOccupied -= r2.width : "right" === f3 && (this._rightOccupied -= r2.width);
      };
      Ka.prototype.getFreeSpace = function() {
        return { x1: this._x1 + this._leftOccupied, y1: this._y1 + this._topOccupied, x2: this._x2 - this._rightOccupied, y2: this._y2 - this._bottomOccupied, width: this._x2 - this._x1 - this._rightOccupied - this._leftOccupied, height: this._y2 - this._y1 - this._bottomOccupied - this._topOccupied };
      };
      Ka.prototype.reset = function() {
        this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding;
      };
      ga(ma, $);
      ma.prototype._initialize = function() {
        f2(this.padding) || "object" !== typeof this.padding ? this.topPadding = this.rightPadding = this.bottomPadding = this.leftPadding = Number(this.padding) | 0 : (this.topPadding = f2(this.padding.top) ? 0 : Number(this.padding.top) | 0, this.rightPadding = f2(this.padding.right) ? 0 : Number(this.padding.right) | 0, this.bottomPadding = f2(this.padding.bottom) ? 0 : Number(this.padding.bottom) | 0, this.leftPadding = f2(this.padding.left) ? 0 : Number(this.padding.left) | 0);
      };
      ma.prototype.render = function(f3) {
        if (0 !== this.fontSize) {
          f3 && this.ctx.save();
          var r2 = this.ctx.font;
          this.ctx.textBaseline = this.textBaseline;
          var K = 0;
          this._isDirty && this.measureText(this.ctx);
          this.ctx.translate(this.x, this.y + K);
          "middle" === this.textBaseline && (K = -this._lineHeight / 2);
          this.ctx.font = this._getFontString();
          this.ctx.rotate(Math.PI / 180 * this.angle);
          var x2 = 0, D2 = this.topPadding, F2 = null;
          this.ctx.roundRect || Da(this.ctx);
          (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(
            0,
            K,
            this.width,
            this.height,
            this.cornerRadius,
            this.borderThickness,
            this.backgroundColor,
            this.borderColor
          );
          this.ctx.fillStyle = this.fontColor;
          for (K = 0; K < this._wrappedText.lines.length; K++) {
            F2 = this._wrappedText.lines[K];
            if ("right" === this.horizontalAlign || "right" === this.textAlign)
              x2 = this.width - F2.width - this.rightPadding;
            else if ("left" === this.horizontalAlign || "left" === this.textAlign)
              x2 = this.leftPadding;
            else if ("center" === this.horizontalAlign || "center" === this.textAlign)
              x2 = (this.width - (this.leftPadding + this.rightPadding)) / 2 - F2.width / 2 + this.leftPadding;
            this.ctx.fillText(F2.text, x2, D2);
            D2 += F2.height;
          }
          this.ctx.font = r2;
          f3 && this.ctx.restore();
        }
      };
      ma.prototype.setText = function(f3) {
        this.text = f3;
        this._isDirty = true;
        this._wrappedText = null;
      };
      ma.prototype.measureText = function() {
        this._lineHeight = eb(this.fontFamily, this.fontSize, this.fontWeight);
        if (null === this.maxWidth)
          throw "Please set maxWidth and height for TextBlock";
        this._wrapText(this.ctx);
        this._isDirty = false;
        return { width: this.width, height: this.height };
      };
      ma.prototype._getLineWithWidth = function(f3, r2, x2) {
        f3 = String(f3);
        if (!f3)
          return { text: "", width: 0 };
        var D2 = x2 = 0, F2 = f3.length - 1, P = Infinity;
        for (this.ctx.font = this._getFontString(); D2 <= F2; ) {
          var P = Math.floor((D2 + F2) / 2), A = f3.substr(0, P + 1);
          x2 = this.ctx.measureText(A).width;
          if (x2 < r2)
            D2 = P + 1;
          else if (x2 > r2)
            F2 = P - 1;
          else
            break;
        }
        x2 > r2 && 1 < A.length && (A = A.substr(0, A.length - 1), x2 = this.ctx.measureText(A).width);
        r2 = true;
        if (A.length === f3.length || " " === f3[A.length])
          r2 = false;
        r2 && (f3 = A.split(" "), 1 < f3.length && f3.pop(), A = f3.join(" "), x2 = this.ctx.measureText(A).width);
        return { text: A, width: x2 };
      };
      ma.prototype._wrapText = function() {
        var f3 = new String(Pa(String(this.text))), r2 = [], x2 = this.ctx.font, D2 = 0, F2 = 0;
        this.ctx.font = this._getFontString();
        if (0 === this.frontSize)
          F2 = D2 = 0;
        else
          for (; 0 < f3.length; ) {
            var P = this.maxHeight - (this.topPadding + this.bottomPadding), A = this._getLineWithWidth(f3, this.maxWidth - (this.leftPadding + this.rightPadding), false);
            A.height = this._lineHeight;
            r2.push(A);
            var L2 = F2, F2 = Math.max(F2, A.width), D2 = D2 + A.height, f3 = Pa(f3.slice(A.text.length, f3.length));
            P && D2 > P && (A = r2.pop(), D2 -= A.height, F2 = L2);
          }
        this._wrappedText = { lines: r2, width: F2, height: D2 };
        this.width = F2 + (this.leftPadding + this.rightPadding);
        this.height = D2 + (this.topPadding + this.bottomPadding);
        this.ctx.font = x2;
      };
      ma.prototype._getFontString = function() {
        var f3;
        f3 = this.fontStyle ? this.fontStyle + " " : "";
        f3 += this.fontWeight ? this.fontWeight + " " : "";
        f3 += this.fontSize ? this.fontSize + "px " : "";
        var w = this.fontFamily ? this.fontFamily + "" : "";
        !r && w && (w = w.split(",")[0], "'" !== w[0] && '"' !== w[0] && (w = "'" + w + "'"));
        return f3 += w;
      };
      ga(Xa, $);
      ga(Ha, $);
      Ha.prototype.setLayout = function() {
        if (this.text) {
          var r2 = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, w = r2.layoutManager.getFreeSpace(), x2 = w.x1, D2 = w.y1, F2 = 0, P = 0, A = this.chart._menuButton && this.chart.exportEnabled && "top" === this.verticalAlign ? 40 : 0, L2, O2;
          "top" === this.verticalAlign || "bottom" === this.verticalAlign ? (null === this.maxWidth && (this.maxWidth = w.width - 4 - A * ("center" === this.horizontalAlign ? 2 : 1)), P = 0.5 * w.height - this.margin - 2, F2 = 0) : "center" === this.verticalAlign && ("left" === this.horizontalAlign || "right" === this.horizontalAlign ? (null === this.maxWidth && (this.maxWidth = w.height - 4), P = 0.5 * w.width - this.margin - 2) : "center" === this.horizontalAlign && (null === this.maxWidth && (this.maxWidth = w.width - 4), P = 0.5 * w.height - 4));
          var Q;
          f2(this.padding) || "number" !== typeof this.padding ? f2(this.padding) || "object" !== typeof this.padding || (Q = this.padding.top ? this.padding.top : this.padding.bottom ? this.padding.bottom : 0, Q += this.padding.bottom ? this.padding.bottom : this.padding.top ? this.padding.top : 0) : Q = 2 * this.padding;
          this.wrap || (P = Math.min(P, 1.5 * this.fontSize + Q));
          P = new ma(this.ctx, {
            fontSize: this.fontSize,
            fontFamily: this.fontFamily,
            fontColor: this.fontColor,
            fontStyle: this.fontStyle,
            fontWeight: this.fontWeight,
            horizontalAlign: this.horizontalAlign,
            textAlign: this.horizontalAlign,
            verticalAlign: this.verticalAlign,
            borderColor: this.borderColor,
            borderThickness: this.borderThickness,
            backgroundColor: this.backgroundColor,
            maxWidth: this.maxWidth,
            maxHeight: P,
            cornerRadius: this.cornerRadius,
            text: this.text,
            padding: this.padding,
            textBaseline: "middle"
          });
          Q = P.measureText();
          "top" === this.verticalAlign || "bottom" === this.verticalAlign ? ("top" === this.verticalAlign ? (D2 = w.y1 + 2 + this.fontSize / 2 + 4, O2 = "top") : "bottom" === this.verticalAlign && (D2 = w.y2 - 2 - Q.height + this.fontSize / 2 + 4, O2 = "bottom"), "left" === this.horizontalAlign ? x2 = w.x1 + 2 : "center" === this.horizontalAlign ? x2 = w.x1 + w.width / 2 - Q.width / 2 : "right" === this.horizontalAlign && (x2 = w.x2 - 2 - Q.width - A), L2 = this.horizontalAlign, this.width = Q.width, this.height = Q.height) : "center" === this.verticalAlign && ("left" === this.horizontalAlign ? (x2 = w.x1 + 2 + (this.fontSize / 2 + 4), D2 = w.y2 - 2 - (this.maxWidth / 2 - Q.width / 2), F2 = -90, O2 = "left", this.width = Q.height, this.height = Q.width) : "right" === this.horizontalAlign ? (x2 = w.x2 - 2 - (this.fontSize / 2 + 4), D2 = w.y1 + 2 + (this.maxWidth / 2 - Q.width / 2), F2 = 90, O2 = "right", this.width = Q.height, this.height = Q.width) : "center" === this.horizontalAlign && (D2 = r2.y1 + (r2.height / 2 - Q.height / 2) + this.fontSize / 2 + 4, x2 = r2.x1 + (r2.width / 2 - Q.width / 2), O2 = "center", this.width = Q.width, this.height = Q.height), L2 = "center");
          P.x = x2;
          P.y = D2;
          P.angle = F2;
          P.horizontalAlign = L2;
          this._textBlock = P;
          r2.layoutManager.registerSpace(O2, { width: this.width + ("left" === O2 || "right" === O2 ? this.margin + 2 : 0), height: this.height + ("top" === O2 || "bottom" === O2 ? this.margin + 2 : 0) });
          this.bounds = { x1: x2, y1: D2, x2: x2 + this.width, y2: D2 + this.height };
          this.ctx.textBaseline = "top";
        }
      };
      Ha.prototype.render = function() {
        this._textBlock && this._textBlock.render(true);
      };
      ga(Na, $);
      Na.prototype.setLayout = Ha.prototype.setLayout;
      Na.prototype.render = Ha.prototype.render;
      ab.prototype.get = function(f3, r2) {
        var x2 = null;
        0 < this.pool.length ? (x2 = this.pool.pop(), Ua(x2, f3, r2)) : x2 = ra(f3, r2);
        return x2;
      };
      ab.prototype.release = function(f3) {
        this.pool.push(f3);
      };
      ga(Oa, $);
      var Sa = { addTheme: function(f3, r2) {
        Ra[f3] = r2;
      }, addColorSet: function(f3, r2) {
        sa[f3] = r2;
      }, addCultureInfo: function(f3, r2) {
        Qa[f3] = r2;
      }, formatNumber: function(f3, r2, x2) {
        x2 = x2 || "en";
        if (Qa[x2])
          return da(f3, r2 || "#,##0.##", new Oa(x2));
        throw "Unknown Culture Name";
      }, formatDate: function(f3, r2, x2) {
        x2 = x2 || "en";
        if (Qa[x2])
          return ea(f3, r2 || "DD MMM YYYY", new Oa(x2));
        throw "Unknown Culture Name";
      } };
      "undefined" !== typeof module && "undefined" !== typeof module.exports ? module.exports = Sa : "function" === typeof define && define.amd ? define([], function() {
        return Sa;
      }) : (window.CanvasJS && window.console && window.console.log("CanvasJS namespace already exists. If you are loading both chart and stockchart scripts, just load stockchart alone as it includes all chart features."), window.CanvasJS = window.CanvasJS ? window.CanvasJS : Sa);
      var Ja = Sa.Chart = function() {
        function k2(a, h2) {
          return a.x - h2.x;
        }
        function w(a, h2, c2) {
          h2 = h2 || {};
          f2(c2) ? (this.predefinedThemes = Ra, this.optionsName = this.parent = this.index = null) : (this.parent = c2.parent, this.index = c2.index, this.predefinedThemes = c2.predefinedThemes, this.optionsName = c2.optionsName, this.stockChart = c2.stockChart, this.panel = a, this.isOptionsInArray = c2.isOptionsInArray);
          this.theme = f2(h2.theme) || f2(this.predefinedThemes[h2.theme]) ? "light1" : h2.theme;
          w.base.constructor.call(
            this,
            "Chart",
            this.optionsName,
            h2,
            this.index,
            this.parent
          );
          var b = this;
          this._containerId = a;
          this._objectsInitialized = false;
          this.overlaidCanvasCtx = this.ctx = null;
          this._indexLabels = [];
          this._panTimerId = 0;
          this._lastTouchEventType = "";
          this._lastTouchData = null;
          this.isAnimating = false;
          this.renderCount = 0;
          this.disableToolTip = this.animatedRender = false;
          this.canvasPool = new ab();
          this.allDOMEventHandlers = [];
          this.panEnabled = false;
          this._defaultCursor = "default";
          this.plotArea = { canvas: null, ctx: null, x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 };
          this._dataInRenderedOrder = [];
          (this.container = "string" === typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) ? (this.container.innerHTML = "", h2 = a = 0, a = this.options.width ? this.width : 0 < this.container.clientWidth ? this.container.clientWidth : this.width, h2 = c2 && c2.height ? c2.height : this.options.height ? this.height : 0 < this.container.clientHeight ? this.container.clientHeight : this.height, this.width = a, this.height = h2, this.x1 = this.y1 = 0, this.x2 = this.width, this.y2 = this.height, this.selectedColorSet = "undefined" !== typeof sa[this.colorSet] ? sa[this.colorSet] : sa.colorSet1, this._canvasJSContainer = document.createElement("div"), this._canvasJSContainer.setAttribute("class", "canvasjs-chart-container"), this._canvasJSContainer.style.position = "relative", this._canvasJSContainer.style.textAlign = "left", this._canvasJSContainer.style.cursor = "auto", this._canvasJSContainer.style.direction = "ltr", r || (this._canvasJSContainer.style.height = "0px"), this.container.appendChild(this._canvasJSContainer), this.canvas = ra(a, h2), this._preRenderCanvas = ra(a, h2), this.canvas.style.position = "absolute", this.canvas.style.WebkitUserSelect = "none", this.canvas.style.MozUserSelect = "none", this.canvas.style.msUserSelect = "none", this.canvas.style.userSelect = "none", this.canvas.getContext && (this._canvasJSContainer.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d"), this.ctx.textBaseline = "top", Da(this.ctx), this._preRenderCtx = this._preRenderCanvas.getContext("2d"), this._preRenderCtx.textBaseline = "top", Da(this._preRenderCtx), r ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = ra(a, h2), this.plotArea.canvas.style.position = "absolute", this.plotArea.canvas.setAttribute("class", "plotAreaCanvas"), this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext("2d")), this.overlaidCanvas = ra(a, h2), this.overlaidCanvas.style.position = "absolute", this.overlaidCanvas.style.webkitTapHighlightColor = "transparent", this.overlaidCanvas.style.WebkitUserSelect = "none", this.overlaidCanvas.style.MozUserSelect = "none", this.overlaidCanvas.style.msUserSelect = "none", this.overlaidCanvas.style.userSelect = "none", this.overlaidCanvas.getContext && (this._canvasJSContainer.appendChild(this.overlaidCanvas), this.overlaidCanvasCtx = this.overlaidCanvas.getContext("2d"), this.overlaidCanvasCtx.textBaseline = "top", Da(this.overlaidCanvasCtx)), this._eventManager = new ia2(this), this.windowResizeHandler = D(window, "resize", function() {
            b._updateSize() && b.render();
          }, this.allDOMEventHandlers), this._toolBar = document.createElement("div"), this._toolBar.setAttribute("class", "canvasjs-chart-toolbar"), O(this._toolBar, {
            position: "absolute",
            right: "1px",
            top: "1px"
          }), this._canvasJSContainer.appendChild(this._toolBar), this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height }, D(this.overlaidCanvas, "click", function(a2) {
            b._mouseEventHandler(a2);
          }, this.allDOMEventHandlers), D(this.overlaidCanvas, "mousemove", function(a2) {
            b._mouseEventHandler(a2);
          }, this.allDOMEventHandlers), D(this.overlaidCanvas, "mouseup", function(a2) {
            b._mouseEventHandler(a2);
          }, this.allDOMEventHandlers), D(
            this.overlaidCanvas,
            "mousedown",
            function(a2) {
              b._mouseEventHandler(a2);
              ya(b._dropdownMenu);
            },
            this.allDOMEventHandlers
          ), D(this.overlaidCanvas, "mouseout", function(a2) {
            b._mouseEventHandler(a2);
          }, this.allDOMEventHandlers), D(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", function(a2) {
            b._touchEventHandler(a2);
          }, this.allDOMEventHandlers), D(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerMove" : "touchmove", function(a2) {
            b._touchEventHandler(a2);
          }, this.allDOMEventHandlers), D(
            this.overlaidCanvas,
            window.navigator.msPointerEnabled ? "MSPointerUp" : "touchend",
            function(a2) {
              b._touchEventHandler(a2);
            },
            this.allDOMEventHandlers
          ), D(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerCancel" : "touchcancel", function(a2) {
            b._touchEventHandler(a2);
          }, this.allDOMEventHandlers), this.toolTip = new pa(this, this.options.toolTip), this.data = null, this.axisX = [], this.axisX2 = [], this.axisY = [], this.axisY2 = [], this.sessionVariables = { axisX: [], axisX2: [], axisY: [], axisY2: [] })) : window.console && window.console.log('CanvasJS Error: Chart Container with id "' + this._containerId + '" was not found');
        }
        function x2(a, h2) {
          for (var c2 = [], b, e = 0; e < a.length; e++)
            if (0 == e)
              c2.push(a[0]);
            else {
              var l2, C2, f3;
              f3 = e - 1;
              l2 = 0 === f3 ? 0 : f3 - 1;
              C2 = f3 === a.length - 1 ? f3 : f3 + 1;
              b = Math.abs((a[C2].x - a[l2].x) / (0 === a[C2].x - a[f3].x ? 0.01 : a[C2].x - a[f3].x)) * (h2 - 1) / 2 + 1;
              var d3 = (a[C2].x - a[l2].x) / b;
              b = (a[C2].y - a[l2].y) / b;
              c2[c2.length] = a[f3].x > a[l2].x && 0 < d3 || a[f3].x < a[l2].x && 0 > d3 ? { x: a[f3].x + d3 / 3, y: a[f3].y + b / 3 } : { x: a[f3].x, y: a[f3].y + (1 === c2.length ? 0 : b / 9) };
              f3 = e;
              l2 = 0 === f3 ? 0 : f3 - 1;
              C2 = f3 === a.length - 1 ? f3 : f3 + 1;
              b = Math.abs((a[C2].x - a[l2].x) / (0 === a[f3].x - a[l2].x ? 0.01 : a[f3].x - a[l2].x)) * (h2 - 1) / 2 + 1;
              d3 = (a[C2].x - a[l2].x) / b;
              b = (a[C2].y - a[l2].y) / b;
              c2[c2.length] = a[f3].x > a[l2].x && 0 < d3 || a[f3].x < a[l2].x && 0 > d3 ? { x: a[f3].x - d3 / 3, y: a[f3].y - b / 3 } : { x: a[f3].x, y: a[f3].y - b / 9 };
              c2[c2.length] = a[e];
            }
          return c2;
        }
        function F2(a, h2, c2, b, e, l2, C2, f3, d3, m) {
          var n = 0;
          m ? (C2.color = l2, f3.color = l2) : m = 1;
          n = d3 ? Math.abs(e - c2) : Math.abs(b - h2);
          n = 0 < C2.trimLength ? Math.abs(n * C2.trimLength / 100) : Math.abs(n - C2.length);
          d3 ? (c2 += n / 2, e -= n / 2) : (h2 += n / 2, b -= n / 2);
          var n = 1 === Math.round(C2.thickness) % 2 ? 0.5 : 0, p = 1 === Math.round(f3.thickness) % 2 ? 0.5 : 0;
          a.save();
          a.globalAlpha = m;
          a.strokeStyle = f3.color || l2;
          a.lineWidth = f3.thickness || 2;
          a.setLineDash && a.setLineDash(R(f3.dashType, f3.thickness));
          a.beginPath();
          d3 && 0 < f3.thickness ? (a.moveTo(b - C2.thickness / 2, Math.round((c2 + e) / 2) - p), a.lineTo(h2 + C2.thickness / 2, Math.round((c2 + e) / 2) - p)) : 0 < f3.thickness && (a.moveTo(Math.round((h2 + b) / 2) - p, c2 + C2.thickness / 2), a.lineTo(Math.round((h2 + b) / 2) - p, e - C2.thickness / 2));
          a.stroke();
          a.strokeStyle = C2.color || l2;
          a.lineWidth = C2.thickness || 2;
          a.setLineDash && a.setLineDash(R(C2.dashType, C2.thickness));
          a.beginPath();
          d3 && 0 < C2.thickness ? (a.moveTo(b - n, c2), a.lineTo(b - n, e), a.moveTo(h2 + n, c2), a.lineTo(h2 + n, e)) : 0 < C2.thickness && (a.moveTo(h2, c2 + n), a.lineTo(b, c2 + n), a.moveTo(h2, e - n), a.lineTo(b, e - n));
          a.stroke();
          a.restore();
        }
        function L2(a, h2) {
          L2.base.constructor.call(this, "Legend", "legend", h2, null, a);
          this.chart = a;
          this.canvas = a.canvas;
          this.ctx = this.chart.ctx;
          this.ghostCtx = this.chart._eventManager.ghostCtx;
          this.items = [];
          this.optionsName = "legend";
          this.height = this.width = 0;
          this.orientation = null;
          this.dataSeries = [];
          this.bounds = { x1: null, y1: null, x2: null, y2: null };
          "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
          this.lineHeight = eb(this.fontFamily, this.fontSize, this.fontWeight);
          this.horizontalSpacing = this.fontSize;
        }
        function P(a, h2, c2, b) {
          P.base.constructor.call(this, "DataSeries", "data", h2, c2, a);
          this.chart = a;
          this.canvas = a.canvas;
          this._ctx = a.canvas.ctx;
          this.index = c2;
          this.noDataPointsInPlotArea = 0;
          this.id = b;
          this.chart._eventManager.objectMap[b] = { id: b, objectType: "dataSeries", dataSeriesIndex: c2 };
          a = h2.dataPoints ? h2.dataPoints.length : 0;
          this.dataPointEOs = [];
          for (h2 = 0; h2 < a; h2++)
            this.dataPointEOs[h2] = {};
          this.dataPointIds = [];
          this.plotUnit = [];
          this.axisY = this.axisX = null;
          this.optionsName = "data";
          this.isOptionsInArray = true;
          null === this.fillOpacity && (this.type.match(/area/i) ? this.fillOpacity = 0.7 : this.fillOpacity = 1);
          this.axisPlacement = this.getDefaultAxisPlacement();
          "undefined" === typeof this.options.indexLabelFontSize && (this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize));
        }
        function A(a, h2, c2, b, e, l2) {
          A.base.constructor.call(this, "Axis", h2, c2, b, a);
          this.chart = a;
          this.canvas = a.canvas;
          this.ctx = a.ctx;
          this.intervalStartPosition = this.maxHeight = this.maxWidth = 0;
          this.labels = [];
          this.dataSeries = [];
          this._stripLineLabels = this._ticks = this._labels = null;
          this.dataInfo = { min: Infinity, max: -Infinity, viewPortMin: Infinity, viewPortMax: -Infinity, minDiff: Infinity };
          this.isOptionsInArray = true;
          "axisX" === e ? ("left" === l2 || "bottom" === l2 ? (this.optionsName = "axisX", f2(this.chart.sessionVariables.axisX[b]) && (this.chart.sessionVariables.axisX[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisX[b]) : (this.optionsName = "axisX2", f2(this.chart.sessionVariables.axisX2[b]) && (this.chart.sessionVariables.axisX2[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisX2[b]), this.options.interval || (this.intervalType = null)) : "left" === l2 || "bottom" === l2 ? (this.optionsName = "axisY", f2(this.chart.sessionVariables.axisY[b]) && (this.chart.sessionVariables.axisY[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisY[b]) : (this.optionsName = "axisY2", f2(this.chart.sessionVariables.axisY2[b]) && (this.chart.sessionVariables.axisY2[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisY2[b]);
          "undefined" === typeof this.options.titleFontSize && (this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize));
          "undefined" === typeof this.options.labelFontSize && (this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize));
          this.type = e;
          "axisX" !== e || c2 && "undefined" !== typeof c2.gridThickness || (this.gridThickness = 0);
          this._position = l2;
          this.lineCoordinates = { x1: null, y1: null, x2: null, y2: null, width: null };
          this.labelAngle = (this.labelAngle % 360 + 360) % 360;
          90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360);
          this.options.scaleBreaks && (this.scaleBreaks = new M2(this.chart, this.options.scaleBreaks, ++this.chart._eventManager.lastObjectId, this));
          this.stripLines = [];
          if (this.options.stripLines && 0 < this.options.stripLines.length)
            for (a = 0; a < this.options.stripLines.length; a++)
              this.stripLines.push(new Q(this.chart, this.options.stripLines[a], a, ++this.chart._eventManager.lastObjectId, this));
          this.options.crosshair && (this.crosshair = new X2(
            this.chart,
            this.options.crosshair,
            this
          ));
          this._titleTextBlock = null;
          this.hasOptionChanged("viewportMinimum") && null === this.viewportMinimum && (this.options.viewportMinimum = void 0, this.sessionVariables.viewportMinimum = null);
          this.hasOptionChanged("viewportMinimum") || isNaN(this.sessionVariables.newViewportMinimum) || null === this.sessionVariables.newViewportMinimum ? this.sessionVariables.newViewportMinimum = null : this.viewportMinimum = this.sessionVariables.newViewportMinimum;
          this.hasOptionChanged("viewportMaximum") && null === this.viewportMaximum && (this.options.viewportMaximum = void 0, this.sessionVariables.viewportMaximum = null);
          this.hasOptionChanged("viewportMaximum") || isNaN(this.sessionVariables.newViewportMaximum) || null === this.sessionVariables.newViewportMaximum ? this.sessionVariables.newViewportMaximum = null : this.viewportMaximum = this.sessionVariables.newViewportMaximum;
          null !== this.minimum && null !== this.viewportMinimum && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));
          null !== this.maximum && null !== this.viewportMaximum && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));
          this.trackChanges("viewportMinimum");
          this.trackChanges("viewportMaximum");
        }
        function M2(a, h2, c2, b) {
          M2.base.constructor.call(this, "ScaleBreaks", "scaleBreaks", h2, null, b);
          this.id = c2;
          this.chart = a;
          this.ctx = this.chart.ctx;
          this.axis = b;
          this.optionsName = "scaleBreaks";
          this.isOptionsInArray = false;
          this._appliedBreaks = [];
          this.customBreaks = [];
          this.autoBreaks = [];
          "string" === typeof this.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 8 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.spacing && (this.spacing = 8);
          this.autoCalculate && (this.maxNumberOfAutoBreaks = Math.min(this.maxNumberOfAutoBreaks, 5));
          if (this.options.customBreaks && 0 < this.options.customBreaks.length) {
            for (a = 0; a < this.options.customBreaks.length; a++)
              this.customBreaks.push(new T2(this.chart, "customBreaks", this.options.customBreaks[a], a, ++this.chart._eventManager.lastObjectId, this)), "number" === typeof this.customBreaks[a].startValue && ("number" === typeof this.customBreaks[a].endValue && this.customBreaks[a].endValue !== this.customBreaks[a].startValue) && this._appliedBreaks.push(this.customBreaks[a]);
            this._appliedBreaks.sort(function(a2, b2) {
              return a2.startValue - b2.startValue;
            });
            for (a = 0; a < this._appliedBreaks.length - 1; a++)
              this._appliedBreaks[a].endValue >= this._appliedBreaks[a + 1].startValue && (this._appliedBreaks[a].endValue = Math.max(this._appliedBreaks[a].endValue, this._appliedBreaks[a + 1].endValue), window.console && window.console.log("CanvasJS Error: Breaks " + a + " and " + (a + 1) + " are overlapping."), this._appliedBreaks.splice(a, 2), a--);
          }
        }
        function T2(a, h2, c2, b, e, l2) {
          T2.base.constructor.call(this, "Break", h2, c2, b, l2);
          this.id = e;
          this.chart = a;
          this.ctx = this.chart.ctx;
          this.scaleBreaks = l2;
          this.optionsName = h2;
          this.isOptionsInArray = true;
          this.type = c2.type ? this.type : l2.type;
          this.fillOpacity = f2(c2.fillOpacity) ? l2.fillOpacity : this.fillOpacity;
          this.lineThickness = f2(c2.lineThickness) ? l2.lineThickness : this.lineThickness;
          this.color = c2.color ? this.color : l2.color;
          this.lineColor = c2.lineColor ? this.lineColor : l2.lineColor;
          this.lineDashType = c2.lineDashType ? this.lineDashType : l2.lineDashType;
          !f2(this.startValue) && this.startValue.getTime && (this.startValue = this.startValue.getTime());
          !f2(this.endValue) && this.endValue.getTime && (this.endValue = this.endValue.getTime());
          "number" === typeof this.startValue && ("number" === typeof this.endValue && this.endValue < this.startValue) && (a = this.startValue, this.startValue = this.endValue, this.endValue = a);
          this.spacing = "undefined" === typeof c2.spacing ? l2.spacing : c2.spacing;
          "string" === typeof this.options.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 0 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.options.spacing && (this.spacing = l2.spacing);
          this.size = l2.parent.logarithmic ? 1 : 0;
        }
        function Q(a, h2, c2, b, e) {
          Q.base.constructor.call(this, "StripLine", "stripLines", h2, c2, e);
          this.id = b;
          this.chart = a;
          this.ctx = this.chart.ctx;
          this.label = this.label;
          this.axis = e;
          this.optionsName = "stripLines";
          this.isOptionsInArray = true;
          this._thicknessType = "pixel";
          null !== this.startValue && null !== this.endValue && (this.value = e.logarithmic ? Math.sqrt((this.startValue.getTime ? this.startValue.getTime() : this.startValue) * (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) : ((this.startValue.getTime ? this.startValue.getTime() : this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2, this._thicknessType = null);
        }
        function X2(a, h2, c2) {
          X2.base.constructor.call(this, "Crosshair", "crosshair", h2, null, c2);
          this.chart = a;
          this.ctx = this.chart.ctx;
          this.axis = c2;
          this.optionsName = "crosshair";
          this._thicknessType = "pixel";
        }
        function pa(a, h2) {
          pa.base.constructor.call(
            this,
            "ToolTip",
            "toolTip",
            h2,
            null,
            a
          );
          this.chart = a;
          this.canvas = a.canvas;
          this.ctx = this.chart.ctx;
          this.currentDataPointIndex = this.currentSeriesIndex = -1;
          this._prevY = this._prevX = NaN;
          this.containerTransitionDuration = 0.1;
          this.mozContainerTransition = this.getContainerTransition(this.containerTransitionDuration);
          this.optionsName = "toolTip";
          this._initialize();
        }
        function ia2(a) {
          this.chart = a;
          this.lastObjectId = 0;
          this.objectMap = [];
          this.rectangularRegionEventSubscriptions = [];
          this.previousDataPointEventObject = null;
          this.ghostCanvas = ra(
            this.chart.width,
            this.chart.height,
            true
          );
          this.ghostCtx = this.ghostCanvas.getContext("2d");
          this.mouseoveredObjectMaps = [];
        }
        function la2(a) {
          this.chart = a;
          this.ctx = this.chart.plotArea.ctx;
          this.animations = [];
          this.animationRequestId = null;
        }
        ga(w, $);
        w.prototype.destroy = function() {
          var a = this.allDOMEventHandlers;
          this._animator && this._animator.cancelAllAnimations();
          this._panTimerId && clearTimeout(this._panTimerId);
          for (var h2 = 0; h2 < a.length; h2++)
            gb(a[h2][0], a[h2][1], a[h2][2], a[h2][3]);
          this.allDOMEventHandlers = [];
          for (this.removeAllEventListeners(); this._canvasJSContainer && this._canvasJSContainer.hasChildNodes(); )
            this._canvasJSContainer.removeChild(this._canvasJSContainer.lastChild);
          for (; this.container && this.container.hasChildNodes(); )
            this.container.removeChild(this.container.lastChild);
          for (; this._dropdownMenu && this._dropdownMenu.hasChildNodes(); )
            this._dropdownMenu.removeChild(this._dropdownMenu.lastChild);
          this.container = this._canvasJSContainer = null;
          this.toolTip.container = null;
          this.canvas && Ca(this.canvas);
          this.overlaidCanvas && Ca(this.overlaidCanvas);
          this._preRenderCanvas && Ca(this._preRenderCanvas);
          this._breaksCanvas && Ca(this._breaksCanvas);
          this._eventManager && this._eventManager.ghostCanvas && Ca(this._eventManager.ghostCanvas);
          this._toolBar = this._dropdownMenu = this._menuButton = this._resetButton = this._zoomButton = null;
        };
        w.prototype._updateOptions = function() {
          var a = this;
          this.updateOption("width");
          this.updateOption("height");
          this.updateOption("dataPointWidth");
          this.updateOption("dataPointMinWidth");
          this.updateOption("dataPointMaxWidth");
          this.updateOption("interactivityEnabled");
          this.updateOption("theme");
          this.updateOption("colorSet") && (this.selectedColorSet = "undefined" !== typeof sa[this.colorSet] ? sa[this.colorSet] : sa.colorSet1);
          this.updateOption("backgroundColor");
          this.stockChart && (this.stockChart.options && "undefined" !== typeof this.stockChart.options.backgroundColor && f2(this.options.backgroundColor)) && (this.backgroundColor = this.stockChart.backgroundColor);
          this.backgroundColor || (this.backgroundColor = "rgba(0,0,0,0)");
          this.updateOption("culture");
          this._cultureInfo = new Oa(this.options.culture);
          this.updateOption("animationEnabled");
          this.animationEnabled = this.animationEnabled && r;
          this.updateOption("animationDuration");
          this.updateOption("rangeChanging");
          this.updateOption("rangeChanged");
          this.updateOption("exportEnabled");
          this.updateOption("exportFileName");
          this.updateOption("zoomType");
          this.toolbar = new Xa(this, this.options.toolbar);
          if (this.options.zoomEnabled || this.panEnabled) {
            if (this._zoomButton)
              O(this._zoomButton, {
                borderRight: this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor,
                backgroundColor: a.toolbar.itemBackgroundColor,
                color: a.toolbar.fontColor
              }), xa(this, this._zoomButton, "zoom");
            else {
              var h2 = false;
              ya(this._zoomButton = document.createElement("button"));
              xa(this, this._zoomButton, "pan");
              this._toolBar.appendChild(this._zoomButton);
              this._zoomButton.style.borderRight = this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor;
              D(this._zoomButton, "touchstart", function(a2) {
                h2 = true;
              }, this.allDOMEventHandlers);
              D(this._zoomButton, "click", function() {
                a.zoomEnabled ? (a.zoomEnabled = false, a.panEnabled = true, xa(a, a._zoomButton, "zoom")) : (a.zoomEnabled = true, a.panEnabled = false, xa(a, a._zoomButton, "pan"));
                a.render();
              }, this.allDOMEventHandlers);
              D(this._zoomButton, "mousemove", function() {
                h2 ? h2 = false : (O(a._zoomButton, { backgroundColor: a.toolbar.itemBackgroundColorOnHover, color: a.toolbar.fontColorOnHover, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && O(a._zoomButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" }));
              }, this.allDOMEventHandlers);
              D(
                this._zoomButton,
                "mouseout",
                function() {
                  h2 || (O(a._zoomButton, { backgroundColor: a.toolbar.itemBackgroundColor, color: a.toolbar.fontColor, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && O(a._zoomButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" }));
                },
                this.allDOMEventHandlers
              );
            }
            this._resetButton ? (O(this._resetButton, { borderRight: this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor, backgroundColor: a.toolbar.itemBackgroundColor, color: a.toolbar.fontColor }), this._resetButton.title = this._cultureInfo.resetText) : (h2 = false, ya(this._resetButton = document.createElement("button")), xa(this, this._resetButton, "reset"), this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.buttonBorderThickness : 0) + "px solid " + this.toolbar.buttonBorderColor, this._toolBar.appendChild(this._resetButton), D(this._resetButton, "touchstart", function(a2) {
              h2 = true;
            }, this.allDOMEventHandlers), D(this._resetButton, "click", function() {
              a.toolTip.hide();
              a.toolTip && a.toolTip.enabled && a.toolTip.dispatchEvent(
                "hidden",
                { chart: a, toolTip: a.toolTip },
                a.toolTip
              );
              a.zoomEnabled || a.panEnabled ? (a.zoomEnabled = true, a.panEnabled = false, xa(a, a._zoomButton, "pan"), a._defaultCursor = "default", a.overlaidCanvas.style.cursor = a._defaultCursor) : (a.zoomEnabled = false, a.panEnabled = false);
              if (a.sessionVariables.axisX)
                for (var b = 0; b < a.sessionVariables.axisX.length; b++)
                  a.sessionVariables.axisX[b].newViewportMinimum = null, a.sessionVariables.axisX[b].newViewportMaximum = null;
              if (a.sessionVariables.axisX2)
                for (b = 0; b < a.sessionVariables.axisX2.length; b++)
                  a.sessionVariables.axisX2[b].newViewportMinimum = null, a.sessionVariables.axisX2[b].newViewportMaximum = null;
              if (a.sessionVariables.axisY)
                for (b = 0; b < a.sessionVariables.axisY.length; b++)
                  a.sessionVariables.axisY[b].newViewportMinimum = null, a.sessionVariables.axisY[b].newViewportMaximum = null;
              if (a.sessionVariables.axisY2)
                for (b = 0; b < a.sessionVariables.axisY2.length; b++)
                  a.sessionVariables.axisY2[b].newViewportMinimum = null, a.sessionVariables.axisY2[b].newViewportMaximum = null;
              a.resetOverlayedCanvas();
              0 >= navigator.userAgent.search("MSIE") && O(
                a._resetButton.childNodes[0],
                { WebkitFilter: "invert(0%)", filter: "invert(0%)" }
              );
              ya(a._zoomButton, a._resetButton);
              a.stockChart && (a.stockChart._rangeEventParameter = { stockChart: a.stockChart, source: "chart", index: a.stockChart.charts.indexOf(a), minimum: null, maximum: null });
              a._dispatchRangeEvent("rangeChanging", "reset");
              a.stockChart && (a.stockChart._rangeEventParameter.type = "rangeChanging", a.stockChart.dispatchEvent("rangeChanging", a.stockChart._rangeEventParameter, a.stockChart));
              a.render();
              a.syncCharts && a.syncCharts(null, null);
              a._dispatchRangeEvent(
                "rangeChanged",
                "reset"
              );
              a.stockChart && (a.stockChart._rangeEventParameter.type = "rangeChanged", a.stockChart.dispatchEvent("rangeChanged", a.stockChart._rangeEventParameter, a.stockChart));
            }, this.allDOMEventHandlers), D(
              this._resetButton,
              "mousemove",
              function() {
                h2 || (O(a._resetButton, { backgroundColor: a.toolbar.itemBackgroundColorOnHover, color: a.toolbar.fontColorOnHover, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && O(a._resetButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" }));
              },
              this.allDOMEventHandlers
            ), D(this._resetButton, "mouseout", function() {
              h2 || (O(a._resetButton, { backgroundColor: a.toolbar.itemBackgroundColor, color: a.toolbar.fontColor, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && O(a._resetButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" }));
            }, this.allDOMEventHandlers), this.overlaidCanvas.style.cursor = a._defaultCursor);
            this.zoomEnabled || this.panEnabled || (this._zoomButton ? (a._zoomButton.getAttribute("state") === a._cultureInfo.zoomText ? (this.panEnabled = true, this.zoomEnabled = false) : (this.zoomEnabled = true, this.panEnabled = false), Ta(a._zoomButton, a._resetButton)) : (this.zoomEnabled = true, this.panEnabled = false));
          } else
            this.panEnabled = this.zoomEnabled = false;
          ib(this);
          "none" !== this._toolBar.style.display && this._zoomButton && (this.panEnabled ? xa(a, a._zoomButton, "zoom") : xa(a, a._zoomButton, "pan"), a._resetButton.getAttribute("state") !== a._cultureInfo.resetText && xa(a, a._resetButton, "reset"));
          this.options.toolTip && this.toolTip.options !== this.options.toolTip && (this.toolTip.options = this.options.toolTip);
          for (var c2 in this.toolTip.options)
            this.toolTip.options.hasOwnProperty(c2) && this.toolTip.updateOption(c2);
        };
        w.prototype._updateSize = function() {
          return lb.call(this, [this.canvas, this.overlaidCanvas, this._eventManager.ghostCanvas]);
        };
        w.prototype._initialize = function() {
          this.isNavigator = f2(this.parent) || f2(this.parent._defaultsKey) || "Navigator" !== this.parent._defaultsKey ? false : true;
          this._animator ? this._animator.cancelAllAnimations() : this._animator = new la2(this);
          this.removeAllEventListeners();
          this.disableToolTip = false;
          this._axes = [];
          this.funnelPyramidClickHandler = this.pieDoughnutClickHandler = null;
          this._updateOptions();
          this.animatedRender = r && this.animationEnabled && 0 === this.renderCount;
          this._updateSize();
          this.clearCanvas();
          this.ctx.beginPath();
          this.axisX = [];
          this.axisX2 = [];
          this.axisY = [];
          this.axisY2 = [];
          this._indexLabels = [];
          this._dataInRenderedOrder = [];
          this._events = [];
          this._eventManager && this._eventManager.reset();
          this.plotInfo = { axisPlacement: null, plotTypes: [] };
          this.layoutManager = new Ka(
            0,
            0,
            this.width,
            this.height,
            this.isNavigator ? 0 : 2
          );
          this.plotArea.layoutManager && this.plotArea.layoutManager.reset();
          this.data = [];
          this.title = null;
          this.subtitles = [];
          var a = 0, h2 = null;
          if (this.options.data) {
            for (var c2 = 0; c2 < this.options.data.length; c2++)
              if (a++, !this.options.data[c2].type || 0 <= w._supportedChartTypes.indexOf(this.options.data[c2].type)) {
                var b = new P(this, this.options.data[c2], a - 1, ++this._eventManager.lastObjectId);
                if (!f2(b) && b.dataPoints) {
                  for (var e = 0; e < b.dataPoints.length; e++)
                    if (b.dataPoints[e].x && b.dataPoints[e].x.getTime) {
                      b.xValueType = "dateTime";
                      break;
                    }
                }
                "error" === b.type && (b.linkedDataSeriesIndex = f2(this.options.data[c2].linkedDataSeriesIndex) ? c2 - 1 : this.options.data[c2].linkedDataSeriesIndex, 0 > b.linkedDataSeriesIndex || b.linkedDataSeriesIndex >= this.options.data.length || "number" !== typeof b.linkedDataSeriesIndex || "error" === this.options.data[b.linkedDataSeriesIndex].type) && (b.linkedDataSeriesIndex = null);
                null === b.name && (b.name = "DataSeries " + a);
                null === b.color ? 1 < this.options.data.length ? (b._colorSet = [this.selectedColorSet[b.index % this.selectedColorSet.length]], b.color = this.selectedColorSet[b.index % this.selectedColorSet.length]) : b._colorSet = "line" === b.type || "stepLine" === b.type || "spline" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "stackedArea" === b.type || "stackedArea100" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "candlestick" === b.type || "ohlc" === b.type || "waterfall" === b.type || "boxAndWhisker" === b.type ? [this.selectedColorSet[0]] : this.selectedColorSet : b._colorSet = [b.color];
                null === b.markerSize && (("line" === b.type || "stepLine" === b.type || "spline" === b.type || 0 <= b.type.toLowerCase().indexOf("area")) && b.dataPoints && b.dataPoints.length < this.width / 16 || "scatter" === b.type) && (b.markerSize = 8);
                "bubble" !== b.type && "scatter" !== b.type || !b.dataPoints || (b.dataPoints.some ? b.dataPoints.some(function(a2) {
                  return a2.x;
                }) && b.dataPoints.sort(k2) : b.dataPoints.sort(k2));
                this.data.push(b);
                var e = b.axisPlacement, h2 = h2 || e, l2;
                "normal" === e ? "xySwapped" === this.plotInfo.axisPlacement ? l2 = 'You cannot combine "' + b.type + '" with bar chart' : "none" === this.plotInfo.axisPlacement ? l2 = 'You cannot combine "' + b.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "normal") : "xySwapped" === e ? "normal" === this.plotInfo.axisPlacement ? l2 = 'You cannot combine "' + b.type + '" with line, area, column or pie chart' : "none" === this.plotInfo.axisPlacement ? l2 = 'You cannot combine "' + b.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "xySwapped") : "none" === e ? "normal" === this.plotInfo.axisPlacement ? l2 = 'You cannot combine "' + b.type + '" with line, area, column or bar chart' : "xySwapped" === this.plotInfo.axisPlacement ? l2 = 'You cannot combine "' + b.type + '" with bar chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "none") : null === e && "none" === this.plotInfo.axisPlacement && (l2 = 'You cannot combine "' + b.type + '" with pie chart');
                if (l2 && window.console) {
                  window.console.log(l2);
                  return;
                }
              }
            for (c2 = 0; c2 < this.data.length; c2++) {
              if ("none" == h2 && "error" === this.data[c2].type && window.console) {
                window.console.log('You cannot combine "' + b.type + '" with error chart');
                return;
              }
              "error" === this.data[c2].type && (this.data[c2].axisPlacement = this.plotInfo.axisPlacement = h2 || "normal", this.data[c2]._linkedSeries = null === this.data[c2].linkedDataSeriesIndex ? null : this.data[this.data[c2].linkedDataSeriesIndex]);
            }
          }
          this._objectsInitialized = true;
          this._plotAreaElements = [];
        };
        w._supportedChartTypes = Ea("line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeBar rangeArea rangeSplineArea pie doughnut funnel pyramid waterfall".split(" "));
        w.prototype.setLayout = function() {
          for (var a = this._plotAreaElements, h2 = 0; h2 < this.data.length; h2++)
            if ("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) {
              if (!this.data[h2].axisYType || "primary" === this.data[h2].axisYType)
                if (this.options.axisY && 0 < this.options.axisY.length) {
                  if (!this.axisY.length)
                    for (var c2 = 0; c2 < this.options.axisY.length; c2++)
                      "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[c2] = new A(this, "axisY", this.options.axisY[c2], c2, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[c2] = new A(this, "axisY", this.options.axisY[c2], c2, "axisY", "bottom"));
                  this.data[h2].axisY = this.axisY[0 <= this.data[h2].axisYIndex && this.data[h2].axisYIndex < this.axisY.length ? this.data[h2].axisYIndex : 0];
                  this.axisY[0 <= this.data[h2].axisYIndex && this.data[h2].axisYIndex < this.axisY.length ? this.data[h2].axisYIndex : 0].dataSeries.push(this.data[h2]);
                } else
                  this.axisY.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[0] = new A(
                    this,
                    "axisY",
                    this.options.axisY,
                    0,
                    "axisY",
                    "left"
                  )) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[0] = new A(this, "axisY", this.options.axisY, 0, "axisY", "bottom"))), this.data[h2].axisY = this.axisY[0], this.axisY[0].dataSeries.push(this.data[h2]);
              if ("secondary" === this.data[h2].axisYType)
                if (this.options.axisY2 && 0 < this.options.axisY2.length) {
                  if (!this.axisY2.length)
                    for (c2 = 0; c2 < this.options.axisY2.length; c2++)
                      "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[c2] = new A(
                        this,
                        "axisY2",
                        this.options.axisY2[c2],
                        c2,
                        "axisY",
                        "right"
                      )) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[c2] = new A(this, "axisY2", this.options.axisY2[c2], c2, "axisY", "top"));
                  this.data[h2].axisY = this.axisY2[0 <= this.data[h2].axisYIndex && this.data[h2].axisYIndex < this.axisY2.length ? this.data[h2].axisYIndex : 0];
                  this.axisY2[0 <= this.data[h2].axisYIndex && this.data[h2].axisYIndex < this.axisY2.length ? this.data[h2].axisYIndex : 0].dataSeries.push(this.data[h2]);
                } else
                  this.axisY2.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[0] = new A(this, "axisY2", this.options.axisY2, 0, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[0] = new A(this, "axisY2", this.options.axisY2, 0, "axisY", "top"))), this.data[h2].axisY = this.axisY2[0], this.axisY2[0].dataSeries.push(this.data[h2]);
              if (!this.data[h2].axisXType || "primary" === this.data[h2].axisXType)
                if (this.options.axisX && 0 < this.options.axisX.length) {
                  if (!this.axisX.length)
                    for (c2 = 0; c2 < this.options.axisX.length; c2++)
                      "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[c2] = new A(this, "axisX", this.options.axisX[c2], c2, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[c2] = new A(this, "axisX", this.options.axisX[c2], c2, "axisX", "left"));
                  this.data[h2].axisX = this.axisX[0 <= this.data[h2].axisXIndex && this.data[h2].axisXIndex < this.axisX.length ? this.data[h2].axisXIndex : 0];
                  this.axisX[0 <= this.data[h2].axisXIndex && this.data[h2].axisXIndex < this.axisX.length ? this.data[h2].axisXIndex : 0].dataSeries.push(this.data[h2]);
                } else
                  this.axisX.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[0] = new A(this, "axisX", this.options.axisX, 0, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[0] = new A(this, "axisX", this.options.axisX, 0, "axisX", "left"))), this.data[h2].axisX = this.axisX[0], this.axisX[0].dataSeries.push(this.data[h2]);
              if ("secondary" === this.data[h2].axisXType)
                if (this.options.axisX2 && 0 < this.options.axisX2.length) {
                  if (!this.axisX2.length)
                    for (c2 = 0; c2 < this.options.axisX2.length; c2++)
                      "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[c2] = new A(this, "axisX2", this.options.axisX2[c2], c2, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[c2] = new A(this, "axisX2", this.options.axisX2[c2], c2, "axisX", "right"));
                  this.data[h2].axisX = this.axisX2[0 <= this.data[h2].axisXIndex && this.data[h2].axisXIndex < this.axisX2.length ? this.data[h2].axisXIndex : 0];
                  this.axisX2[0 <= this.data[h2].axisXIndex && this.data[h2].axisXIndex < this.axisX2.length ? this.data[h2].axisXIndex : 0].dataSeries.push(this.data[h2]);
                } else
                  this.axisX2.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[0] = new A(this, "axisX2", this.options.axisX2, 0, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[0] = new A(this, "axisX2", this.options.axisX2, 0, "axisX", "right"))), this.data[h2].axisX = this.axisX2[0], this.axisX2[0].dataSeries.push(this.data[h2]);
            }
          if (this.axisY) {
            for (c2 = 1; c2 < this.axisY.length; c2++)
              "undefined" === typeof this.axisY[c2].options.gridThickness && (this.axisY[c2].gridThickness = 0);
            for (c2 = 0; c2 < this.axisY.length - 1; c2++)
              "undefined" === typeof this.axisY[c2].options.margin && (this.axisY[c2].margin = 10);
          }
          if (this.axisY2) {
            for (c2 = 1; c2 < this.axisY2.length; c2++)
              "undefined" === typeof this.axisY2[c2].options.gridThickness && (this.axisY2[c2].gridThickness = 0);
            for (c2 = 0; c2 < this.axisY2.length - 1; c2++)
              "undefined" === typeof this.axisY2[c2].options.margin && (this.axisY2[c2].margin = 10);
          }
          this.axisY && 0 < this.axisY.length && (this.axisY2 && 0 < this.axisY2.length) && (0 < this.axisY[0].gridThickness && "undefined" === typeof this.axisY2[0].options.gridThickness ? this.axisY2[0].gridThickness = 0 : 0 < this.axisY2[0].gridThickness && "undefined" === typeof this.axisY[0].options.gridThickness && (this.axisY[0].gridThickness = 0));
          if (this.axisX)
            for (c2 = 0; c2 < this.axisX.length; c2++)
              "undefined" === typeof this.axisX[c2].options.gridThickness && (this.axisX[c2].gridThickness = 0);
          if (this.axisX2)
            for (c2 = 0; c2 < this.axisX2.length; c2++)
              "undefined" === typeof this.axisX2[c2].options.gridThickness && (this.axisX2[c2].gridThickness = 0);
          this.axisX && 0 < this.axisX.length && (this.axisX2 && 0 < this.axisX2.length) && (0 < this.axisX[0].gridThickness && "undefined" === typeof this.axisX2[0].options.gridThickness ? this.axisX2[0].gridThickness = 0 : 0 < this.axisX2[0].gridThickness && "undefined" === typeof this.axisX[0].options.gridThickness && (this.axisX[0].gridThickness = 0));
          c2 = false;
          if (0 < this._axes.length && this.options.zoomEnabled && (this.zoomEnabled || this.panEnabled)) {
            for (h2 = 0; h2 < this._axes.length; h2++)
              if (!f2(this._axes[h2].viewportMinimum) || !f2(this._axes[h2].viewportMaximum)) {
                c2 = true;
                break;
              }
          }
          c2 ? (Ta(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor, this._zoomButton.style.borderRight = this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor, this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.buttonBorderThickness : 0) + "px solid " + this.toolbar.buttonBorderColor) : (ya(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.buttonBorderThickness + "px solid transparent", this.options.zoomEnabled && (this.zoomEnabled = true, this.panEnabled = false));
          qb(this);
          this._processData();
          this.options.title && (this.title = new Ha(this, this.options.title), this.title.dockInsidePlotArea ? a.push(this.title) : this.title.setLayout());
          if (this.options.subtitles)
            for (h2 = 0; h2 < this.options.subtitles.length; h2++)
              c2 = new Na(this, this.options.subtitles[h2], h2), this.subtitles.push(c2), c2.dockInsidePlotArea ? a.push(c2) : c2.setLayout();
          this.legend = new L2(this, this.options.legend);
          for (h2 = 0; h2 < this.data.length; h2++)
            (this.data[h2].showInLegend || "pie" === this.data[h2].type || "doughnut" === this.data[h2].type || "funnel" === this.data[h2].type || "pyramid" === this.data[h2].type) && this.legend.dataSeries.push(this.data[h2]);
          this.legend.dockInsidePlotArea ? a.push(this.legend) : this.legend.setLayout();
          for (h2 = 0; h2 < this._axes.length; h2++)
            if (this._axes[h2].scaleBreaks && this._axes[h2].scaleBreaks._appliedBreaks.length) {
              r ? (this._breaksCanvas = ra(this.width, this.height, true), this._breaksCanvasCtx = this._breaksCanvas.getContext("2d")) : (this._breaksCanvas = this.canvas, this._breaksCanvasCtx = this.ctx);
              break;
            }
          this._preRenderCanvas = ra(this.width, this.height);
          this._preRenderCtx = this._preRenderCanvas.getContext("2d");
          "normal" !== this.plotInfo.axisPlacement && "xySwapped" !== this.plotInfo.axisPlacement || A.setLayout(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace());
        };
        w.prototype.renderElements = function() {
          if (this.height) {
            var a = this._plotAreaElements;
            this.title && !this.title.dockInsidePlotArea && this.title.render();
            for (var h2 = 0; h2 < this.subtitles.length; h2++)
              this.subtitles[h2].dockInsidePlotArea || this.subtitles[h2].render();
            this.legend.dockInsidePlotArea || this.legend.render();
            if ("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement)
              A.render(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement);
            else if ("none" === this.plotInfo.axisPlacement)
              this.preparePlotArea();
            else
              return;
            for (h2 = 0; h2 < a.length; h2++)
              a[h2].setLayout(), a[h2].render();
            var c2 = [];
            if (this.animatedRender) {
              var b = ra(this.width, this.height);
              b.getContext("2d").drawImage(this.canvas, 0, 0, this.width, this.height);
            }
            sb(this);
            var a = this.ctx.miterLimit, e;
            this.ctx.miterLimit = 3;
            r && this._breaksCanvas && (this._preRenderCtx.drawImage(this.canvas, 0, 0, this.width, this.height), this._preRenderCtx.drawImage(this._breaksCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx.globalCompositeOperation = "source-atop", this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), this._preRenderCtx.clearRect(0, 0, this.width, this.height));
            for (h2 = 0; h2 < this.plotInfo.plotTypes.length; h2++)
              for (var l2 = this.plotInfo.plotTypes[h2], C2 = 0; C2 < l2.plotUnits.length; C2++) {
                var f3 = l2.plotUnits[C2], d3 = null;
                f3.targetCanvas && Ca(f3.targetCanvas);
                f3.targetCanvas = null;
                this.animatedRender && (f3.targetCanvas = ra(this.width, this.height), f3.targetCanvasCtx = f3.targetCanvas.getContext("2d"), e = f3.targetCanvasCtx.miterLimit, f3.targetCanvasCtx.miterLimit = 3);
                "line" === f3.type ? d3 = this.renderLine(f3) : "stepLine" === f3.type ? d3 = this.renderStepLine(f3) : "spline" === f3.type ? d3 = this.renderSpline(f3) : "column" === f3.type ? d3 = this.renderColumn(f3) : "bar" === f3.type ? d3 = this.renderBar(f3) : "area" === f3.type ? d3 = this.renderArea(f3) : "stepArea" === f3.type ? d3 = this.renderStepArea(f3) : "splineArea" === f3.type ? d3 = this.renderSplineArea(f3) : "stackedColumn" === f3.type ? d3 = this.renderStackedColumn(f3) : "stackedColumn100" === f3.type ? d3 = this.renderStackedColumn100(f3) : "stackedBar" === f3.type ? d3 = this.renderStackedBar(f3) : "stackedBar100" === f3.type ? d3 = this.renderStackedBar100(f3) : "stackedArea" === f3.type ? d3 = this.renderStackedArea(f3) : "stackedArea100" === f3.type ? d3 = this.renderStackedArea100(f3) : "bubble" === f3.type ? d3 = d3 = this.renderBubble(f3) : "scatter" === f3.type ? d3 = this.renderScatter(f3) : "pie" === f3.type ? this.renderPie(f3) : "doughnut" === f3.type ? this.renderPie(f3) : "funnel" === f3.type ? d3 = this.renderFunnel(f3) : "pyramid" === f3.type ? d3 = this.renderFunnel(f3) : "candlestick" === f3.type ? d3 = this.renderCandlestick(f3) : "ohlc" === f3.type ? d3 = this.renderCandlestick(f3) : "rangeColumn" === f3.type ? d3 = this.renderRangeColumn(f3) : "error" === f3.type ? d3 = this.renderError(f3) : "rangeBar" === f3.type ? d3 = this.renderRangeBar(f3) : "rangeArea" === f3.type ? d3 = this.renderRangeArea(f3) : "rangeSplineArea" === f3.type ? d3 = this.renderRangeSplineArea(f3) : "waterfall" === f3.type ? d3 = this.renderWaterfall(f3) : "boxAndWhisker" === f3.type && (d3 = this.renderBoxAndWhisker(f3));
                for (var m = 0; m < f3.dataSeriesIndexes.length; m++)
                  this._dataInRenderedOrder.push(this.data[f3.dataSeriesIndexes[m]]);
                this.animatedRender && (f3.targetCanvasCtx.miterLimit = e, d3 && c2.push(d3));
              }
            this.ctx.miterLimit = a;
            this.animatedRender && this._breaksCanvasCtx && c2.push({ source: this._breaksCanvasCtx, dest: this.plotArea.ctx, animationCallback: s.fadeInAnimation, easingFunction: s.easing.easeInQuad, animationBase: 0, startTimePercent: 0.7 });
            this.animatedRender && 0 < this._indexLabels.length && (e = ra(this.width, this.height).getContext("2d"), Da(e), c2.push(this.renderIndexLabels(e)));
            var n = this;
            if (0 < c2.length)
              n.disableToolTip = true, n._animator.animate(200, n.animationDuration, function(a2) {
                n.ctx.clearRect(0, 0, n.width, n.height);
                n.ctx.drawImage(b, 0, 0, Math.floor(n.width * ja), Math.floor(n.height * ja), 0, 0, n.width, n.height);
                for (var e2 = 0; e2 < c2.length; e2++)
                  d3 = c2[e2], 1 > a2 && "undefined" !== typeof d3.startTimePercent ? a2 >= d3.startTimePercent && d3.animationCallback(
                    d3.easingFunction(a2 - d3.startTimePercent, 0, 1, 1 - d3.startTimePercent),
                    d3
                  ) : d3.animationCallback(d3.easingFunction(a2, 0, 1, 1), d3);
                n.dispatchEvent("dataAnimationIterationEnd", { chart: n });
              }, function() {
                c2 = [];
                for (var a2 = 0; a2 < n.plotInfo.plotTypes.length; a2++)
                  for (var e2 = n.plotInfo.plotTypes[a2], h3 = 0; h3 < e2.plotUnits.length; h3++) {
                    var l3 = e2.plotUnits[h3];
                    l3.targetCanvas && Ca(l3.targetCanvas);
                    l3.targetCanvas = null;
                  }
                b = null;
                n.disableToolTip = false;
                n.dispatchEvent("dataAnimationEnd", { chart: n });
              });
            else {
              if (n._breaksCanvas)
                if (r)
                  n.plotArea.ctx.drawImage(n._breaksCanvas, 0, 0, this.width, this.height);
                else
                  for (m = 0; m < n._axes.length; m++)
                    n._axes[m].createMask();
              0 < n._indexLabels.length && n.renderIndexLabels();
              n.dispatchEvent("dataAnimationIterationEnd", { chart: n });
              n.dispatchEvent("dataAnimationEnd", { chart: n });
            }
            this.attachPlotAreaEventHandlers();
            this.zoomEnabled || (this.panEnabled || !this._zoomButton || "none" === this._zoomButton.style.display) || ya(this._zoomButton, this._resetButton);
            this.toolTip._updateToolTip();
            this.renderCount++;
            Ma && (n = this, setTimeout(function() {
              var a2 = document.getElementById("ghostCanvasCopy");
              a2 && (Ua(a2, n.width, n.height), a2.getContext("2d").drawImage(
                n._eventManager.ghostCanvas,
                0,
                0
              ));
            }, 2e3));
            this._breaksCanvas && (delete this._breaksCanvas, delete this._breaksCanvasCtx);
            for (m = 0; m < this._axes.length; m++)
              this._axes[m].maskCanvas && (delete this._axes[m].maskCanvas, delete this._axes[m].maskCtx);
          }
        };
        w.prototype.render = function(a) {
          a && (this.options = a);
          this._initialize();
          this.setLayout();
          this.renderElements();
          this._preRenderCanvas && Ca(this._preRenderCanvas);
        };
        w.prototype.attachPlotAreaEventHandlers = function() {
          this.attachEvent({
            context: this,
            chart: this,
            mousedown: this._plotAreaMouseDown,
            mouseup: this._plotAreaMouseUp,
            mousemove: this._plotAreaMouseMove,
            cursor: this.panEnabled ? "move" : "default",
            capture: true,
            bounds: this.plotArea
          });
        };
        w.prototype.categoriseDataSeries = function() {
          for (var a = "", h2 = 0; h2 < this.data.length; h2++)
            if (a = this.data[h2], a.dataPoints && (0 !== a.dataPoints.length && a.visible) && 0 <= w._supportedChartTypes.indexOf(a.type)) {
              for (var c2 = null, b = false, e = null, l2 = false, C2 = 0; C2 < this.plotInfo.plotTypes.length; C2++)
                if (this.plotInfo.plotTypes[C2].type === a.type) {
                  b = true;
                  c2 = this.plotInfo.plotTypes[C2];
                  break;
                }
              b || (c2 = {
                type: a.type,
                totalDataSeries: 0,
                plotUnits: []
              }, this.plotInfo.plotTypes.push(c2));
              for (C2 = 0; C2 < c2.plotUnits.length; C2++)
                if (c2.plotUnits[C2].axisYType === a.axisYType && c2.plotUnits[C2].axisXType === a.axisXType && c2.plotUnits[C2].axisYIndex === a.axisYIndex && c2.plotUnits[C2].axisXIndex === a.axisXIndex) {
                  l2 = true;
                  e = c2.plotUnits[C2];
                  break;
                }
              l2 || (e = { type: a.type, previousDataSeriesCount: 0, index: c2.plotUnits.length, plotType: c2, axisXType: a.axisXType, axisYType: a.axisYType, axisYIndex: a.axisYIndex, axisXIndex: a.axisXIndex, axisY: "primary" === a.axisYType ? this.axisY[0 <= a.axisYIndex && a.axisYIndex < this.axisY.length ? a.axisYIndex : 0] : this.axisY2[0 <= a.axisYIndex && a.axisYIndex < this.axisY2.length ? a.axisYIndex : 0], axisX: "primary" === a.axisXType ? this.axisX[0 <= a.axisXIndex && a.axisXIndex < this.axisX.length ? a.axisXIndex : 0] : this.axisX2[0 <= a.axisXIndex && a.axisXIndex < this.axisX2.length ? a.axisXIndex : 0], dataSeriesIndexes: [], yTotals: [], yAbsTotals: [] }, c2.plotUnits.push(e));
              c2.totalDataSeries++;
              e.dataSeriesIndexes.push(h2);
              a.plotUnit = e;
            }
          for (h2 = 0; h2 < this.plotInfo.plotTypes.length; h2++)
            for (c2 = this.plotInfo.plotTypes[h2], C2 = a = 0; C2 < c2.plotUnits.length; C2++)
              c2.plotUnits[C2].previousDataSeriesCount = a, a += c2.plotUnits[C2].dataSeriesIndexes.length;
        };
        w.prototype.assignIdToDataPoints = function() {
          for (var a = 0; a < this.data.length; a++) {
            var h2 = this.data[a];
            if (h2.dataPoints)
              for (var c2 = h2.dataPoints.length, b = 0; b < c2; b++)
                h2.dataPointIds[b] = ++this._eventManager.lastObjectId;
          }
        };
        w.prototype._processData = function() {
          this.assignIdToDataPoints();
          this.categoriseDataSeries();
          for (var a = 0; a < this.plotInfo.plotTypes.length; a++)
            for (var h2 = this.plotInfo.plotTypes[a], c2 = 0; c2 < h2.plotUnits.length; c2++) {
              var b = h2.plotUnits[c2];
              "line" === b.type || "stepLine" === b.type || "spline" === b.type || "column" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "bar" === b.type || "bubble" === b.type || "scatter" === b.type ? this._processMultiseriesPlotUnit(b) : "stackedColumn" === b.type || "stackedBar" === b.type || "stackedArea" === b.type ? this._processStackedPlotUnit(b) : "stackedColumn100" === b.type || "stackedBar100" === b.type || "stackedArea100" === b.type ? this._processStacked100PlotUnit(b) : "candlestick" === b.type || "ohlc" === b.type || "rangeColumn" === b.type || "rangeBar" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "error" === b.type || "boxAndWhisker" === b.type ? this._processMultiYPlotUnit(b) : "waterfall" === b.type && this._processSpecificPlotUnit(b);
            }
          this.calculateAutoBreaks();
        };
        w.prototype._processMultiseriesPlotUnit = function(a) {
          if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length))
            for (var h2 = a.axisY.dataInfo, c2 = a.axisX.dataInfo, b, e, l2 = false, C2 = 0; C2 < a.dataSeriesIndexes.length; C2++) {
              var f3 = this.data[a.dataSeriesIndexes[C2]], d3 = 0, m = false, n = false, p;
              if ("normal" === f3.axisPlacement || "xySwapped" === f3.axisPlacement)
                var q = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : a.axisX.logarithmic ? 0 : -Infinity, g = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : Infinity;
              if (f3.dataPoints[d3].x && f3.dataPoints[d3].x.getTime || "dateTime" === f3.xValueType)
                l2 = true;
              for (d3 = 0; d3 < f3.dataPoints.length; d3++) {
                "undefined" === typeof f3.dataPoints[d3].x && (f3.dataPoints[d3].x = d3 + (a.axisX.logarithmic ? 1 : 0));
                f3.dataPoints[d3].x.getTime ? (l2 = true, b = f3.dataPoints[d3].x.getTime()) : b = f3.dataPoints[d3].x;
                e = f3.dataPoints[d3].y;
                b < c2.min && (c2.min = b);
                b > c2.max && (c2.max = b);
                e < h2.min && "number" === typeof e && (h2.min = e);
                e > h2.max && "number" === typeof e && (h2.max = e);
                if (0 < d3) {
                  if (a.axisX.logarithmic) {
                    var z = b / f3.dataPoints[d3 - 1].x;
                    1 > z && (z = 1 / z);
                    c2.minDiff > z && 1 !== z && (c2.minDiff = z);
                  } else
                    z = b - f3.dataPoints[d3 - 1].x, 0 > z && (z *= -1), c2.minDiff > z && 0 !== z && (c2.minDiff = z);
                  null !== e && null !== f3.dataPoints[d3 - 1].y && (a.axisY.logarithmic ? (z = e / f3.dataPoints[d3 - 1].y, 1 > z && (z = 1 / z), h2.minDiff > z && 1 !== z && (h2.minDiff = z)) : (z = e - f3.dataPoints[d3 - 1].y, 0 > z && (z *= -1), h2.minDiff > z && 0 !== z && (h2.minDiff = z)));
                }
                if (b < q && !m)
                  null !== e && (p = b);
                else {
                  if (!m && (m = true, 0 < d3)) {
                    d3 -= 2;
                    continue;
                  }
                  if (b > g && !n)
                    n = true;
                  else if (b > g && n)
                    continue;
                  f3.dataPoints[d3].label && (a.axisX.labels[b] = f3.dataPoints[d3].label);
                  b < c2.viewPortMin && (c2.viewPortMin = b);
                  b > c2.viewPortMax && (c2.viewPortMax = b);
                  null === e ? c2.viewPortMin === b && p < b && (c2.viewPortMin = p) : (e < h2.viewPortMin && "number" === typeof e && (h2.viewPortMin = e), e > h2.viewPortMax && "number" === typeof e && (h2.viewPortMax = e));
                }
              }
              f3.axisX.valueType = f3.xValueType = l2 ? "dateTime" : "number";
            }
        };
        w.prototype._processStackedPlotUnit = function(a) {
          if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
            for (var h2 = a.axisY.dataInfo, c2 = a.axisX.dataInfo, b, e, l2 = false, C2 = [], d3 = [], ha = Infinity, m = -Infinity, n = {}, p = 0; p < a.dataSeriesIndexes.length; p++) {
              var q = this.data[a.dataSeriesIndexes[p]], g = 0, z = false, s2 = false, r2;
              if ("normal" === q.axisPlacement || "xySwapped" === q.axisPlacement)
                var t = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : -Infinity, k3 = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : Infinity;
              if (q.dataPoints[g].x && q.dataPoints[g].x.getTime || "dateTime" === q.xValueType)
                l2 = true;
              for (g = 0; g < q.dataPoints.length; g++) {
                "undefined" === typeof q.dataPoints[g].x && (q.dataPoints[g].x = g + (a.axisX.logarithmic ? 1 : 0));
                q.dataPoints[g].x.getTime ? (l2 = true, b = q.dataPoints[g].x.getTime()) : b = q.dataPoints[g].x;
                e = f2(q.dataPoints[g].y) ? 0 : q.dataPoints[g].y;
                b < c2.min && (c2.min = b);
                b > c2.max && (c2.max = b);
                if (0 < g) {
                  if (a.axisX.logarithmic) {
                    var y2 = b / q.dataPoints[g - 1].x;
                    1 > y2 && (y2 = 1 / y2);
                    c2.minDiff > y2 && 1 !== y2 && (c2.minDiff = y2);
                  } else
                    y2 = b - q.dataPoints[g - 1].x, 0 > y2 && (y2 *= -1), c2.minDiff > y2 && 0 !== y2 && (c2.minDiff = y2);
                  null !== e && null !== q.dataPoints[g - 1].y && (a.axisY.logarithmic ? 0 < e && (y2 = e / q.dataPoints[g - 1].y, 1 > y2 && (y2 = 1 / y2), h2.minDiff > y2 && 1 !== y2 && (h2.minDiff = y2)) : (y2 = e - q.dataPoints[g - 1].y, 0 > y2 && (y2 *= -1), h2.minDiff > y2 && 0 !== y2 && (h2.minDiff = y2)));
                }
                if (b < t && !z)
                  null !== q.dataPoints[g].y && (r2 = b);
                else {
                  if (!z && (z = true, 0 < g)) {
                    g -= 2;
                    continue;
                  }
                  if (b > k3 && !s2)
                    s2 = true;
                  else if (b > k3 && s2)
                    continue;
                  q.dataPoints[g].label && (a.axisX.labels[b] = q.dataPoints[g].label);
                  b < c2.viewPortMin && (c2.viewPortMin = b);
                  b > c2.viewPortMax && (c2.viewPortMax = b);
                  null === q.dataPoints[g].y ? c2.viewPortMin === b && r2 < b && (c2.viewPortMin = r2) : (n[b] = (n[b] || 0) + q.dataPoints[g].y, q.dataPointEOs[g].cumulativeY = n[b], a.yTotals[b] = (a.yTotals[b] ? a.yTotals[b] : 0) + e, a.yAbsTotals[b] = (a.yAbsTotals[b] ? a.yAbsTotals[b] : 0) + Math.abs(e), 0 <= e ? C2[b] ? C2[b] += e : (C2[b] = e, ha = Math.min(e, ha)) : d3[b] ? d3[b] += e : (d3[b] = e, m = Math.max(e, m)));
                }
              }
              a.axisY.scaleBreaks && (a.axisY.scaleBreaks.autoCalculate && 1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks) && (h2.dataPointYPositiveSums ? (h2.dataPointYPositiveSums.push.apply(h2.dataPointYPositiveSums, C2), h2.dataPointYNegativeSums.push.apply(h2.dataPointYPositiveSums, d3)) : (h2.dataPointYPositiveSums = C2, h2.dataPointYNegativeSums = d3));
              q.axisX.valueType = q.xValueType = l2 ? "dateTime" : "number";
            }
            for (g in C2)
              C2.hasOwnProperty(g) && !isNaN(g) && (a = C2[g], a < h2.min && (h2.min = Math.min(a, ha)), a > h2.max && (h2.max = a), g < c2.viewPortMin || g > c2.viewPortMax || (a < h2.viewPortMin && (h2.viewPortMin = Math.min(a, ha)), a > h2.viewPortMax && (h2.viewPortMax = a)));
            for (g in d3)
              d3.hasOwnProperty(g) && !isNaN(g) && (a = d3[g], a < h2.min && (h2.min = a), a > h2.max && (h2.max = Math.max(a, m)), g < c2.viewPortMin || g > c2.viewPortMax || (a < h2.viewPortMin && (h2.viewPortMin = a), a > h2.viewPortMax && (h2.viewPortMax = Math.max(a, m))));
          }
        };
        w.prototype._processStacked100PlotUnit = function(a) {
          if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
            for (var h2 = a.axisY.dataInfo, c2 = a.axisX.dataInfo, b, e, l2 = false, C2 = false, d3 = false, ha = {}, m = [], n = 0; n < a.dataSeriesIndexes.length; n++) {
              var p = this.data[a.dataSeriesIndexes[n]], q = 0, g = false, z = false, s2;
              if ("normal" === p.axisPlacement || "xySwapped" === p.axisPlacement)
                var r2 = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : -Infinity, t = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : Infinity;
              if (p.dataPoints[q].x && p.dataPoints[q].x.getTime || "dateTime" === p.xValueType)
                l2 = true;
              for (q = 0; q < p.dataPoints.length; q++) {
                "undefined" === typeof p.dataPoints[q].x && (p.dataPoints[q].x = q + (a.axisX.logarithmic ? 1 : 0));
                p.dataPoints[q].x.getTime ? (l2 = true, b = p.dataPoints[q].x.getTime()) : b = p.dataPoints[q].x;
                e = f2(p.dataPoints[q].y) ? null : p.dataPoints[q].y;
                b < c2.min && (c2.min = b);
                b > c2.max && (c2.max = b);
                if (0 < q) {
                  if (a.axisX.logarithmic) {
                    var k3 = b / p.dataPoints[q - 1].x;
                    1 > k3 && (k3 = 1 / k3);
                    c2.minDiff > k3 && 1 !== k3 && (c2.minDiff = k3);
                  } else
                    k3 = b - p.dataPoints[q - 1].x, 0 > k3 && (k3 *= -1), c2.minDiff > k3 && 0 !== k3 && (c2.minDiff = k3);
                  f2(e) || null === p.dataPoints[q - 1].y || (a.axisY.logarithmic ? 0 < e && (k3 = e / p.dataPoints[q - 1].y, 1 > k3 && (k3 = 1 / k3), h2.minDiff > k3 && 1 !== k3 && (h2.minDiff = k3)) : (k3 = e - p.dataPoints[q - 1].y, 0 > k3 && (k3 *= -1), h2.minDiff > k3 && 0 !== k3 && (h2.minDiff = k3)));
                }
                if (b < r2 && !g)
                  null !== e && (s2 = b);
                else {
                  if (!g && (g = true, 0 < q)) {
                    q -= 2;
                    continue;
                  }
                  if (b > t && !z)
                    z = true;
                  else if (b > t && z)
                    continue;
                  p.dataPoints[q].label && (a.axisX.labels[b] = p.dataPoints[q].label);
                  b < c2.viewPortMin && (c2.viewPortMin = b);
                  b > c2.viewPortMax && (c2.viewPortMax = b);
                  null === e ? c2.viewPortMin === b && s2 < b && (c2.viewPortMin = s2) : (ha[b] = (ha[b] || 0) + p.dataPoints[q].y, p.dataPointEOs[q].cumulativeY = ha[b], a.yTotals[b] = (a.yTotals[b] ? a.yTotals[b] : 0) + e, a.yAbsTotals[b] = (a.yAbsTotals[b] ? a.yAbsTotals[b] : 0) + Math.abs(e), 0 <= e ? C2 = true : 0 > e && (d3 = true), m[b] = m[b] ? m[b] + Math.abs(e) : Math.abs(e));
                }
              }
              p.axisX.valueType = p.xValueType = l2 ? "dateTime" : "number";
            }
            a.axisY.logarithmic ? (h2.max = f2(h2.viewPortMax) ? 99 * Math.pow(a.axisY.logarithmBase, -0.05) : Math.max(h2.viewPortMax, 99 * Math.pow(a.axisY.logarithmBase, -0.05)), h2.min = f2(h2.viewPortMin) ? 1 : Math.min(h2.viewPortMin, 1)) : C2 && !d3 ? (h2.max = f2(h2.viewPortMax) ? 99 : Math.max(h2.viewPortMax, 99), h2.min = f2(h2.viewPortMin) ? 1 : Math.min(h2.viewPortMin, 1)) : C2 && d3 ? (h2.max = f2(h2.viewPortMax) ? 99 : Math.max(h2.viewPortMax, 99), h2.min = f2(h2.viewPortMin) ? -99 : Math.min(h2.viewPortMin, -99)) : !C2 && d3 && (h2.max = f2(h2.viewPortMax) ? -1 : Math.max(h2.viewPortMax, -1), h2.min = f2(h2.viewPortMin) ? -99 : Math.min(h2.viewPortMin, -99));
            h2.viewPortMin = h2.min;
            h2.viewPortMax = h2.max;
            a.dataPointYSums = m;
          }
        };
        w.prototype._processMultiYPlotUnit = function(a) {
          if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length))
            for (var h2 = a.axisY.dataInfo, c2 = a.axisX.dataInfo, b, e, l2, C2, f3 = false, d3 = 0; d3 < a.dataSeriesIndexes.length; d3++) {
              var m = this.data[a.dataSeriesIndexes[d3]], n = 0, p = false, q = false, g, z, s2;
              if ("normal" === m.axisPlacement || "xySwapped" === m.axisPlacement)
                var r2 = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : a.axisX.logarithmic ? 0 : -Infinity, t = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : Infinity;
              if (m.dataPoints[n].x && m.dataPoints[n].x.getTime || "dateTime" === m.xValueType)
                f3 = true;
              for (n = 0; n < m.dataPoints.length; n++) {
                "undefined" === typeof m.dataPoints[n].x && (m.dataPoints[n].x = n + (a.axisX.logarithmic ? 1 : 0));
                m.dataPoints[n].x.getTime ? (f3 = true, b = m.dataPoints[n].x.getTime()) : b = m.dataPoints[n].x;
                if ((e = m.dataPoints[n].y) && e.length) {
                  l2 = Math.min.apply(null, e);
                  C2 = Math.max.apply(null, e);
                  z = true;
                  for (var k3 = 0; k3 < e.length; k3++)
                    null === e.k && (z = false);
                  z && (p || (s2 = g), g = b);
                }
                b < c2.min && (c2.min = b);
                b > c2.max && (c2.max = b);
                l2 < h2.min && (h2.min = l2);
                C2 > h2.max && (h2.max = C2);
                0 < n && (a.axisX.logarithmic ? (z = b / m.dataPoints[n - 1].x, 1 > z && (z = 1 / z), c2.minDiff > z && 1 !== z && (c2.minDiff = z)) : (z = b - m.dataPoints[n - 1].x, 0 > z && (z *= -1), c2.minDiff > z && 0 !== z && (c2.minDiff = z)), e && (null !== e[0] && m.dataPoints[n - 1].y && null !== m.dataPoints[n - 1].y[0]) && (a.axisY.logarithmic ? (z = e[0] / m.dataPoints[n - 1].y[0], 1 > z && (z = 1 / z), h2.minDiff > z && 1 !== z && (h2.minDiff = z)) : (z = e[0] - m.dataPoints[n - 1].y[0], 0 > z && (z *= -1), h2.minDiff > z && 0 !== z && (h2.minDiff = z))));
                if (!(b < r2) || p) {
                  if (!p && (p = true, 0 < n)) {
                    n -= 2;
                    g = s2;
                    continue;
                  }
                  if (b > t && !q)
                    q = true;
                  else if (b > t && q)
                    continue;
                  m.dataPoints[n].label && (a.axisX.labels[b] = m.dataPoints[n].label);
                  b < c2.viewPortMin && (c2.viewPortMin = b);
                  b > c2.viewPortMax && (c2.viewPortMax = b);
                  if (c2.viewPortMin === b && e) {
                    for (k3 = 0; k3 < e.length; k3++)
                      if (null === e[k3] && g < b) {
                        c2.viewPortMin = g;
                        break;
                      }
                  }
                  null === e ? c2.viewPortMin === b && g < b && (c2.viewPortMin = g) : (l2 < h2.viewPortMin && (h2.viewPortMin = l2), C2 > h2.viewPortMax && (h2.viewPortMax = C2));
                }
              }
              m.axisX.valueType = m.xValueType = f3 ? "dateTime" : "number";
            }
        };
        w.prototype._processSpecificPlotUnit = function(a) {
          if ("waterfall" === a.type && a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length))
            for (var h2 = a.axisY.dataInfo, c2 = a.axisX.dataInfo, b, e, l2 = false, C2 = 0; C2 < a.dataSeriesIndexes.length; C2++) {
              var f3 = this.data[a.dataSeriesIndexes[C2]], d3 = 0, m = false, n = false, p = b = 0;
              if ("normal" === f3.axisPlacement || "xySwapped" === f3.axisPlacement)
                var q = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : a.axisX.logarithmic ? 0 : -Infinity, g = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : Infinity;
              if (f3.dataPoints[d3].x && f3.dataPoints[d3].x.getTime || "dateTime" === f3.xValueType)
                l2 = true;
              for (d3 = 0; d3 < f3.dataPoints.length; d3++)
                "undefined" !== typeof f3.dataPoints[d3].isCumulativeSum && true === f3.dataPoints[d3].isCumulativeSum ? (f3.dataPointEOs[d3].cumulativeSumYStartValue = 0, f3.dataPointEOs[d3].cumulativeSum = 0 === d3 ? 0 : f3.dataPointEOs[d3 - 1].cumulativeSum, f3.dataPoints[d3].y = 0 === d3 ? 0 : f3.dataPointEOs[d3 - 1].cumulativeSum) : "undefined" !== typeof f3.dataPoints[d3].isIntermediateSum && true === f3.dataPoints[d3].isIntermediateSum ? (f3.dataPointEOs[d3].cumulativeSumYStartValue = p, f3.dataPointEOs[d3].cumulativeSum = 0 === d3 ? 0 : f3.dataPointEOs[d3 - 1].cumulativeSum, f3.dataPoints[d3].y = 0 === d3 ? 0 : b, p = 0 === d3 ? 0 : f3.dataPointEOs[d3 - 1].cumulativeSum, b = 0) : (e = "number" !== typeof f3.dataPoints[d3].y ? 0 : f3.dataPoints[d3].y, f3.dataPointEOs[d3].cumulativeSumYStartValue = 0 === d3 ? 0 : f3.dataPointEOs[d3 - 1].cumulativeSum, f3.dataPointEOs[d3].cumulativeSum = 0 === d3 ? e : f3.dataPointEOs[d3 - 1].cumulativeSum + e, b += e);
              for (d3 = 0; d3 < f3.dataPoints.length; d3++)
                if ("undefined" === typeof f3.dataPoints[d3].x && (f3.dataPoints[d3].x = d3 + (a.axisX.logarithmic ? 1 : 0)), f3.dataPoints[d3].x.getTime ? (l2 = true, b = f3.dataPoints[d3].x.getTime()) : b = f3.dataPoints[d3].x, e = f3.dataPoints[d3].y, b < c2.min && (c2.min = b), b > c2.max && (c2.max = b), f3.dataPointEOs[d3].cumulativeSum < h2.min && (h2.min = f3.dataPointEOs[d3].cumulativeSum), f3.dataPointEOs[d3].cumulativeSum > h2.max && (h2.max = f3.dataPointEOs[d3].cumulativeSum), 0 < d3 && (a.axisX.logarithmic ? (p = b / f3.dataPoints[d3 - 1].x, 1 > p && (p = 1 / p), c2.minDiff > p && 1 !== p && (c2.minDiff = p)) : (p = b - f3.dataPoints[d3 - 1].x, 0 > p && (p *= -1), c2.minDiff > p && 0 !== p && (c2.minDiff = p)), null !== e && null !== f3.dataPoints[d3 - 1].y && (a.axisY.logarithmic ? (e = f3.dataPointEOs[d3].cumulativeSum / f3.dataPointEOs[d3 - 1].cumulativeSum, 1 > e && (e = 1 / e), h2.minDiff > e && 1 !== e && (h2.minDiff = e)) : (e = f3.dataPointEOs[d3].cumulativeSum - f3.dataPointEOs[d3 - 1].cumulativeSum, 0 > e && (e *= -1), h2.minDiff > e && 0 !== e && (h2.minDiff = e)))), !(b < q) || m) {
                  if (!m && (m = true, 0 < d3)) {
                    d3 -= 2;
                    continue;
                  }
                  if (b > g && !n)
                    n = true;
                  else if (b > g && n)
                    continue;
                  f3.dataPoints[d3].label && (a.axisX.labels[b] = f3.dataPoints[d3].label);
                  b < c2.viewPortMin && (c2.viewPortMin = b);
                  b > c2.viewPortMax && (c2.viewPortMax = b);
                  0 < d3 && (f3.dataPointEOs[d3 - 1].cumulativeSum < h2.viewPortMin && (h2.viewPortMin = f3.dataPointEOs[d3 - 1].cumulativeSum), f3.dataPointEOs[d3 - 1].cumulativeSum > h2.viewPortMax && (h2.viewPortMax = f3.dataPointEOs[d3 - 1].cumulativeSum));
                  f3.dataPointEOs[d3].cumulativeSum < h2.viewPortMin && (h2.viewPortMin = f3.dataPointEOs[d3].cumulativeSum);
                  f3.dataPointEOs[d3].cumulativeSum > h2.viewPortMax && (h2.viewPortMax = f3.dataPointEOs[d3].cumulativeSum);
                }
              f3.axisX.valueType = f3.xValueType = l2 ? "dateTime" : "number";
            }
        };
        w.prototype.calculateAutoBreaks = function() {
          function a(a2, b2, c3, e2) {
            if (e2)
              return c3 = Math.pow(Math.min(c3 * a2 / b2, b2 / a2), 0.2), 1 >= c3 && (c3 = Math.pow(1 > a2 ? 1 / a2 : Math.min(b2 / a2, a2), 0.25)), { startValue: a2 * c3, endValue: b2 / c3 };
            c3 = 0.2 * Math.min(c3 - b2 + a2, b2 - a2);
            0 >= c3 && (c3 = 0.25 * Math.min(b2 - a2, Math.abs(a2)));
            return { startValue: a2 + c3, endValue: b2 - c3 };
          }
          function h2(a2) {
            if (a2.dataSeriesIndexes && !(1 > a2.dataSeriesIndexes.length)) {
              var b2 = a2.axisX.scaleBreaks && a2.axisX.scaleBreaks.autoCalculate && 1 <= a2.axisX.scaleBreaks.maxNumberOfAutoBreaks, c3 = a2.axisY.scaleBreaks && a2.axisY.scaleBreaks.autoCalculate && 1 <= a2.axisY.scaleBreaks.maxNumberOfAutoBreaks;
              if (b2 || c3)
                for (var h3 = a2.axisY.dataInfo, g2 = a2.axisX.dataInfo, l3, C3 = g2.min, m2 = g2.max, n2 = h3.min, d4 = h3.max, g2 = g2._dataRanges, h3 = h3._dataRanges, q2, p2 = 0, ua = 0; ua < a2.dataSeriesIndexes.length; ua++) {
                  var s3 = e.data[a2.dataSeriesIndexes[ua]];
                  if (!(4 > s3.dataPoints.length)) {
                    for (p2 = 0; p2 < s3.dataPoints.length; p2++)
                      if (b2 && (q2 = (m2 + 1 - C3) * Math.max(parseFloat(a2.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, l3 = s3.dataPoints[p2].x.getTime ? s3.dataPoints[p2].x.getTime() : s3.dataPoints[p2].x, q2 = Math.floor((l3 - C3) / q2), l3 < g2[q2].min && (g2[q2].min = l3), l3 > g2[q2].max && (g2[q2].max = l3)), c3) {
                        var ha = (d4 + 1 - n2) * Math.max(parseFloat(a2.axisY.scaleBreaks.collapsibleThreshold) || 10, 10) / 100;
                        if ((l3 = "waterfall" === a2.type ? s3.dataPointEOs[p2].cumulativeSum : s3.dataPoints[p2].y) && l3.length)
                          for (var r2 = 0; r2 < l3.length; r2++)
                            q2 = Math.floor((l3[r2] - n2) / ha), l3[r2] < h3[q2].min && (h3[q2].min = l3[r2]), l3[r2] > h3[q2].max && (h3[q2].max = l3[r2]);
                        else
                          f2(l3) || (q2 = Math.floor((l3 - n2) / ha), l3 < h3[q2].min && (h3[q2].min = l3), l3 > h3[q2].max && (h3[q2].max = l3));
                      }
                  }
                }
            }
          }
          function c2(a2) {
            if (a2.dataSeriesIndexes && !(1 > a2.dataSeriesIndexes.length) && a2.axisX.scaleBreaks && a2.axisX.scaleBreaks.autoCalculate && 1 <= a2.axisX.scaleBreaks.maxNumberOfAutoBreaks)
              for (var b2 = a2.axisX.dataInfo, c3 = b2.min, h3 = b2.max, g2 = b2._dataRanges, l3, C3 = 0, f3 = 0; f3 < a2.dataSeriesIndexes.length; f3++) {
                var m2 = e.data[a2.dataSeriesIndexes[f3]];
                if (!(4 > m2.dataPoints.length))
                  for (C3 = 0; C3 < m2.dataPoints.length; C3++)
                    l3 = (h3 + 1 - c3) * Math.max(parseFloat(a2.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, b2 = m2.dataPoints[C3].x.getTime ? m2.dataPoints[C3].x.getTime() : m2.dataPoints[C3].x, l3 = Math.floor((b2 - c3) / l3), b2 < g2[l3].min && (g2[l3].min = b2), b2 > g2[l3].max && (g2[l3].max = b2);
              }
          }
          for (var b, e = this, l2 = false, C2 = 0; C2 < this._axes.length; C2++)
            if (this._axes[C2].scaleBreaks && this._axes[C2].scaleBreaks.autoCalculate && 1 <= this._axes[C2].scaleBreaks.maxNumberOfAutoBreaks) {
              l2 = true;
              this._axes[C2].dataInfo._dataRanges = [];
              for (var d3 = 0; d3 < 100 / Math.max(parseFloat(this._axes[C2].scaleBreaks.collapsibleThreshold) || 10, 10); d3++)
                this._axes[C2].dataInfo._dataRanges.push({ min: Infinity, max: -Infinity });
            }
          if (l2) {
            for (C2 = 0; C2 < this.plotInfo.plotTypes.length; C2++)
              for (l2 = this.plotInfo.plotTypes[C2], d3 = 0; d3 < l2.plotUnits.length; d3++)
                b = l2.plotUnits[d3], "line" === b.type || "stepLine" === b.type || "spline" === b.type || "column" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "bar" === b.type || "bubble" === b.type || "scatter" === b.type || "candlestick" === b.type || "ohlc" === b.type || "rangeColumn" === b.type || "rangeBar" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "waterfall" === b.type || "error" === b.type || "boxAndWhisker" === b.type ? h2(b) : 0 <= b.type.indexOf("stacked") && c2(b);
            for (C2 = 0; C2 < this._axes.length; C2++)
              if (this._axes[C2].dataInfo._dataRanges) {
                var s2 = this._axes[C2].dataInfo.min;
                b = (this._axes[C2].dataInfo.max + 1 - s2) * Math.max(parseFloat(this._axes[C2].scaleBreaks.collapsibleThreshold) || 10, 10) / 100;
                var m = this._axes[C2].dataInfo._dataRanges, n, p, l2 = [];
                if (this._axes[C2].dataInfo.dataPointYPositiveSums) {
                  var q = this._axes[C2].dataInfo.dataPointYPositiveSums;
                  n = m;
                  for (d3 in q)
                    if (q.hasOwnProperty(d3) && !isNaN(d3) && (p = q[d3], !f2(p))) {
                      var g = Math.floor((p - s2) / b);
                      p < n[g].min && (n[g].min = p);
                      p > n[g].max && (n[g].max = p);
                    }
                  delete this._axes[C2].dataInfo.dataPointYPositiveSums;
                }
                if (this._axes[C2].dataInfo.dataPointYNegativeSums) {
                  q = this._axes[C2].dataInfo.dataPointYNegativeSums;
                  n = m;
                  for (d3 in q)
                    q.hasOwnProperty(d3) && !isNaN(d3) && (p = -1 * q[d3], f2(p) || (g = Math.floor((p - s2) / b), p < n[g].min && (n[g].min = p), p > n[g].max && (n[g].max = p)));
                  delete this._axes[C2].dataInfo.dataPointYNegativeSums;
                }
                for (d3 = 0; d3 < m.length - 1; d3++)
                  if (n = m[d3].max, isFinite(n))
                    for (; d3 < m.length - 1; )
                      if (s2 = m[d3 + 1].min, isFinite(s2)) {
                        p = s2 - n;
                        p > b && l2.push({ diff: p, start: n, end: s2 });
                        break;
                      } else
                        d3++;
                if (this._axes[C2].scaleBreaks.customBreaks) {
                  for (d3 = 0; d3 < this._axes[C2].scaleBreaks.customBreaks.length; d3++)
                    for (b = 0; b < l2.length; b++)
                      if (this._axes[C2].scaleBreaks.customBreaks[d3].startValue <= l2[b].start && l2[b].start <= this._axes[C2].scaleBreaks.customBreaks[d3].endValue || this._axes[C2].scaleBreaks.customBreaks[d3].startValue <= l2[b].start && l2[b].start <= this._axes[C2].scaleBreaks.customBreaks[d3].endValue || l2[b].start <= this._axes[C2].scaleBreaks.customBreaks[d3].startValue && this._axes[C2].scaleBreaks.customBreaks[d3].startValue <= l2[b].end || l2[b].start <= this._axes[C2].scaleBreaks.customBreaks[d3].endValue && this._axes[C2].scaleBreaks.customBreaks[d3].endValue <= l2[b].end)
                        l2.splice(b, 1), b--;
                }
                l2.sort(function(a2, b2) {
                  return b2.diff - a2.diff;
                });
                for (d3 = 0; d3 < Math.min(l2.length, this._axes[C2].scaleBreaks.maxNumberOfAutoBreaks); d3++)
                  b = a(l2[d3].start, l2[d3].end, this._axes[C2].logarithmic ? this._axes[C2].dataInfo.max / this._axes[C2].dataInfo.min : this._axes[C2].dataInfo.max - this._axes[C2].dataInfo.min, this._axes[C2].logarithmic), this._axes[C2].scaleBreaks.autoBreaks.push(new T2(this, "autoBreaks", b, d3, ++this._eventManager.lastObjectId, this._axes[C2].scaleBreaks)), this._axes[C2].scaleBreaks._appliedBreaks.push(this._axes[C2].scaleBreaks.autoBreaks[this._axes[C2].scaleBreaks.autoBreaks.length - 1]);
                this._axes[C2].scaleBreaks._appliedBreaks.sort(function(a2, b2) {
                  return a2.startValue - b2.startValue;
                });
              }
          }
        };
        w.prototype.renderCrosshairs = function(a) {
          for (var h2 = 0; h2 < this.axisX.length; h2++)
            this.axisX[h2] != a && (this.axisX[h2].crosshair && this.axisX[h2].crosshair.enabled && !this.axisX[h2].crosshair._hidden) && this.axisX[h2].showCrosshair(this.axisX[h2].crosshair._updatedValue);
          for (h2 = 0; h2 < this.axisX2.length; h2++)
            this.axisX2[h2] != a && (this.axisX2[h2].crosshair && this.axisX2[h2].crosshair.enabled && !this.axisX2[h2].crosshair._hidden) && this.axisX2[h2].showCrosshair(this.axisX2[h2].crosshair._updatedValue);
          for (h2 = 0; h2 < this.axisY.length; h2++)
            this.axisY[h2] != a && (this.axisY[h2].crosshair && this.axisY[h2].crosshair.enabled && !this.axisY[h2].crosshair._hidden) && this.axisY[h2].showCrosshair(this.axisY[h2].crosshair._updatedValue);
          for (h2 = 0; h2 < this.axisY2.length; h2++)
            this.axisY2[h2] != a && (this.axisY2[h2].crosshair && this.axisY2[h2].crosshair.enabled && !this.axisY2[h2].crosshair._hidden) && this.axisY2[h2].showCrosshair(this.axisY2[h2].crosshair._updatedValue);
        };
        w.prototype.getDataPointAtXY = function(a, h2, c2) {
          c2 = c2 || false;
          for (var b = [], e = this._dataInRenderedOrder.length - 1; 0 <= e; e--) {
            var l2 = null;
            (l2 = this._dataInRenderedOrder[e].getDataPointAtXY(a, h2, c2)) && b.push(l2);
          }
          a = null;
          h2 = false;
          for (c2 = 0; c2 < b.length; c2++)
            if ("line" === b[c2].dataSeries.type || "stepLine" === b[c2].dataSeries.type || "area" === b[c2].dataSeries.type || "stepArea" === b[c2].dataSeries.type) {
              if (e = qa("markerSize", b[c2].dataPoint, b[c2].dataSeries) || 8, b[c2].distance <= e / 2) {
                h2 = true;
                break;
              }
            }
          for (c2 = 0; c2 < b.length; c2++)
            h2 && "line" !== b[c2].dataSeries.type && "stepLine" !== b[c2].dataSeries.type && "area" !== b[c2].dataSeries.type && "stepArea" !== b[c2].dataSeries.type || (a ? b[c2].distance <= a.distance && (a = b[c2]) : a = b[c2]);
          return a;
        };
        w.prototype.getObjectAtXY = function(a, h2, c2) {
          var b = null;
          if (c2 = this.getDataPointAtXY(a, h2, c2 || false))
            b = c2.dataSeries.dataPointIds[c2.dataPointIndex];
          else if (r)
            b = jb(a, h2, this._eventManager.ghostCtx);
          else
            for (c2 = 0; c2 < this.legend.items.length; c2++) {
              var e = this.legend.items[c2];
              a >= e.x1 && (a <= e.x2 && h2 >= e.y1 && h2 <= e.y2) && (b = e.id);
            }
          return b;
        };
        w.prototype.getAutoFontSize = nb;
        w.prototype.resetOverlayedCanvas = function() {
          this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height);
        };
        w.prototype.clearCanvas = mb;
        w.prototype.attachEvent = function(a) {
          this._events.push(a);
        };
        w.prototype._touchEventHandler = function(a) {
          if (a.changedTouches && this.interactivityEnabled) {
            var h2 = [], c2 = a.changedTouches, b = c2 ? c2[0] : a, e = null;
            switch (a.type) {
              case "touchstart":
              case "MSPointerDown":
                h2 = ["mousemove", "mousedown"];
                this._lastTouchData = Aa(b);
                this._lastTouchData.time = new Date();
                break;
              case "touchmove":
              case "MSPointerMove":
                h2 = ["mousemove"];
                break;
              case "touchend":
              case "MSPointerUp":
                var l2 = this._lastTouchData && this._lastTouchData.time ? new Date() - this._lastTouchData.time : 0, h2 = "touchstart" === this._lastTouchEventType || "MSPointerDown" === this._lastTouchEventType || 300 > l2 ? ["mouseup", "click"] : ["mouseup"];
                break;
              default:
                return;
            }
            if (!(c2 && 1 < c2.length)) {
              e = Aa(b);
              e.time = new Date();
              try {
                var C2 = e.y - this._lastTouchData.y, l2 = e.time - this._lastTouchData.time;
                if (1 < Math.abs(C2) && this._lastTouchData.scroll || 5 < Math.abs(C2) && 250 > l2)
                  this._lastTouchData.scroll = true;
              } catch (d3) {
              }
              this._lastTouchEventType = a.type;
              if (this._lastTouchData.scroll && this.zoomEnabled)
                this.isDrag && this.resetOverlayedCanvas(), this.isDrag = false;
              else
                for (c2 = 0; c2 < h2.length; c2++)
                  if (e = h2[c2], C2 = document.createEvent("MouseEvent"), C2.initMouseEvent(e, true, true, window, 1, b.screenX, b.screenY, b.clientX, b.clientY, false, false, false, false, 0, null), b.target.dispatchEvent(C2), !f2(this._lastTouchData.scroll) && !this._lastTouchData.scroll || !this._lastTouchData.scroll && 250 < l2 || "click" === e)
                    a.preventManipulation && a.preventManipulation(), a.preventDefault && a.cancelable && a.preventDefault();
            }
          }
        };
        w.prototype._dispatchRangeEvent = function(a, h2) {
          var c2 = { chart: this };
          c2.type = a;
          c2.trigger = h2;
          var b = [];
          this.axisX && 0 < this.axisX.length && b.push("axisX");
          this.axisX2 && 0 < this.axisX2.length && b.push("axisX2");
          this.axisY && 0 < this.axisY.length && b.push("axisY");
          this.axisY2 && 0 < this.axisY2.length && b.push("axisY2");
          for (var e = 0; e < b.length; e++)
            if (f2(c2[b[e]]) && (c2[b[e]] = []), "axisY" === b[e])
              for (var l2 = 0; l2 < this.axisY.length; l2++)
                c2[b[e]].push({ viewportMinimum: this[b[e]][l2].sessionVariables.newViewportMinimum, viewportMaximum: this[b[e]][l2].sessionVariables.newViewportMaximum });
            else if ("axisY2" === b[e])
              for (l2 = 0; l2 < this.axisY2.length; l2++)
                c2[b[e]].push({ viewportMinimum: this[b[e]][l2].sessionVariables.newViewportMinimum, viewportMaximum: this[b[e]][l2].sessionVariables.newViewportMaximum });
            else if ("axisX" === b[e])
              for (l2 = 0; l2 < this.axisX.length; l2++)
                c2[b[e]].push({ viewportMinimum: this[b[e]][l2].sessionVariables.newViewportMinimum, viewportMaximum: this[b[e]][l2].sessionVariables.newViewportMaximum });
            else if ("axisX2" === b[e])
              for (l2 = 0; l2 < this.axisX2.length; l2++)
                c2[b[e]].push({
                  viewportMinimum: this[b[e]][l2].sessionVariables.newViewportMinimum,
                  viewportMaximum: this[b[e]][l2].sessionVariables.newViewportMaximum
                });
          this.dispatchEvent(a, c2, this);
        };
        w.prototype._mouseEventHandler = function(a) {
          function h2() {
            w.capturedEventParam && (e = w.capturedEventParam, C2 = e.bounds, "mouseup" === b && (w.capturedEventParam = null, e.chart.overlaidCanvas.releaseCapture ? e.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", e.chart._mouseEventHandler, false)), e.hasOwnProperty(b) && ("mouseup" !== b || e.chart.overlaidCanvas.releaseCapture ? a.target !== e.chart.overlaidCanvas && r || e[b].call(e.context, c2.x, c2.y) : a.target !== e.chart.overlaidCanvas && (e.chart.isDrag = false)));
          }
          "undefined" === typeof a.target && a.srcElement && (a.target = a.srcElement);
          var c2 = Aa(a), b = a.type, e, l2;
          a.which ? l2 = 3 == a.which : a.button && (l2 = 2 == a.button);
          if (this._ignoreNextEvent)
            h2(), this._ignoreNextEvent = false;
          else if (h2(), this.interactivityEnabled) {
            a.preventManipulation && a.preventManipulation();
            a.preventDefault && a.preventDefault();
            var C2;
            Ma && window.console && (window.console.log(b + " --> x: " + c2.x + "; y:" + c2.y), l2 && window.console.log(a.which), "mouseup" === b && window.console.log("mouseup"));
            if (!l2) {
              if (!w.capturedEventParam && this._events) {
                for (l2 = 0; l2 < this._events.length; l2++)
                  if (this._events[l2].hasOwnProperty(b))
                    if (e = this._events[l2], C2 = e.bounds, c2.x >= C2.x1 && c2.x <= C2.x2 && c2.y >= C2.y1 && c2.y <= C2.y2) {
                      e[b].call(e.context, c2.x, c2.y);
                      "mousedown" === b && true === e.capture ? (w.capturedEventParam = e, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener(
                        "mouseup",
                        this._mouseEventHandler,
                        false
                      )) : "mouseup" === b && (e.chart.overlaidCanvas.releaseCapture ? e.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", this._mouseEventHandler, false));
                      break;
                    } else
                      e = null;
                a.target.style.cursor = e && e.cursor ? e.cursor : this._defaultCursor;
              }
              l2 = this.plotArea;
              if (c2.x < l2.x1 || c2.x > l2.x2 || c2.y < l2.y1 || c2.y > l2.y2) {
                this.toolTip && this.toolTip.enabled ? (this.toolTip.hide(), this.toolTip.dispatchEvent("hidden", { chart: this, toolTip: this.toolTip }, this.toolTip)) : this.resetOverlayedCanvas();
                for (l2 = 0; l2 < this.axisX.length; l2++)
                  this.axisX[l2].crosshair && this.axisX[l2].crosshair.enabled && (this.axisX[l2].crosshair.hide(), this.axisX[l2].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisX[l2].options }, this.axisX[l2].crosshair));
                for (l2 = 0; l2 < this.axisX2.length; l2++)
                  this.axisX2[l2].crosshair && this.axisX2[l2].crosshair.enabled && (this.axisX2[l2].crosshair.hide(), this.axisX2[l2].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisX2[l2].options }, this.axisX2[l2].crosshair));
                for (l2 = 0; l2 < this.axisY.length; l2++)
                  this.axisY[l2].crosshair && this.axisY[l2].crosshair.enabled && (this.axisY[l2].crosshair.hide(), this.axisY[l2].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisY[l2].options }, this.axisY[l2].crosshair));
                for (l2 = 0; l2 < this.axisY2.length; l2++)
                  this.axisY2[l2].crosshair && this.axisY2[l2].crosshair.enabled && (this.axisY2[l2].crosshair.hide(), this.axisY2[l2].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisY2[l2].options }, this.axisY2[l2].crosshair));
              }
              this.isDrag && this.zoomEnabled || !this._eventManager || this._eventManager.mouseEventHandler(a);
            }
          }
        };
        w.prototype._plotAreaMouseDown = function(a, h2) {
          this.isDrag = true;
          this.dragStartPoint = { x: a, y: h2 };
        };
        w.prototype._plotAreaMouseUp = function(a, h2) {
          if (("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) && this.isDrag) {
            var c2 = h2 - this.dragStartPoint.y, b = a - this.dragStartPoint.x, e = 0 <= this.zoomType.indexOf("x"), l2 = 0 <= this.zoomType.indexOf("y"), C2 = false;
            this.resetOverlayedCanvas();
            if ("xySwapped" === this.plotInfo.axisPlacement)
              var f3 = l2, l2 = e, e = f3;
            if (this.panEnabled || this.zoomEnabled) {
              if (this.panEnabled)
                for (e = l2 = 0; e < this._axes.length; e++)
                  c2 = this._axes[e], c2.logarithmic ? c2.viewportMinimum < c2.minimum ? (l2 = c2.minimum / c2.viewportMinimum, c2.sessionVariables.newViewportMinimum = c2.viewportMinimum * l2, c2.sessionVariables.newViewportMaximum = c2.viewportMaximum * l2, C2 = true) : c2.viewportMaximum > c2.maximum && (l2 = c2.viewportMaximum / c2.maximum, c2.sessionVariables.newViewportMinimum = c2.viewportMinimum / l2, c2.sessionVariables.newViewportMaximum = c2.viewportMaximum / l2, C2 = true) : c2.viewportMinimum < c2.minimum ? (l2 = c2.minimum - c2.viewportMinimum, c2.sessionVariables.newViewportMinimum = c2.viewportMinimum + l2, c2.sessionVariables.newViewportMaximum = c2.viewportMaximum + l2, C2 = true) : c2.viewportMaximum > c2.maximum && (l2 = c2.viewportMaximum - c2.maximum, c2.sessionVariables.newViewportMinimum = c2.viewportMinimum - l2, c2.sessionVariables.newViewportMaximum = c2.viewportMaximum - l2, C2 = true);
              else if ((!e || 2 < Math.abs(b)) && (!l2 || 2 < Math.abs(c2)) && this.zoomEnabled) {
                if (!this.dragStartPoint)
                  return;
                c2 = e ? this.dragStartPoint.x : this.plotArea.x1;
                b = l2 ? this.dragStartPoint.y : this.plotArea.y1;
                e = e ? a : this.plotArea.x2;
                l2 = l2 ? h2 : this.plotArea.y2;
                2 < Math.abs(c2 - e) && 2 < Math.abs(b - l2) && this._zoomPanToSelectedRegion(c2, b, e, l2) && (C2 = true);
              }
              C2 && (this._ignoreNextEvent = true, this._dispatchRangeEvent("rangeChanging", "zoom"), this.stockChart && (this.stockChart.navigator && this.stockChart.navigator.enabled) && (this.stockChart._rangeEventParameter || (this.stockChart._rangeEventParameter = { stockChart: this.stockChart, source: "chart", index: this.stockChart.charts.indexOf(this), minimum: this.stockChart.sessionVariables._axisXMin, maximum: this.stockChart.sessionVariables._axisXMax }), this.stockChart._rangeEventParameter.type = "rangeChanging", this.stockChart.dispatchEvent("rangeChanging", this.stockChart._rangeEventParameter, this.stockChart)), this.render(), this._dispatchRangeEvent("rangeChanged", "zoom"), this.stockChart && (this.stockChart.navigator && this.stockChart.navigator.enabled) && (this.stockChart._rangeEventParameter.type = "rangeChanged", this.stockChart.dispatchEvent("rangeChanged", this.stockChart._rangeEventParameter, this.stockChart)), C2 && (this.zoomEnabled && "none" === this._zoomButton.style.display) && (Ta(
                this._zoomButton,
                this._resetButton
              ), xa(this, this._zoomButton, "pan"), xa(this, this._resetButton, "reset")));
            }
          }
          this.isDrag = false;
          if ("none" !== this.plotInfo.axisPlacement) {
            this.resetOverlayedCanvas();
            if (this.axisX && 0 < this.axisX.length)
              for (C2 = 0; C2 < this.axisX.length; C2++)
                this.axisX[C2].crosshair && this.axisX[C2].crosshair.enabled && this.axisX[C2].renderCrosshair(a, h2);
            if (this.axisX2 && 0 < this.axisX2.length)
              for (C2 = 0; C2 < this.axisX2.length; C2++)
                this.axisX2[C2].crosshair && this.axisX2[C2].crosshair.enabled && this.axisX2[C2].renderCrosshair(a, h2);
            if (this.axisY && 0 < this.axisY.length)
              for (C2 = 0; C2 < this.axisY.length; C2++)
                this.axisY[C2].crosshair && this.axisY[C2].crosshair.enabled && this.axisY[C2].renderCrosshair(a, h2);
            if (this.axisY2 && 0 < this.axisY2.length)
              for (C2 = 0; C2 < this.axisY2.length; C2++)
                this.axisY2[C2].crosshair && this.axisY2[C2].crosshair.enabled && this.axisY2[C2].renderCrosshair(a, h2);
            if (this.axisX && 0 < this.axisX.length)
              for (C2 = 0; C2 < this.axisX.length; C2++)
                this.axisX[C2].crosshair && this.axisX[C2].crosshair.enabled && this.axisX[C2].crosshair.renderLabel();
            if (this.axisX2 && 0 < this.axisX2.length)
              for (C2 = 0; C2 < this.axisX2.length; C2++)
                this.axisX2[C2].crosshair && this.axisX2[C2].crosshair.enabled && this.axisX2[C2].crosshair.renderLabel();
            if (this.axisY && 0 < this.axisY.length)
              for (C2 = 0; C2 < this.axisY.length; C2++)
                this.axisY[C2].crosshair && this.axisY[C2].crosshair.enabled && this.axisY[C2].crosshair.renderLabel();
            if (this.axisY2 && 0 < this.axisY2.length)
              for (C2 = 0; C2 < this.axisY2.length; C2++)
                this.axisY2[C2].crosshair && this.axisY2[C2].crosshair.enabled && this.axisY2[C2].crosshair.renderLabel();
          }
        };
        w.prototype._plotAreaMouseMove = function(a, h2) {
          if (this.isDrag && "none" !== this.plotInfo.axisPlacement) {
            var c2 = 0, b = 0, e = c2 = null, e = 0 <= this.zoomType.indexOf("x"), l2 = 0 <= this.zoomType.indexOf("y"), C2 = this;
            "xySwapped" === this.plotInfo.axisPlacement && (c2 = l2, l2 = e, e = c2);
            c2 = this.dragStartPoint.x - a;
            b = this.dragStartPoint.y - h2;
            if (2 < Math.abs(c2) && 8 > Math.abs(c2) && (this.panEnabled || this.zoomEnabled)) {
              this.toolTip.hide();
              this.toolTip && this.toolTip.enabled && this.toolTip.dispatchEvent("hidden", { chart: this, toolTip: this.toolTip }, this.toolTip);
              for (var f3 = 0; f3 < this.axisX.length; f3++)
                this.axisX[f3].crosshair && this.axisX[f3].crosshair.enabled && (this.axisX[f3].crosshair.hide(), this.axisX[f3].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisX[f3].options }, this.axisX[f3].crosshair));
              for (f3 = 0; f3 < this.axisX2.length; f3++)
                this.axisX2[f3].crosshair && this.axisX2[f3].crosshair.enabled && (this.axisX2[f3].crosshair.hide(), this.axisX2[f3].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisX2[f3].options }, this.axisX2[f3].crosshair));
              for (f3 = 0; f3 < this.axisY.length; f3++)
                this.axisY[f3].crosshair && this.axisY[f3].crosshair.enabled && (this.axisY[f3].crosshair.hide(), this.axisY[f3].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisY[f3].options }, this.axisY[f3].crosshair));
              for (f3 = 0; f3 < this.axisY2.length; f3++)
                this.axisY2[f3].crosshair && this.axisY2[f3].crosshair.enabled && (this.axisY2[f3].crosshair.hide(), this.axisY2[f3].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisY2[f3].options }, this.axisY2[f3].crosshair));
            } else
              this.panEnabled || this.zoomEnabled || this.toolTip.mouseMoveHandler(a, h2);
            if ((!e || 2 < Math.abs(c2) || !l2 || 2 < Math.abs(b)) && (this.panEnabled || this.zoomEnabled)) {
              if (this.panEnabled)
                e = { x1: e ? this.plotArea.x1 + c2 : this.plotArea.x1, y1: l2 ? this.plotArea.y1 + b : this.plotArea.y1, x2: e ? this.plotArea.x2 + c2 : this.plotArea.x2, y2: l2 ? this.plotArea.y2 + b : this.plotArea.y2 }, clearTimeout(C2._panTimerId), C2._panTimerId = setTimeout(function(b2, c3, e2, g) {
                  return function() {
                    C2._zoomPanToSelectedRegion(b2, c3, e2, g, true) && (C2._dispatchRangeEvent("rangeChanging", "pan"), C2.stockChart && (C2.stockChart.navigator && C2.stockChart.navigator.enabled) && (C2.stockChart._rangeEventParameter.type = "rangeChanging", C2.stockChart.dispatchEvent("rangeChanging", C2.stockChart._rangeEventParameter, C2.stockChart)), C2.render(), C2._dispatchRangeEvent("rangeChanged", "pan"), C2.stockChart && (C2.stockChart.navigator && C2.stockChart.navigator.enabled) && (C2.stockChart._rangeEventParameter.type = "rangeChanged", C2.stockChart.dispatchEvent("rangeChanged", C2.stockChart._rangeEventParameter, C2.stockChart)), C2.dragStartPoint.x = a, C2.dragStartPoint.y = h2);
                  };
                }(e.x1, e.y1, e.x2, e.y2), 0);
              else if (this.zoomEnabled) {
                this.resetOverlayedCanvas();
                c2 = this.overlaidCanvasCtx.globalAlpha;
                this.overlaidCanvasCtx.fillStyle = "#A89896";
                var b = e ? this.dragStartPoint.x : this.plotArea.x1, f3 = l2 ? this.dragStartPoint.y : this.plotArea.y1, d3 = e ? a - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1, m = l2 ? h2 - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1;
                this.validateRegion(b, f3, e ? a : this.plotArea.x2 - this.plotArea.x1, l2 ? h2 : this.plotArea.y2 - this.plotArea.y1, "xy" !== this.zoomType).isValid && (this.resetOverlayedCanvas(), this.overlaidCanvasCtx.fillStyle = "#99B2B5");
                this.overlaidCanvasCtx.globalAlpha = 0.7;
                this.overlaidCanvasCtx.fillRect(b, f3, d3, m);
                this.overlaidCanvasCtx.globalAlpha = c2;
              }
            }
          } else if (this.toolTip.mouseMoveHandler(a, h2), "none" !== this.plotInfo.axisPlacement) {
            if (this.axisX && 0 < this.axisX.length)
              for (e = 0; e < this.axisX.length; e++)
                this.axisX[e].crosshair && this.axisX[e].crosshair.enabled && this.axisX[e].renderCrosshair(a, h2);
            if (this.axisX2 && 0 < this.axisX2.length)
              for (e = 0; e < this.axisX2.length; e++)
                this.axisX2[e].crosshair && this.axisX2[e].crosshair.enabled && this.axisX2[e].renderCrosshair(a, h2);
            if (this.axisY && 0 < this.axisY.length)
              for (e = 0; e < this.axisY.length; e++)
                this.axisY[e].crosshair && this.axisY[e].crosshair.enabled && this.axisY[e].renderCrosshair(a, h2);
            if (this.axisY2 && 0 < this.axisY2.length)
              for (e = 0; e < this.axisY2.length; e++)
                this.axisY2[e].crosshair && this.axisY2[e].crosshair.enabled && this.axisY2[e].renderCrosshair(a, h2);
            if (this.axisX && 0 < this.axisX.length)
              for (e = 0; e < this.axisX.length; e++)
                this.axisX[e].crosshair && this.axisX[e].crosshair.enabled && this.axisX[e].crosshair.renderLabel();
            if (this.axisX2 && 0 < this.axisX2.length)
              for (e = 0; e < this.axisX2.length; e++)
                this.axisX2[e].crosshair && this.axisX2[e].crosshair.enabled && this.axisX2[e].crosshair.renderLabel();
            if (this.axisY && 0 < this.axisY.length)
              for (e = 0; e < this.axisY.length; e++)
                this.axisY[e].crosshair && this.axisY[e].crosshair.enabled && this.axisY[e].crosshair.renderLabel();
            if (this.axisY2 && 0 < this.axisY2.length)
              for (e = 0; e < this.axisY2.length; e++)
                this.axisY2[e].crosshair && this.axisY2[e].crosshair.enabled && this.axisY2[e].crosshair.renderLabel();
          }
        };
        w.prototype._zoomPanToSelectedRegion = function(a, h2, c2, b, e) {
          a = this.validateRegion(a, h2, c2, b, e);
          h2 = a.axesWithValidRange;
          c2 = a.axesRanges;
          if (a.isValid)
            for (b = 0; b < h2.length; b++)
              e = c2[b], h2[b].setViewPortRange(e.val1, e.val2), this.syncCharts && "y" != this.zoomType && this.syncCharts(e.val1, e.val2), this.stockChart && (this.stockChart._rangeEventParameter = { stockChart: this.stockChart, source: "chart", index: this.stockChart.charts.indexOf(this), minimum: e.val1, maximum: e.val2 });
          return a.isValid;
        };
        w.prototype.validateRegion = function(a, h2, c2, b, e) {
          e = e || false;
          for (var l2 = 0 <= this.zoomType.indexOf("x"), f3 = 0 <= this.zoomType.indexOf("y"), d3 = false, s2 = [], m = [], n = [], p = 0; p < this._axes.length; p++)
            ("axisX" === this._axes[p].type && l2 || "axisY" === this._axes[p].type && f3) && m.push(this._axes[p]);
          for (f3 = 0; f3 < m.length; f3++) {
            var p = m[f3], l2 = false, q = p.convertPixelToValue({ x: a, y: h2 }), g = p.convertPixelToValue({ x: c2, y: b });
            if (q > g)
              var z = g, g = q, q = z;
            if (p.scaleBreaks)
              for (z = 0; !l2 && z < p.scaleBreaks._appliedBreaks.length; z++)
                l2 = p.scaleBreaks._appliedBreaks[z].startValue <= q && p.scaleBreaks._appliedBreaks[z].endValue >= g;
            if (isFinite(p.dataInfo.minDiff)) {
              if (z = p.getApparentDifference(q, g, null, true), !(l2 || !(this.panEnabled && p.scaleBreaks && p.scaleBreaks._appliedBreaks.length) && (p.logarithmic && z < Math.pow(p.dataInfo.minDiff, 3) || !p.logarithmic && z < 3 * Math.abs(p.dataInfo.minDiff)) || q < p.minimum || g > p.maximum))
                s2.push(p), n.push({ val1: q, val2: g }), d3 = true;
              else if (!e) {
                d3 = false;
                break;
              }
            }
          }
          return { isValid: d3, axesWithValidRange: s2, axesRanges: n };
        };
        w.prototype.preparePlotArea = function() {
          var a = this.plotArea;
          !r && (0 < a.x1 || 0 < a.y1) && a.ctx.translate(a.x1, a.y1);
          if ((this.axisX[0] || this.axisX2[0]) && (this.axisY[0] || this.axisY2[0])) {
            var h2 = this.axisX[0] ? this.axisX[0].lineCoordinates : this.axisX2[0].lineCoordinates;
            if (this.axisY && 0 < this.axisY.length && this.axisY[0]) {
              var c2 = this.axisY[0];
              a.x1 = h2.x1 < h2.x2 ? h2.x1 : c2.lineCoordinates.x1;
              a.y1 = h2.y1 < c2.lineCoordinates.y1 ? h2.y1 : c2.lineCoordinates.y1;
              a.x2 = h2.x2 > c2.lineCoordinates.x2 ? h2.x2 : c2.lineCoordinates.x2;
              a.y2 = h2.y1 > c2.lineCoordinates.y2 ? h2.y1 : c2.lineCoordinates.y2;
              a.width = a.x2 - a.x1;
              a.height = a.y2 - a.y1;
            }
            this.axisY2 && 0 < this.axisY2.length && this.axisY2[0] && (c2 = this.axisY2[0], a.x1 = h2.x1 < h2.x2 ? h2.x1 : c2.lineCoordinates.x1, a.y1 = h2.y1 < c2.lineCoordinates.y1 ? h2.y1 : c2.lineCoordinates.y1, a.x2 = h2.x2 > c2.lineCoordinates.x2 ? h2.x2 : c2.lineCoordinates.x2, a.y2 = h2.y2 > c2.lineCoordinates.y2 ? h2.y2 : c2.lineCoordinates.y2, a.width = a.x2 - a.x1, a.height = a.y2 - a.y1);
          } else
            h2 = this.layoutManager.getFreeSpace(), a.x1 = h2.x1, a.x2 = h2.x2, a.y1 = h2.y1, a.y2 = h2.y2, a.width = h2.width, a.height = h2.height;
          r || (a.canvas.width = a.width, a.canvas.height = a.height, a.canvas.style.left = a.x1 + "px", a.canvas.style.top = a.y1 + "px", (0 < a.x1 || 0 < a.y1) && a.ctx.translate(
            -a.x1,
            -a.y1
          ));
          a.layoutManager = new Ka(a.x1, a.y1, a.x2, a.y2, 2);
        };
        w.prototype.renderIndexLabels = function(a) {
          var h2 = a || this.plotArea.ctx, c2 = this.plotArea, b = 0, e = 0, l2 = 0, C2 = e = l2 = 0, d3 = 0, ha = b = 0, m = 0;
          for (a = 0; a < this._indexLabels.length; a++) {
            var n = this._indexLabels[a], p = n.chartType.toLowerCase(), q, g, d3 = qa("indexLabelFontColor", n.dataPoint, n.dataSeries), z = qa("indexLabelFontSize", n.dataPoint, n.dataSeries), ha = qa("indexLabelFontFamily", n.dataPoint, n.dataSeries), m = qa("indexLabelFontStyle", n.dataPoint, n.dataSeries);
            q = qa(
              "indexLabelFontWeight",
              n.dataPoint,
              n.dataSeries
            );
            var k3 = qa("indexLabelBackgroundColor", n.dataPoint, n.dataSeries);
            g = qa("indexLabelMaxWidth", n.dataPoint, n.dataSeries);
            var l2 = qa("indexLabelWrap", n.dataPoint, n.dataSeries), v2 = qa("indexLabelLineDashType", n.dataPoint, n.dataSeries), t = qa("indexLabelLineColor", n.dataPoint, n.dataSeries), u3 = f2(n.dataPoint.indexLabelLineThickness) ? f2(n.dataSeries.options.indexLabelLineThickness) ? 0 : n.dataSeries.options.indexLabelLineThickness : n.dataPoint.indexLabelLineThickness, b = 0 < u3 ? Math.min(10, ("normal" === this.plotInfo.axisPlacement ? this.plotArea.height : this.plotArea.width) << 0) : 0, y2 = { percent: null, total: null }, N = null;
            if (0 <= n.dataSeries.type.indexOf("stacked") || "pie" === n.dataSeries.type || "doughnut" === n.dataSeries.type)
              y2 = this.getPercentAndTotal(n.dataSeries, n.dataPoint);
            if (n.dataSeries.indexLabelFormatter || n.dataPoint.indexLabelFormatter)
              N = { chart: this, dataSeries: n.dataSeries, dataPoint: n.dataPoint, index: n.indexKeyword, total: y2.total, percent: y2.percent };
            var La = n.dataPoint.indexLabelFormatter ? n.dataPoint.indexLabelFormatter(N) : n.dataPoint.indexLabel ? this.replaceKeywordsWithValue(n.dataPoint.indexLabel, n.dataPoint, n.dataSeries, null, n.indexKeyword) : n.dataSeries.indexLabelFormatter ? n.dataSeries.indexLabelFormatter(N) : n.dataSeries.indexLabel ? this.replaceKeywordsWithValue(n.dataSeries.indexLabel, n.dataPoint, n.dataSeries, null, n.indexKeyword) : null;
            if (null !== La && "" !== La) {
              var y2 = qa("indexLabelPlacement", n.dataPoint, n.dataSeries), N = qa("indexLabelOrientation", n.dataPoint, n.dataSeries), E = qa("indexLabelTextAlign", n.dataPoint, n.dataSeries), w2 = n.direction, e = n.dataSeries.axisX, C2 = n.dataSeries.axisY, x3 = false, k3 = new ma(h2, { x: 0, y: 0, maxWidth: g ? g : 0.5 * this.width, maxHeight: l2 ? 5 * z : 1.5 * z, angle: "horizontal" === N ? 0 : -90, text: La, padding: 0, backgroundColor: k3, textAlign: E, fontSize: z, fontFamily: ha, fontWeight: q, fontColor: d3, fontStyle: m, textBaseline: "middle" });
              k3.measureText();
              n.dataSeries.indexLabelMaxWidth = k3.maxWidth;
              if ("stackedarea100" === p) {
                if (n.point.x < c2.x1 || n.point.x > c2.x2 || n.point.y < c2.y1 - 1 || n.point.y > c2.y2 + 1)
                  continue;
              } else if ("rangearea" === p || "rangesplinearea" === p) {
                if (n.dataPoint.x < e.viewportMinimum || n.dataPoint.x > e.viewportMaximum || Math.max.apply(null, n.dataPoint.y) < C2.viewportMinimum || Math.min.apply(null, n.dataPoint.y) > C2.viewportMaximum)
                  continue;
              } else if (0 <= p.indexOf("line") || 0 <= p.indexOf("area") || 0 <= p.indexOf("bubble") || 0 <= p.indexOf("scatter")) {
                if (n.dataPoint.x < e.viewportMinimum || n.dataPoint.x > e.viewportMaximum || n.dataPoint.y < C2.viewportMinimum || n.dataPoint.y > C2.viewportMaximum)
                  continue;
              } else if (0 <= p.indexOf("column") || "waterfall" === p || "error" === p && !n.axisSwapped) {
                if (n.dataPoint.x < e.viewportMinimum || n.dataPoint.x > e.viewportMaximum || n.bounds.y1 > c2.y2 || n.bounds.y2 < c2.y1)
                  continue;
              } else if (0 <= p.indexOf("bar") || "error" === p) {
                if (n.dataPoint.x < e.viewportMinimum || n.dataPoint.x > e.viewportMaximum || n.bounds.x1 > c2.x2 || n.bounds.x2 < c2.x1)
                  continue;
              } else if ("candlestick" === p || "ohlc" === p) {
                if (n.dataPoint.x < e.viewportMinimum || n.dataPoint.x > e.viewportMaximum || Math.max.apply(null, n.dataPoint.y) < C2.viewportMinimum || Math.min.apply(null, n.dataPoint.y) > C2.viewportMaximum)
                  continue;
              } else if (n.dataPoint.x < e.viewportMinimum || n.dataPoint.x > e.viewportMaximum)
                continue;
              C2 = d3 = 2;
              "horizontal" === N ? (ha = k3.width, m = k3.height) : (m = k3.width, ha = k3.height);
              if ("normal" === this.plotInfo.axisPlacement) {
                if (0 <= p.indexOf("line") || 0 <= p.indexOf("area"))
                  y2 = "auto", d3 = 4;
                else if (0 <= p.indexOf("stacked"))
                  "auto" === y2 && (y2 = "inside");
                else if ("bubble" === p || "scatter" === p)
                  y2 = "inside";
                q = n.point.x - ha / 2 + ("horizontal" === N ? 0 : k3._lineHeight / 2);
                if ("inside" !== y2)
                  e = c2.y1, l2 = c2.y2, 0 < w2 ? (g = n.point.y + k3._lineHeight / 2 - m - d3 - b, g < e && (g = "auto" === y2 ? Math.max(n.point.y, e) + k3._lineHeight / 2 + d3 + b : e + k3._lineHeight / 2 + d3 + b, x3 = g + ("horizontal" === N ? m - k3._lineHeight / 2 : 0) > n.point.y, !x3 || (0 <= p.indexOf("line") || 0 <= p.indexOf("area")) || (g -= b))) : (g = n.point.y + k3._lineHeight / 2 + d3 + b, g > l2 - m + k3._lineHeight / 2 - d3 && (g = "auto" === y2 ? Math.min(n.point.y, l2) + k3._lineHeight / 2 - m - d3 - b : l2 + k3._lineHeight / 2 - m - d3 - b, x3 = g - ("horizontal" === N ? k3._lineHeight / 2 : m) < n.point.y, !x3 || (0 <= p.indexOf("line") || 0 <= p.indexOf("area")) || (g += b)));
                else {
                  Math.max(n.bounds.y1, c2.y1);
                  l2 = Math.min(n.bounds.y2, c2.y2) - m + k3._lineHeight / 2;
                  b = 0 <= p.indexOf("range") || "error" === p ? 0 < w2 ? Math.max(n.bounds.y1, c2.y1) + k3._lineHeight / 2 + d3 : Math.min(n.bounds.y2, c2.y2) + k3._lineHeight / 2 - m - d3 : (Math.max(n.bounds.y1, c2.y1) + Math.min(n.bounds.y2, c2.y2)) / 2 - m / 2 + k3._lineHeight / 2;
                  if (0 < w2) {
                    if (g = b, "bubble" === p || "scatter" === p)
                      g = n.point.y - m / 2 + k3._lineHeight / 2, m > n.bounds.y2 - n.bounds.y1 && (g -= m / 2 + d3), 0 > g - k3._lineHeight / 2 && (g += Math.abs(g - k3._lineHeight / 2) <= (n.bounds.y2 - n.bounds.y1) / 2 + d3 ? Math.abs(g - k3._lineHeight / 2) : (n.bounds.y2 - n.bounds.y1) / 2 + d3);
                  } else
                    g = Math.min(n.point.y, b), g > l2 - m - d3 && ("bubble" === p || "scatter" === p) && (g = Math.min(n.point.y + d3, c2.y2 - m - d3));
                  g = Math.min(g, l2);
                }
              } else
                0 <= p.indexOf("line") || 0 <= p.indexOf("area") || 0 <= p.indexOf("scatter") ? (y2 = "auto", C2 = 4) : 0 <= p.indexOf("stacked") ? "auto" === y2 && (y2 = "inside") : "bubble" === p && (y2 = "inside"), g = n.point.y + k3._lineHeight / 2 - m / 2, "inside" !== y2 ? (l2 = c2.x1, e = c2.x2, 0 > w2 ? (q = n.point.x - ha + ("horizontal" === N ? 0 : k3._lineHeight / 2) - C2 - b, ("horizontal" === N ? q : q - k3._lineHeight / 2) < l2 && (q = "auto" === y2 ? Math.max(n.point.x, l2) + ("horizontal" === N ? 0 : k3._lineHeight / 2) + d3 + b : l2 + ("horizontal" === N ? 0 : k3._lineHeight / 2) + C2, (x3 = q + ha - ("horizontal" === N ? 0 : k3._lineHeight / 2) > n.point.x) && (q -= b))) : (q = n.point.x + ("horizontal" === N ? 0 : k3._lineHeight / 2) + C2 + b, ("horizontal" === N ? q : q - k3._lineHeight / 2) > e - ha - C2 - b && (q = "auto" === y2 ? Math.min(n.point.x, e) - ("horizontal" === N ? ha : ha - k3._lineHeight / 2) - C2 - b : e - ha - C2 + ("horizontal" === N ? 0 : k3._lineHeight / 2), (x3 = q - ("horizontal" === N ? 0 : k3._lineHeight / 2) < n.point.x) && (q += b)))) : (l2 = Math.max(n.bounds.x1, c2.x1), Math.min(n.bounds.x2, c2.x2), b = 0 <= p.indexOf("range") || "error" === p ? 0 > w2 ? Math.max(n.bounds.x1, c2.x1) : Math.min(n.bounds.x2, c2.x2) - ha - C2 + ("horizontal" === N ? 0 : k3._lineHeight / 2) : (Math.max(n.bounds.x1, c2.x1) + Math.min(n.bounds.x2, c2.x2)) / 2 - ha / 2 + ("horizontal" === N ? 0 : k3._lineHeight / 2), q = 0 > w2 ? b : Math.min(n.point.x, b), q = Math.max(q, l2 + ("horizontal" === N ? 0 : k3._lineHeight / 2 + d3)));
              "vertical" === N && (g += m - k3._lineHeight / 2, 0 <= "ohlc candlestick boxandwhisker column rangecolumn stackedcolumn stackedcolumn100 error".split(" ").indexOf(p) && (x3 = 0 < w2 ? g + ("horizontal" === N ? m - k3._lineHeight / 2 : 0) > n.point.y : g - ("horizontal" === N ? k3._lineHeight / 2 : m) < n.point.y), "bubble" === p || "scatter" === p) && (q += k3._lineHeight / 2 - z / 2);
              k3.x = q;
              k3.y = g;
              k3.render(true);
              u3 && ("inside" !== y2 && (0 > p.indexOf("bar") && ("error" !== p || !n.axisSwapped) && n.point.x > c2.x1 && n.point.x < c2.x2 || !x3) && (-1 === "ohlc candlestick boxandwhisker column rangecolumn stackedcolumn stackedcolumn100 error".split(" ").indexOf(p) && ("error" !== p || n.axisSwapped) && n.point.y > c2.y1 && n.point.y < c2.y2 || !x3)) && (h2.lineWidth = u3, h2.strokeStyle = t ? t : "gray", h2.setLineDash && h2.setLineDash(R(v2, u3)), h2.beginPath(), h2.moveTo(n.point.x, n.point.y), 0 <= p.indexOf("bar") || "error" === p && n.axisSwapped ? h2.lineTo(q + (0 < n.direction ? 0 : ha) + ("vertical" === N ? -k3._lineHeight / 2 : 0), g + ("vertical" === N ? -m / 2 : m / 2 - k3._lineHeight / 2)) : 0 <= p.indexOf("column") || "error" === p && !n.axisSwapped ? h2.lineTo(q + ha / 2 - ("horizontal" === N ? 0 : k3._lineHeight / 2), g + ("vertical" === N ? g - m < n.point.y ? 0 : -m : (g - k3._lineHeight / 2 < n.point.y ? m : 0) - k3._lineHeight / 2)) : 0 <= p.indexOf("waterfall") ? h2.lineTo(q + ha / 2 - ("horizontal" === N ? 0 : k3._lineHeight / 2), "vertical" === N ? 0 < w2 && g < n.point.y ? g : 0 > w2 && g - m > n.point.y ? g - m : n.point.y : 0 < w2 && g + m - k3._lineHeight / 2 < n.point.y ? g + m - k3._lineHeight / 2 : 0 > w2 && g - k3._lineHeight / 2 > n.point.y ? g - k3._lineHeight / 2 : n.point.y) : h2.lineTo(q + ha / 2 - ("horizontal" === N ? 0 : k3._lineHeight / 2), g + ("vertical" === N ? g - m < n.point.y ? 0 : -m : (g + m - k3._lineHeight / 2 < n.point.y ? m : 0) - k3._lineHeight / 2)), h2.stroke());
            }
          }
          h2 = { source: h2, dest: this.plotArea.ctx, animationCallback: s.fadeInAnimation, easingFunction: s.easing.easeInQuad, animationBase: 0, startTimePercent: 0.7 };
          for (a = 0; a < this._indexLabels.length; a++)
            n = this._indexLabels[a], k3 = qa("indexLabelBackgroundColor", n.dataPoint, n.dataSeries), n.dataSeries.indexLabelBackgroundColor = f2(k3) ? r ? "transparent" : null : k3;
          return h2;
        };
        w.prototype.renderLine = function(a) {
          var h2 = a.targetCanvasCtx || this.plotArea.ctx, c2 = r ? this._preRenderCtx : h2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = this._eventManager.ghostCtx;
            c2.save();
            var e = this.plotArea;
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            for (var l2 = [], f3, d3 = 0; d3 < a.dataSeriesIndexes.length; d3++) {
              var k3 = a.dataSeriesIndexes[d3], m = this.data[k3];
              c2.lineWidth = m.lineThickness;
              var n = m.dataPoints, p = "solid";
              if (c2.setLineDash) {
                var q = R(
                  m.nullDataLineDashType,
                  m.lineThickness
                ), p = m.lineDashType, g = R(p, m.lineThickness);
                c2.setLineDash(g);
              }
              var z = m.id;
              this._eventManager.objectMap[z] = { objectType: "dataSeries", dataSeriesIndex: k3 };
              z = V(z);
              b.strokeStyle = z;
              b.lineWidth = 0 < m.lineThickness ? Math.max(m.lineThickness, 4) : 0;
              var z = m._colorSet, u3 = z = m.lineColor = m.options.lineColor ? m.options.lineColor : z[0];
              c2.strokeStyle = z;
              var B = true, t = 0, G, y2;
              c2.beginPath();
              if (0 < n.length) {
                for (var N = false, t = 0; t < n.length; t++)
                  if (G = n[t].x.getTime ? n[t].x.getTime() : n[t].x, !(G < a.axisX.dataInfo.viewPortMin || G > a.axisX.dataInfo.viewPortMax && (!m.connectNullData || !N)))
                    if ("number" !== typeof n[t].y)
                      0 < t && !(m.connectNullData || N || B) && (c2.stroke(), r && b.stroke()), N = true;
                    else {
                      G = a.axisX.convertValueToPixel(G);
                      y2 = a.axisY.convertValueToPixel(n[t].y);
                      var w2 = m.dataPointIds[t];
                      this._eventManager.objectMap[w2] = { id: w2, objectType: "dataPoint", dataSeriesIndex: k3, dataPointIndex: t, x1: G, y1: y2 };
                      B || N ? (!B && m.connectNullData ? (c2.setLineDash && (m.options.nullDataLineDashType || p === m.lineDashType && m.lineDashType !== m.nullDataLineDashType) && (c2.stroke(), c2.beginPath(), c2.moveTo(
                        f3.x,
                        f3.y
                      ), p = m.nullDataLineDashType, c2.setLineDash(q)), c2.lineTo(G, y2), r && b.lineTo(G, y2)) : (c2.beginPath(), c2.moveTo(G, y2), r && (b.beginPath(), b.moveTo(G, y2))), N = B = false) : (c2.lineTo(G, y2), r && b.lineTo(G, y2), 0 == t % 500 && (c2.stroke(), c2.beginPath(), c2.moveTo(G, y2), r && (b.stroke(), b.beginPath(), b.moveTo(G, y2))));
                      f3 = { x: G, y: y2 };
                      t < n.length - 1 && (u3 !== (n[t].lineColor || z) || p !== (n[t].lineDashType || m.lineDashType)) && (c2.stroke(), c2.beginPath(), c2.moveTo(G, y2), u3 = n[t].lineColor || z, c2.strokeStyle = u3, c2.setLineDash && (n[t].lineDashType ? (p = n[t].lineDashType, c2.setLineDash(R(p, m.lineThickness))) : (p = m.lineDashType, c2.setLineDash(g))));
                      if (0 !== n[t].markerSize && (0 < n[t].markerSize || 0 < m.markerSize)) {
                        var E = m.getMarkerProperties(t, G, y2, c2);
                        l2.push(E);
                        w2 = V(w2);
                        r && l2.push({ x: G, y: y2, ctx: b, type: E.type, size: E.size, color: w2, borderColor: w2, borderThickness: E.borderThickness });
                      }
                      (n[t].indexLabel || m.indexLabel || n[t].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({ chartType: "line", dataPoint: n[t], dataSeries: m, point: { x: G, y: y2 }, direction: 0 > n[t].y === a.axisY.reversed ? 1 : -1, color: z });
                    }
                c2.stroke();
                r && b.stroke();
              }
            }
            v.drawMarkers(l2);
            r && (h2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c2.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), b.beginPath());
            c2.restore();
            c2.beginPath();
            return { source: h2, dest: this.plotArea.ctx, animationCallback: s.xClipAnimation, easingFunction: s.easing.linear, animationBase: 0 };
          }
        };
        w.prototype.renderStepLine = function(a) {
          var h2 = a.targetCanvasCtx || this.plotArea.ctx, c2 = r ? this._preRenderCtx : h2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = this._eventManager.ghostCtx;
            c2.save();
            var e = this.plotArea;
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            for (var l2 = [], f3, d3 = 0; d3 < a.dataSeriesIndexes.length; d3++) {
              var k3 = a.dataSeriesIndexes[d3], m = this.data[k3];
              c2.lineWidth = m.lineThickness;
              var n = m.dataPoints, p = "solid";
              if (c2.setLineDash) {
                var q = R(m.nullDataLineDashType, m.lineThickness), p = m.lineDashType, g = R(p, m.lineThickness);
                c2.setLineDash(g);
              }
              var z = m.id;
              this._eventManager.objectMap[z] = { objectType: "dataSeries", dataSeriesIndex: k3 };
              z = V(z);
              b.strokeStyle = z;
              b.lineWidth = 0 < m.lineThickness ? Math.max(m.lineThickness, 4) : 0;
              var z = m._colorSet, u3 = z = m.lineColor = m.options.lineColor ? m.options.lineColor : z[0];
              c2.strokeStyle = z;
              var B = true, t = 0, G, y2;
              c2.beginPath();
              if (0 < n.length) {
                for (var N = false, t = 0; t < n.length; t++)
                  if (G = n[t].getTime ? n[t].x.getTime() : n[t].x, !(G < a.axisX.dataInfo.viewPortMin || G > a.axisX.dataInfo.viewPortMax && (!m.connectNullData || !N)))
                    if ("number" !== typeof n[t].y)
                      0 < t && !(m.connectNullData || N || B) && (c2.stroke(), r && b.stroke()), N = true;
                    else {
                      var w2 = y2;
                      G = a.axisX.convertValueToPixel(G);
                      y2 = a.axisY.convertValueToPixel(n[t].y);
                      var E = m.dataPointIds[t];
                      this._eventManager.objectMap[E] = { id: E, objectType: "dataPoint", dataSeriesIndex: k3, dataPointIndex: t, x1: G, y1: y2 };
                      B || N ? (!B && m.connectNullData ? (c2.setLineDash && (m.options.nullDataLineDashType || p === m.lineDashType && m.lineDashType !== m.nullDataLineDashType) && (c2.stroke(), c2.beginPath(), c2.moveTo(f3.x, f3.y), p = m.nullDataLineDashType, c2.setLineDash(q)), c2.lineTo(G, w2), c2.lineTo(G, y2), r && (b.lineTo(G, w2), b.lineTo(G, y2))) : (c2.beginPath(), c2.moveTo(G, y2), r && (b.beginPath(), b.moveTo(G, y2))), N = B = false) : (c2.lineTo(G, w2), r && b.lineTo(G, w2), c2.lineTo(G, y2), r && b.lineTo(G, y2), 0 == t % 500 && (c2.stroke(), c2.beginPath(), c2.moveTo(G, y2), r && (b.stroke(), b.beginPath(), b.moveTo(G, y2))));
                      f3 = { x: G, y: y2 };
                      t < n.length - 1 && (u3 !== (n[t].lineColor || z) || p !== (n[t].lineDashType || m.lineDashType)) && (c2.stroke(), c2.beginPath(), c2.moveTo(G, y2), u3 = n[t].lineColor || z, c2.strokeStyle = u3, c2.setLineDash && (n[t].lineDashType ? (p = n[t].lineDashType, c2.setLineDash(R(p, m.lineThickness))) : (p = m.lineDashType, c2.setLineDash(g))));
                      0 !== n[t].markerSize && (0 < n[t].markerSize || 0 < m.markerSize) && (w2 = m.getMarkerProperties(t, G, y2, c2), l2.push(w2), E = V(E), r && l2.push({ x: G, y: y2, ctx: b, type: w2.type, size: w2.size, color: E, borderColor: E, borderThickness: w2.borderThickness }));
                      (n[t].indexLabel || m.indexLabel || n[t].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({ chartType: "stepLine", dataPoint: n[t], dataSeries: m, point: { x: G, y: y2 }, direction: 0 > n[t].y === a.axisY.reversed ? 1 : -1, color: z });
                    }
                c2.stroke();
                r && b.stroke();
              }
            }
            v.drawMarkers(l2);
            r && (h2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c2.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), c2.clearRect(e.x1, e.y1, e.width, e.height), b.beginPath());
            c2.restore();
            c2.beginPath();
            return { source: h2, dest: this.plotArea.ctx, animationCallback: s.xClipAnimation, easingFunction: s.easing.linear, animationBase: 0 };
          }
        };
        w.prototype.renderSpline = function(a) {
          function h2(a2) {
            a2 = x2(a2, 2);
            if (0 < a2.length) {
              b.beginPath();
              r && e.beginPath();
              b.moveTo(a2[0].x, a2[0].y);
              a2[0].newStrokeStyle && (b.strokeStyle = a2[0].newStrokeStyle);
              a2[0].newLineDashArray && b.setLineDash(a2[0].newLineDashArray);
              r && e.moveTo(a2[0].x, a2[0].y);
              for (var c3 = 0; c3 < a2.length - 3; c3 += 3)
                if (b.bezierCurveTo(a2[c3 + 1].x, a2[c3 + 1].y, a2[c3 + 2].x, a2[c3 + 2].y, a2[c3 + 3].x, a2[c3 + 3].y), r && e.bezierCurveTo(a2[c3 + 1].x, a2[c3 + 1].y, a2[c3 + 2].x, a2[c3 + 2].y, a2[c3 + 3].x, a2[c3 + 3].y), 0 < c3 && 0 === c3 % 3e3 || a2[c3 + 3].newStrokeStyle || a2[c3 + 3].newLineDashArray)
                  b.stroke(), b.beginPath(), b.moveTo(a2[c3 + 3].x, a2[c3 + 3].y), a2[c3 + 3].newStrokeStyle && (b.strokeStyle = a2[c3 + 3].newStrokeStyle), a2[c3 + 3].newLineDashArray && b.setLineDash(a2[c3 + 3].newLineDashArray), r && (e.stroke(), e.beginPath(), e.moveTo(a2[c3 + 3].x, a2[c3 + 3].y));
              b.stroke();
              r && e.stroke();
            }
          }
          var c2 = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : c2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = this._eventManager.ghostCtx;
            b.save();
            var l2 = this.plotArea;
            b.beginPath();
            b.rect(l2.x1, l2.y1, l2.width, l2.height);
            b.clip();
            for (var f3 = [], d3 = 0; d3 < a.dataSeriesIndexes.length; d3++) {
              var k3 = a.dataSeriesIndexes[d3], m = this.data[k3];
              b.lineWidth = m.lineThickness;
              var n = m.dataPoints, p = "solid";
              if (b.setLineDash) {
                var q = R(m.nullDataLineDashType, m.lineThickness), p = m.lineDashType, g = R(p, m.lineThickness);
                b.setLineDash(g);
              }
              var z = m.id;
              this._eventManager.objectMap[z] = { objectType: "dataSeries", dataSeriesIndex: k3 };
              z = V(z);
              e.strokeStyle = z;
              e.lineWidth = 0 < m.lineThickness ? Math.max(m.lineThickness, 4) : 0;
              var z = m._colorSet, u3 = z = m.lineColor = m.options.lineColor ? m.options.lineColor : z[0];
              b.strokeStyle = z;
              var B = 0, t, G, y2 = [];
              b.beginPath();
              if (0 < n.length) {
                for (G = false, B = 0; B < n.length; B++)
                  if (t = n[B].getTime ? n[B].x.getTime() : n[B].x, !(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax && (!m.connectNullData || !G)))
                    if ("number" !== typeof n[B].y)
                      0 < B && !G && (m.connectNullData ? b.setLineDash && (0 < y2.length && (m.options.nullDataLineDashType || !n[B - 1].lineDashType)) && (y2[y2.length - 1].newLineDashArray = q, p = m.nullDataLineDashType) : (h2(y2), y2 = [])), G = true;
                    else {
                      t = a.axisX.convertValueToPixel(t);
                      G = a.axisY.convertValueToPixel(n[B].y);
                      var N = m.dataPointIds[B];
                      this._eventManager.objectMap[N] = { id: N, objectType: "dataPoint", dataSeriesIndex: k3, dataPointIndex: B, x1: t, y1: G };
                      y2[y2.length] = { x: t, y: G };
                      B < n.length - 1 && (u3 !== (n[B].lineColor || z) || p !== (n[B].lineDashType || m.lineDashType)) && (u3 = n[B].lineColor || z, y2[y2.length - 1].newStrokeStyle = u3, b.setLineDash && (n[B].lineDashType ? (p = n[B].lineDashType, y2[y2.length - 1].newLineDashArray = R(p, m.lineThickness)) : (p = m.lineDashType, y2[y2.length - 1].newLineDashArray = g)));
                      if (0 !== n[B].markerSize && (0 < n[B].markerSize || 0 < m.markerSize)) {
                        var w2 = m.getMarkerProperties(B, t, G, b);
                        f3.push(w2);
                        N = V(N);
                        r && f3.push({ x: t, y: G, ctx: e, type: w2.type, size: w2.size, color: N, borderColor: N, borderThickness: w2.borderThickness });
                      }
                      (n[B].indexLabel || m.indexLabel || n[B].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({
                        chartType: "spline",
                        dataPoint: n[B],
                        dataSeries: m,
                        point: { x: t, y: G },
                        direction: 0 > n[B].y === a.axisY.reversed ? 1 : -1,
                        color: z
                      });
                      G = false;
                    }
              }
              h2(y2);
            }
            v.drawMarkers(f3);
            r && (c2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(
              l2.x1,
              l2.y1,
              l2.width,
              l2.height
            ), e.beginPath());
            b.restore();
            b.beginPath();
            return { source: c2, dest: this.plotArea.ctx, animationCallback: s.xClipAnimation, easingFunction: s.easing.linear, animationBase: 0 };
          }
        };
        w.prototype.renderColumn = function(a) {
          var h2 = a.targetCanvasCtx || this.plotArea.ctx, c2 = r ? this._preRenderCtx : h2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = null, e = this.plotArea, l2 = 0, f3, d3, k3, m = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), l2 = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, n = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0, p = a.axisX.dataInfo.minDiff;
            isFinite(p) || (p = 0.3 * Math.abs(a.axisX.range));
            p = this.dataPointWidth = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) : Math.abs(p) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && l2 > n && (l2 = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, n));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && n < l2) && (n = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, l2));
            p < l2 && (p = l2);
            p > n && (p = n);
            c2.save();
            r && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (n = 0; n < a.dataSeriesIndexes.length; n++) {
              var q = a.dataSeriesIndexes[n], g = this.data[q], z = g.dataPoints;
              if (0 < z.length) {
                for (var v2 = 5 < p && g.bevelEnabled ? true : false, l2 = 0; l2 < z.length; l2++)
                  if (z[l2].getTime ? k3 = z[l2].x.getTime() : k3 = z[l2].x, !(k3 < a.axisX.dataInfo.viewPortMin || k3 > a.axisX.dataInfo.viewPortMax) && "number" === typeof z[l2].y) {
                    f3 = a.axisX.convertValueToPixel(k3);
                    d3 = a.axisY.convertValueToPixel(z[l2].y);
                    f3 = a.axisX.reversed ? f3 + a.plotType.totalDataSeries * p / 2 - (a.previousDataSeriesCount + n) * p << 0 : f3 - a.plotType.totalDataSeries * p / 2 + (a.previousDataSeriesCount + n) * p << 0;
                    var B = a.axisX.reversed ? f3 - p << 0 : f3 + p << 0, t;
                    0 <= z[l2].y ? t = m : (t = d3, d3 = m);
                    d3 > t && (b = d3, d3 = t, t = b);
                    b = z[l2].color ? z[l2].color : g._colorSet[l2 % g._colorSet.length];
                    ba(c2, a.axisX.reversed ? B : f3, d3, a.axisX.reversed ? f3 : B, t, b, 0, null, v2 && (a.axisY.reversed ? 0 > z[l2].y : 0 <= z[l2].y), (a.axisY.reversed ? 0 <= z[l2].y : 0 > z[l2].y) && v2, false, false, g.fillOpacity);
                    b = g.dataPointIds[l2];
                    this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: q, dataPointIndex: l2, x1: f3, y1: d3, x2: B, y2: t };
                    b = V(b);
                    r && ba(
                      this._eventManager.ghostCtx,
                      a.axisX.reversed ? B : f3,
                      d3,
                      a.axisX.reversed ? f3 : B,
                      t,
                      b,
                      0,
                      null,
                      false,
                      false,
                      false,
                      false
                    );
                    (z[l2].indexLabel || g.indexLabel || z[l2].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({ chartType: "column", dataPoint: z[l2], dataSeries: g, point: { x: f3 + (B - f3) / 2, y: 0 > z[l2].y === a.axisY.reversed ? d3 : t }, direction: 0 > z[l2].y === a.axisY.reversed ? 1 : -1, bounds: { x1: f3, y1: Math.min(d3, t), x2: B, y2: Math.max(d3, t) }, color: b });
                  }
              }
            }
            r && (h2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c2.drawImage(
              a.axisX.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), a.axisY.maskCanvas && c2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: h2, dest: this.plotArea.ctx, animationCallback: s.yScaleAnimation, easingFunction: s.easing.easeOutQuart, animationBase: m < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : m > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : m };
          }
        };
        w.prototype.renderStackedColumn = function(a) {
          var h2 = a.targetCanvasCtx || this.plotArea.ctx, c2 = r ? this._preRenderCtx : h2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = null, e = this.plotArea, l2 = [], f3 = [], d3 = [], k3 = [], m = 0, n, p, q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), m = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, g = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0, z = a.axisX.dataInfo.minDiff;
            isFinite(z) || (z = 0.3 * Math.abs(a.axisX.range));
            z = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(z) / Math.log(a.axisX.range) : Math.abs(z) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
            this.dataPointMaxWidth && m > g && (m = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, g));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && g < m) && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, m));
            z < m && (z = m);
            z > g && (z = g);
            c2.save();
            r && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (g = 0; g < a.dataSeriesIndexes.length; g++) {
              var v2 = a.dataSeriesIndexes[g], B = this.data[v2], t = B.dataPoints;
              if (0 < t.length) {
                var u3 = 5 < z && B.bevelEnabled ? true : false;
                c2.strokeStyle = "#4572A7 ";
                for (m = 0; m < t.length; m++)
                  if (b = t[m].x.getTime ? t[m].x.getTime() : t[m].x, !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && "number" === typeof t[m].y) {
                    n = a.axisX.convertValueToPixel(b);
                    n = n - a.plotType.plotUnits.length * z / 2 + a.index * z << 0;
                    var y2 = n + z << 0, N;
                    if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[m].y)
                      d3[b] = t[m].y + (d3[b] ? d3[b] : 0), 0 < d3[b] && (p = a.axisY.convertValueToPixel(d3[b]), N = "undefined" !== typeof l2[b] ? l2[b] : q, l2[b] = p);
                    else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[m].y)
                      k3[b] = t[m].y + (k3[b] ? k3[b] : 0), N = a.axisY.convertValueToPixel(k3[b]), p = "undefined" !== typeof f3[b] ? f3[b] : q, f3[b] = N;
                    else if (p = a.axisY.convertValueToPixel(t[m].y), 0 <= t[m].y) {
                      var w2 = "undefined" !== typeof l2[b] ? l2[b] : 0;
                      p -= w2;
                      N = q - w2;
                      l2[b] = w2 + (N - p);
                    } else
                      w2 = f3[b] ? f3[b] : 0, N = p + w2, p = q + w2, f3[b] = w2 + (N - p);
                    b = t[m].color ? t[m].color : B._colorSet[m % B._colorSet.length];
                    ba(c2, n, a.axisY.reversed ? N : p, y2, a.axisY.reversed ? p : N, b, 0, null, u3 && (a.axisY.reversed ? 0 > t[m].y : 0 <= t[m].y), (a.axisY.reversed ? 0 <= t[m].y : 0 > t[m].y) && u3, false, false, B.fillOpacity);
                    b = B.dataPointIds[m];
                    this._eventManager.objectMap[b] = {
                      id: b,
                      objectType: "dataPoint",
                      dataSeriesIndex: v2,
                      dataPointIndex: m,
                      x1: n,
                      y1: p,
                      x2: y2,
                      y2: N
                    };
                    b = V(b);
                    r && ba(this._eventManager.ghostCtx, n, p, y2, N, b, 0, null, false, false, false, false);
                    (t[m].indexLabel || B.indexLabel || t[m].indexLabelFormatter || B.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedColumn", dataPoint: t[m], dataSeries: B, point: { x: n + (y2 - n) / 2, y: 0 <= t[m].y ? p : N }, direction: 0 > t[m].y === a.axisY.reversed ? 1 : -1, bounds: { x1: n, y1: Math.min(p, N), x2: y2, y2: Math.max(p, N) }, color: b });
                  }
              }
            }
            r && (h2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c2.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: h2, dest: this.plotArea.ctx, animationCallback: s.yScaleAnimation, easingFunction: s.easing.easeOutQuart, animationBase: q < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : q > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : q };
          }
        };
        w.prototype.renderStackedColumn100 = function(a) {
          var h2 = a.targetCanvasCtx || this.plotArea.ctx, c2 = r ? this._preRenderCtx : h2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = null, e = this.plotArea, l2 = [], f3 = [], d3 = [], k3 = [], m = 0, n, p, q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), m = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, g = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0, z = a.axisX.dataInfo.minDiff;
            isFinite(z) || (z = 0.3 * Math.abs(a.axisX.range));
            z = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(z) / Math.log(a.axisX.range) : Math.abs(z) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
            this.dataPointMaxWidth && m > g && (m = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, g));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && g < m) && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, m));
            z < m && (z = m);
            z > g && (z = g);
            c2.save();
            r && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (g = 0; g < a.dataSeriesIndexes.length; g++) {
              var v2 = a.dataSeriesIndexes[g], B = this.data[v2], t = B.dataPoints;
              if (0 < t.length) {
                for (var u3 = 5 < z && B.bevelEnabled ? true : false, m = 0; m < t.length; m++)
                  if (b = t[m].x.getTime ? t[m].x.getTime() : t[m].x, !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && "number" === typeof t[m].y) {
                    n = a.axisX.convertValueToPixel(b);
                    p = 0 !== a.dataPointYSums[b] ? 100 * (t[m].y / a.dataPointYSums[b]) : 0;
                    n = n - a.plotType.plotUnits.length * z / 2 + a.index * z << 0;
                    var y2 = n + z << 0, N;
                    if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[m].y) {
                      d3[b] = p + ("undefined" !== typeof d3[b] ? d3[b] : 0);
                      if (0 >= d3[b])
                        continue;
                      p = a.axisY.convertValueToPixel(d3[b]);
                      N = l2[b] ? l2[b] : q;
                      l2[b] = p;
                    } else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[m].y)
                      k3[b] = p + ("undefined" !== typeof k3[b] ? k3[b] : 0), N = a.axisY.convertValueToPixel(k3[b]), p = f3[b] ? f3[b] : q, f3[b] = N;
                    else if (p = a.axisY.convertValueToPixel(p), 0 <= t[m].y) {
                      var w2 = "undefined" !== typeof l2[b] ? l2[b] : 0;
                      p -= w2;
                      N = q - w2;
                      a.dataSeriesIndexes.length - 1 === g && 1 >= Math.abs(e.y1 - p) && (p = e.y1);
                      l2[b] = w2 + (N - p);
                    } else
                      w2 = "undefined" !== typeof f3[b] ? f3[b] : 0, N = p + w2, p = q + w2, a.dataSeriesIndexes.length - 1 === g && 1 >= Math.abs(e.y2 - N) && (N = e.y2), f3[b] = w2 + (N - p);
                    b = t[m].color ? t[m].color : B._colorSet[m % B._colorSet.length];
                    ba(c2, n, a.axisY.reversed ? N : p, y2, a.axisY.reversed ? p : N, b, 0, null, u3 && (a.axisY.reversed ? 0 > t[m].y : 0 <= t[m].y), (a.axisY.reversed ? 0 <= t[m].y : 0 > t[m].y) && u3, false, false, B.fillOpacity);
                    b = B.dataPointIds[m];
                    this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: v2, dataPointIndex: m, x1: n, y1: p, x2: y2, y2: N };
                    b = V(b);
                    r && ba(this._eventManager.ghostCtx, n, p, y2, N, b, 0, null, false, false, false, false);
                    (t[m].indexLabel || B.indexLabel || t[m].indexLabelFormatter || B.indexLabelFormatter) && this._indexLabels.push({
                      chartType: "stackedColumn100",
                      dataPoint: t[m],
                      dataSeries: B,
                      point: { x: n + (y2 - n) / 2, y: 0 <= t[m].y ? p : N },
                      direction: 0 > t[m].y === a.axisY.reversed ? 1 : -1,
                      bounds: { x1: n, y1: Math.min(p, N), x2: y2, y2: Math.max(p, N) },
                      color: b
                    });
                  }
              }
            }
            r && (h2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c2.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: h2, dest: this.plotArea.ctx, animationCallback: s.yScaleAnimation, easingFunction: s.easing.easeOutQuart, animationBase: q < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : q > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : q };
          }
        };
        w.prototype.renderBar = function(a) {
          var h2 = a.targetCanvasCtx || this.plotArea.ctx, c2 = r ? this._preRenderCtx : h2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = null, e = this.plotArea, l2 = 0, f3, d3, k3, m = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), l2 = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, n = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0, p = a.axisX.dataInfo.minDiff;
            isFinite(p) || (p = 0.3 * Math.abs(a.axisX.range));
            p = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) : Math.abs(p) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && l2 > n && (l2 = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, n));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && n < l2) && (n = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, l2));
            p < l2 && (p = l2);
            p > n && (p = n);
            c2.save();
            r && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(
              e.x1,
              e.y1,
              e.width,
              e.height
            ), this._eventManager.ghostCtx.clip());
            for (n = 0; n < a.dataSeriesIndexes.length; n++) {
              var q = a.dataSeriesIndexes[n], g = this.data[q], z = g.dataPoints;
              if (0 < z.length) {
                var v2 = 5 < p && g.bevelEnabled ? true : false;
                c2.strokeStyle = "#4572A7 ";
                for (l2 = 0; l2 < z.length; l2++)
                  if (z[l2].getTime ? k3 = z[l2].x.getTime() : k3 = z[l2].x, !(k3 < a.axisX.dataInfo.viewPortMin || k3 > a.axisX.dataInfo.viewPortMax) && "number" === typeof z[l2].y) {
                    d3 = a.axisX.convertValueToPixel(k3);
                    f3 = a.axisY.convertValueToPixel(z[l2].y);
                    d3 = a.axisX.reversed ? d3 + a.plotType.totalDataSeries * p / 2 - (a.previousDataSeriesCount + n) * p << 0 : d3 - a.plotType.totalDataSeries * p / 2 + (a.previousDataSeriesCount + n) * p << 0;
                    var B = a.axisX.reversed ? d3 - p << 0 : d3 + p << 0, t;
                    0 <= z[l2].y ? t = m : (t = f3, f3 = m);
                    b = z[l2].color ? z[l2].color : g._colorSet[l2 % g._colorSet.length];
                    ba(c2, a.axisY.reversed ? f3 : t, a.axisX.reversed ? B : d3, a.axisY.reversed ? t : f3, a.axisX.reversed ? d3 : B, b, 0, null, v2, false, false, false, g.fillOpacity);
                    b = g.dataPointIds[l2];
                    this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: q, dataPointIndex: l2, x1: t, y1: d3, x2: f3, y2: B };
                    b = V(b);
                    r && ba(
                      this._eventManager.ghostCtx,
                      t,
                      a.axisX.reversed ? B : d3,
                      f3,
                      a.axisX.reversed ? d3 : B,
                      b,
                      0,
                      null,
                      false,
                      false,
                      false,
                      false
                    );
                    (z[l2].indexLabel || g.indexLabel || z[l2].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({ chartType: "bar", dataPoint: z[l2], dataSeries: g, point: { x: 0 <= z[l2].y ? f3 : t, y: d3 + (B - d3) / 2 }, direction: 0 > z[l2].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(t, f3), y1: d3, x2: Math.max(t, f3), y2: B }, color: b });
                  }
              }
            }
            r && (h2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c2.drawImage(
              a.axisX.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), a.axisY.maskCanvas && c2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: h2, dest: this.plotArea.ctx, animationCallback: s.xScaleAnimation, easingFunction: s.easing.easeOutQuart, animationBase: m < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : m > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : m };
          }
        };
        w.prototype.renderStackedBar = function(a) {
          var h2 = a.targetCanvasCtx || this.plotArea.ctx, c2 = r ? this._preRenderCtx : h2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = null, e = this.plotArea, l2 = [], f3 = [], d3 = [], k3 = [], m = 0, n, p, q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), m = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, g = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0, z = a.axisX.dataInfo.minDiff;
            isFinite(z) || (z = 0.3 * Math.abs(a.axisX.range));
            z = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(z) / Math.log(a.axisX.range) : Math.abs(z) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
            this.dataPointMaxWidth && m > g && (m = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, g));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && g < m) && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, m));
            z < m && (z = m);
            z > g && (z = g);
            c2.save();
            r && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (g = 0; g < a.dataSeriesIndexes.length; g++) {
              var v2 = a.dataSeriesIndexes[g], B = this.data[v2], t = B.dataPoints;
              if (0 < t.length) {
                var u3 = 5 < z && B.bevelEnabled ? true : false;
                c2.strokeStyle = "#4572A7 ";
                for (m = 0; m < t.length; m++)
                  if (b = t[m].x.getTime ? t[m].x.getTime() : t[m].x, !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && "number" === typeof t[m].y) {
                    p = a.axisX.convertValueToPixel(b);
                    p = p - a.plotType.plotUnits.length * z / 2 + a.index * z << 0;
                    var y2 = p + z << 0, w2;
                    if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[m].y)
                      d3[b] = t[m].y + (d3[b] ? d3[b] : 0), 0 < d3[b] && (w2 = l2[b] ? l2[b] : q, l2[b] = n = a.axisY.convertValueToPixel(d3[b]));
                    else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[m].y)
                      k3[b] = t[m].y + (k3[b] ? k3[b] : 0), n = f3[b] ? f3[b] : q, f3[b] = w2 = a.axisY.convertValueToPixel(k3[b]);
                    else if (n = a.axisY.convertValueToPixel(t[m].y), 0 <= t[m].y) {
                      var x3 = l2[b] ? l2[b] : 0;
                      w2 = q + x3;
                      n += x3;
                      l2[b] = x3 + (n - w2);
                    } else
                      x3 = f3[b] ? f3[b] : 0, w2 = n - x3, n = q - x3, f3[b] = x3 + (n - w2);
                    b = t[m].color ? t[m].color : B._colorSet[m % B._colorSet.length];
                    ba(c2, a.axisY.reversed ? n : w2, p, a.axisY.reversed ? w2 : n, y2, b, 0, null, u3, false, false, false, B.fillOpacity);
                    b = B.dataPointIds[m];
                    this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: v2, dataPointIndex: m, x1: w2, y1: p, x2: n, y2 };
                    b = V(b);
                    r && ba(
                      this._eventManager.ghostCtx,
                      w2,
                      p,
                      n,
                      y2,
                      b,
                      0,
                      null,
                      false,
                      false,
                      false,
                      false
                    );
                    (t[m].indexLabel || B.indexLabel || t[m].indexLabelFormatter || B.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedBar", dataPoint: t[m], dataSeries: B, point: { x: 0 <= t[m].y ? n : w2, y: p + (y2 - p) / 2 }, direction: 0 > t[m].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(w2, n), y1: p, x2: Math.max(w2, n), y2 }, color: b });
                  }
              }
            }
            r && (h2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c2.drawImage(
              a.axisX.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), a.axisY.maskCanvas && c2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: h2, dest: this.plotArea.ctx, animationCallback: s.xScaleAnimation, easingFunction: s.easing.easeOutQuart, animationBase: q < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : q > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : q };
          }
        };
        w.prototype.renderStackedBar100 = function(a) {
          var h2 = a.targetCanvasCtx || this.plotArea.ctx, c2 = r ? this._preRenderCtx : h2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = null, e = this.plotArea, l2 = [], f3 = [], d3 = [], k3 = [], m = 0, n, p, q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), m = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, g = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0, z = a.axisX.dataInfo.minDiff;
            isFinite(z) || (z = 0.3 * Math.abs(a.axisX.range));
            z = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(z) / Math.log(a.axisX.range) : Math.abs(z) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
            this.dataPointMaxWidth && m > g && (m = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, g));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && g < m) && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, m));
            z < m && (z = m);
            z > g && (z = g);
            c2.save();
            r && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (g = 0; g < a.dataSeriesIndexes.length; g++) {
              var v2 = a.dataSeriesIndexes[g], B = this.data[v2], t = B.dataPoints;
              if (0 < t.length) {
                var u3 = 5 < z && B.bevelEnabled ? true : false;
                c2.strokeStyle = "#4572A7 ";
                for (m = 0; m < t.length; m++)
                  if (b = t[m].x.getTime ? t[m].x.getTime() : t[m].x, !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && "number" === typeof t[m].y) {
                    p = a.axisX.convertValueToPixel(b);
                    var y2;
                    y2 = 0 !== a.dataPointYSums[b] ? 100 * (t[m].y / a.dataPointYSums[b]) : 0;
                    p = p - a.plotType.plotUnits.length * z / 2 + a.index * z << 0;
                    var w2 = p + z << 0;
                    if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[m].y) {
                      d3[b] = y2 + (d3[b] ? d3[b] : 0);
                      if (0 >= d3[b])
                        continue;
                      y2 = l2[b] ? l2[b] : q;
                      l2[b] = n = a.axisY.convertValueToPixel(d3[b]);
                    } else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[m].y)
                      k3[b] = y2 + (k3[b] ? k3[b] : 0), n = f3[b] ? f3[b] : q, f3[b] = y2 = a.axisY.convertValueToPixel(k3[b]);
                    else if (n = a.axisY.convertValueToPixel(y2), 0 <= t[m].y) {
                      var x3 = l2[b] ? l2[b] : 0;
                      y2 = q + x3;
                      n += x3;
                      a.dataSeriesIndexes.length - 1 === g && 1 >= Math.abs(e.x2 - n) && (n = e.x2);
                      l2[b] = x3 + (n - y2);
                    } else
                      x3 = f3[b] ? f3[b] : 0, y2 = n - x3, n = q - x3, a.dataSeriesIndexes.length - 1 === g && 1 >= Math.abs(e.x1 - y2) && (y2 = e.x1), f3[b] = x3 + (n - y2);
                    b = t[m].color ? t[m].color : B._colorSet[m % B._colorSet.length];
                    ba(c2, a.axisY.reversed ? n : y2, p, a.axisY.reversed ? y2 : n, w2, b, 0, null, u3, false, false, false, B.fillOpacity);
                    b = B.dataPointIds[m];
                    this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: v2, dataPointIndex: m, x1: y2, y1: p, x2: n, y2: w2 };
                    b = V(b);
                    r && ba(this._eventManager.ghostCtx, y2, p, n, w2, b, 0, null, false, false, false, false);
                    (t[m].indexLabel || B.indexLabel || t[m].indexLabelFormatter || B.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedBar100", dataPoint: t[m], dataSeries: B, point: { x: 0 <= t[m].y ? n : y2, y: p + (w2 - p) / 2 }, direction: 0 > t[m].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(y2, n), y1: p, x2: Math.max(y2, n), y2: w2 }, color: b });
                  }
              }
            }
            r && (h2.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), c2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c2.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return {
              source: h2,
              dest: this.plotArea.ctx,
              animationCallback: s.xScaleAnimation,
              easingFunction: s.easing.easeOutQuart,
              animationBase: q < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : q > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : q
            };
          }
        };
        w.prototype.renderArea = function(a) {
          var h2, c2;
          function b() {
            x3 && (0 < g.lineThickness && l2.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? w2 = y2 : 0 > a.axisY.viewportMaximum ? w2 = d3.y1 : 0 < a.axisY.viewportMinimum && (w2 = y2), l2.lineTo(B, w2), l2.lineTo(x3.x, w2), l2.closePath(), l2.globalAlpha = g.fillOpacity, l2.fill(), l2.globalAlpha = 1, r && (f3.lineTo(B, w2), f3.lineTo(x3.x, w2), f3.closePath(), f3.fill()), l2.beginPath(), l2.moveTo(
              B,
              t
            ), f3.beginPath(), f3.moveTo(B, t), x3 = { x: B, y: t });
          }
          var e = a.targetCanvasCtx || this.plotArea.ctx, l2 = r ? this._preRenderCtx : e;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var f3 = this._eventManager.ghostCtx, d3 = a.axisY.lineCoordinates, k3 = [], m = this.plotArea, n;
            l2.save();
            r && f3.save();
            l2.beginPath();
            l2.rect(m.x1, m.y1, m.width, m.height);
            l2.clip();
            r && (f3.beginPath(), f3.rect(m.x1, m.y1, m.width, m.height), f3.clip());
            for (var p = 0; p < a.dataSeriesIndexes.length; p++) {
              var q = a.dataSeriesIndexes[p], g = this.data[q], z = g.dataPoints, k3 = g.id;
              this._eventManager.objectMap[k3] = { objectType: "dataSeries", dataSeriesIndex: q };
              k3 = V(k3);
              f3.fillStyle = k3;
              k3 = [];
              h2 = true;
              var u3 = 0, B, t, G, y2 = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), w2, x3 = null;
              if (0 < z.length) {
                var E = g._colorSet[u3 % g._colorSet.length], A2 = g.lineColor = g.options.lineColor || E, D2 = A2;
                l2.fillStyle = E;
                l2.strokeStyle = A2;
                l2.lineWidth = g.lineThickness;
                c2 = "solid";
                if (l2.setLineDash) {
                  var Y = R(g.nullDataLineDashType, g.lineThickness);
                  c2 = g.lineDashType;
                  var W = R(c2, g.lineThickness);
                  l2.setLineDash(W);
                }
                for (var fa = true; u3 < z.length; u3++)
                  if (G = z[u3].x.getTime ? z[u3].x.getTime() : z[u3].x, !(G < a.axisX.dataInfo.viewPortMin || G > a.axisX.dataInfo.viewPortMax && (!g.connectNullData || !fa)))
                    if ("number" !== typeof z[u3].y)
                      g.connectNullData || (fa || h2) || b(), fa = true;
                    else {
                      B = a.axisX.convertValueToPixel(G);
                      t = a.axisY.convertValueToPixel(z[u3].y);
                      h2 || fa ? (!h2 && g.connectNullData ? (l2.setLineDash && (g.options.nullDataLineDashType || c2 === g.lineDashType && g.lineDashType !== g.nullDataLineDashType) && (h2 = B, c2 = t, B = n.x, t = n.y, b(), l2.moveTo(n.x, n.y), B = h2, t = c2, x3 = n, c2 = g.nullDataLineDashType, l2.setLineDash(Y)), l2.lineTo(
                        B,
                        t
                      ), r && f3.lineTo(B, t)) : (l2.beginPath(), l2.moveTo(B, t), r && (f3.beginPath(), f3.moveTo(B, t)), x3 = { x: B, y: t }), fa = h2 = false) : (l2.lineTo(B, t), r && f3.lineTo(B, t), 0 == u3 % 250 && b());
                      n = { x: B, y: t };
                      u3 < z.length - 1 && (D2 !== (z[u3].lineColor || A2) || c2 !== (z[u3].lineDashType || g.lineDashType)) && (b(), D2 = z[u3].lineColor || A2, l2.strokeStyle = D2, l2.setLineDash && (z[u3].lineDashType ? (c2 = z[u3].lineDashType, l2.setLineDash(R(c2, g.lineThickness))) : (c2 = g.lineDashType, l2.setLineDash(W))));
                      var ca = g.dataPointIds[u3];
                      this._eventManager.objectMap[ca] = {
                        id: ca,
                        objectType: "dataPoint",
                        dataSeriesIndex: q,
                        dataPointIndex: u3,
                        x1: B,
                        y1: t
                      };
                      0 !== z[u3].markerSize && (0 < z[u3].markerSize || 0 < g.markerSize) && (G = g.getMarkerProperties(u3, B, t, l2), k3.push(G), ca = V(ca), r && k3.push({ x: B, y: t, ctx: f3, type: G.type, size: G.size, color: ca, borderColor: ca, borderThickness: G.borderThickness }));
                      (z[u3].indexLabel || g.indexLabel || z[u3].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({ chartType: "area", dataPoint: z[u3], dataSeries: g, point: { x: B, y: t }, direction: 0 > z[u3].y === a.axisY.reversed ? 1 : -1, color: E });
                    }
                b();
                v.drawMarkers(k3);
              }
            }
            r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), l2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && l2.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && l2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), l2.clearRect(m.x1, m.y1, m.width, m.height), this._eventManager.ghostCtx.restore());
            l2.restore();
            return {
              source: e,
              dest: this.plotArea.ctx,
              animationCallback: s.xClipAnimation,
              easingFunction: s.easing.linear,
              animationBase: 0
            };
          }
        };
        w.prototype.renderSplineArea = function(a) {
          function h2() {
            var c3 = x2(G, 2);
            if (0 < c3.length) {
              if (0 < n.lineThickness) {
                b.beginPath();
                b.moveTo(c3[0].x, c3[0].y);
                c3[0].newStrokeStyle && (b.strokeStyle = c3[0].newStrokeStyle);
                c3[0].newLineDashArray && b.setLineDash(c3[0].newLineDashArray);
                for (var h3 = 0; h3 < c3.length - 3; h3 += 3)
                  if (b.bezierCurveTo(c3[h3 + 1].x, c3[h3 + 1].y, c3[h3 + 2].x, c3[h3 + 2].y, c3[h3 + 3].x, c3[h3 + 3].y), r && e.bezierCurveTo(c3[h3 + 1].x, c3[h3 + 1].y, c3[h3 + 2].x, c3[h3 + 2].y, c3[h3 + 3].x, c3[h3 + 3].y), c3[h3 + 3].newStrokeStyle || c3[h3 + 3].newLineDashArray)
                    b.stroke(), b.beginPath(), b.moveTo(c3[h3 + 3].x, c3[h3 + 3].y), c3[h3 + 3].newStrokeStyle && (b.strokeStyle = c3[h3 + 3].newStrokeStyle), c3[h3 + 3].newLineDashArray && b.setLineDash(c3[h3 + 3].newLineDashArray);
                b.stroke();
              }
              b.beginPath();
              b.moveTo(c3[0].x, c3[0].y);
              r && (e.beginPath(), e.moveTo(c3[0].x, c3[0].y));
              for (h3 = 0; h3 < c3.length - 3; h3 += 3)
                b.bezierCurveTo(c3[h3 + 1].x, c3[h3 + 1].y, c3[h3 + 2].x, c3[h3 + 2].y, c3[h3 + 3].x, c3[h3 + 3].y), r && e.bezierCurveTo(c3[h3 + 1].x, c3[h3 + 1].y, c3[h3 + 2].x, c3[h3 + 2].y, c3[h3 + 3].x, c3[h3 + 3].y);
              a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? B = u3 : 0 > a.axisY.viewportMaximum ? B = l2.y1 : 0 < a.axisY.viewportMinimum && (B = u3);
              t = { x: c3[0].x, y: c3[0].y };
              b.lineTo(c3[c3.length - 1].x, B);
              b.lineTo(t.x, B);
              b.closePath();
              b.globalAlpha = n.fillOpacity;
              b.fill();
              b.globalAlpha = 1;
              r && (e.lineTo(c3[c3.length - 1].x, B), e.lineTo(t.x, B), e.closePath(), e.fill());
            }
          }
          var c2 = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : c2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = this._eventManager.ghostCtx, l2 = a.axisY.lineCoordinates, f3 = [], d3 = this.plotArea;
            b.save();
            r && e.save();
            b.beginPath();
            b.rect(d3.x1, d3.y1, d3.width, d3.height);
            b.clip();
            r && (e.beginPath(), e.rect(d3.x1, d3.y1, d3.width, d3.height), e.clip());
            for (var k3 = 0; k3 < a.dataSeriesIndexes.length; k3++) {
              var m = a.dataSeriesIndexes[k3], n = this.data[m], p = n.dataPoints, f3 = n.id;
              this._eventManager.objectMap[f3] = { objectType: "dataSeries", dataSeriesIndex: m };
              f3 = V(f3);
              e.fillStyle = f3;
              var f3 = [], q = 0, g, z, u3 = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), B, t = null, G = [];
              if (0 < p.length) {
                var y2 = n._colorSet[q % n._colorSet.length], w2 = n.lineColor = n.options.lineColor || y2, La = w2;
                b.fillStyle = y2;
                b.strokeStyle = w2;
                b.lineWidth = n.lineThickness;
                var E = "solid";
                if (b.setLineDash) {
                  var A2 = R(n.nullDataLineDashType, n.lineThickness), E = n.lineDashType, D2 = R(E, n.lineThickness);
                  b.setLineDash(D2);
                }
                for (z = false; q < p.length; q++)
                  if (g = p[q].x.getTime ? p[q].x.getTime() : p[q].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax && (!n.connectNullData || !z)))
                    if ("number" !== typeof p[q].y)
                      0 < q && !z && (n.connectNullData ? b.setLineDash && (0 < G.length && (n.options.nullDataLineDashType || !p[q - 1].lineDashType)) && (G[G.length - 1].newLineDashArray = A2, E = n.nullDataLineDashType) : (h2(), G = [])), z = true;
                    else {
                      g = a.axisX.convertValueToPixel(g);
                      z = a.axisY.convertValueToPixel(p[q].y);
                      var Y = n.dataPointIds[q];
                      this._eventManager.objectMap[Y] = { id: Y, objectType: "dataPoint", dataSeriesIndex: m, dataPointIndex: q, x1: g, y1: z };
                      G[G.length] = { x: g, y: z };
                      q < p.length - 1 && (La !== (p[q].lineColor || w2) || E !== (p[q].lineDashType || n.lineDashType)) && (La = p[q].lineColor || w2, G[G.length - 1].newStrokeStyle = La, b.setLineDash && (p[q].lineDashType ? (E = p[q].lineDashType, G[G.length - 1].newLineDashArray = R(E, n.lineThickness)) : (E = n.lineDashType, G[G.length - 1].newLineDashArray = D2)));
                      if (0 !== p[q].markerSize && (0 < p[q].markerSize || 0 < n.markerSize)) {
                        var W = n.getMarkerProperties(q, g, z, b);
                        f3.push(W);
                        Y = V(Y);
                        r && f3.push({ x: g, y: z, ctx: e, type: W.type, size: W.size, color: Y, borderColor: Y, borderThickness: W.borderThickness });
                      }
                      (p[q].indexLabel || n.indexLabel || p[q].indexLabelFormatter || n.indexLabelFormatter) && this._indexLabels.push({
                        chartType: "splineArea",
                        dataPoint: p[q],
                        dataSeries: n,
                        point: { x: g, y: z },
                        direction: 0 > p[q].y === a.axisY.reversed ? 1 : -1,
                        color: y2
                      });
                      z = false;
                    }
                h2();
                v.drawMarkers(f3);
              }
            }
            r && (c2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(d3.x1, d3.y1, d3.width, d3.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: c2, dest: this.plotArea.ctx, animationCallback: s.xClipAnimation, easingFunction: s.easing.linear, animationBase: 0 };
          }
        };
        w.prototype.renderStepArea = function(a) {
          var h2, c2;
          function b() {
            x3 && (0 < g.lineThickness && l2.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? w2 = y2 : 0 > a.axisY.viewportMaximum ? w2 = d3.y1 : 0 < a.axisY.viewportMinimum && (w2 = y2), l2.lineTo(B, w2), l2.lineTo(x3.x, w2), l2.closePath(), l2.globalAlpha = g.fillOpacity, l2.fill(), l2.globalAlpha = 1, r && (f3.lineTo(B, w2), f3.lineTo(x3.x, w2), f3.closePath(), f3.fill()), l2.beginPath(), l2.moveTo(B, t), f3.beginPath(), f3.moveTo(B, t), x3 = { x: B, y: t });
          }
          var e = a.targetCanvasCtx || this.plotArea.ctx, l2 = r ? this._preRenderCtx : e;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var f3 = this._eventManager.ghostCtx, d3 = a.axisY.lineCoordinates, k3 = [], m = this.plotArea, n;
            l2.save();
            r && f3.save();
            l2.beginPath();
            l2.rect(m.x1, m.y1, m.width, m.height);
            l2.clip();
            r && (f3.beginPath(), f3.rect(m.x1, m.y1, m.width, m.height), f3.clip());
            for (var p = 0; p < a.dataSeriesIndexes.length; p++) {
              var q = a.dataSeriesIndexes[p], g = this.data[q], z = g.dataPoints, k3 = g.id;
              this._eventManager.objectMap[k3] = { objectType: "dataSeries", dataSeriesIndex: q };
              k3 = V(k3);
              f3.fillStyle = k3;
              k3 = [];
              h2 = true;
              var u3 = 0, B, t, G, y2 = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), w2, x3 = null;
              c2 = false;
              if (0 < z.length) {
                var E = g._colorSet[u3 % g._colorSet.length], A2 = g.lineColor = g.options.lineColor || E, D2 = A2;
                l2.fillStyle = E;
                l2.strokeStyle = A2;
                l2.lineWidth = g.lineThickness;
                var Y = "solid";
                if (l2.setLineDash) {
                  var W = R(g.nullDataLineDashType, g.lineThickness), Y = g.lineDashType, fa = R(Y, g.lineThickness);
                  l2.setLineDash(fa);
                }
                for (; u3 < z.length; u3++)
                  if (G = z[u3].x.getTime ? z[u3].x.getTime() : z[u3].x, !(G < a.axisX.dataInfo.viewPortMin || G > a.axisX.dataInfo.viewPortMax && (!g.connectNullData || !c2))) {
                    var ca = t;
                    "number" !== typeof z[u3].y ? (g.connectNullData || (c2 || h2) || b(), c2 = true) : (B = a.axisX.convertValueToPixel(G), t = a.axisY.convertValueToPixel(z[u3].y), h2 || c2 ? (!h2 && g.connectNullData ? (l2.setLineDash && (g.options.nullDataLineDashType || Y === g.lineDashType && g.lineDashType !== g.nullDataLineDashType) && (h2 = B, c2 = t, B = n.x, t = n.y, b(), l2.moveTo(n.x, n.y), B = h2, t = c2, x3 = n, Y = g.nullDataLineDashType, l2.setLineDash(W)), l2.lineTo(B, ca), l2.lineTo(B, t), r && (f3.lineTo(B, ca), f3.lineTo(B, t))) : (l2.beginPath(), l2.moveTo(B, t), r && (f3.beginPath(), f3.moveTo(B, t)), x3 = { x: B, y: t }), c2 = h2 = false) : (l2.lineTo(B, ca), r && f3.lineTo(B, ca), l2.lineTo(B, t), r && f3.lineTo(B, t), 0 == u3 % 250 && b()), n = { x: B, y: t }, u3 < z.length - 1 && (D2 !== (z[u3].lineColor || A2) || Y !== (z[u3].lineDashType || g.lineDashType)) && (b(), D2 = z[u3].lineColor || A2, l2.strokeStyle = D2, l2.setLineDash && (z[u3].lineDashType ? (Y = z[u3].lineDashType, l2.setLineDash(R(Y, g.lineThickness))) : (Y = g.lineDashType, l2.setLineDash(fa)))), G = g.dataPointIds[u3], this._eventManager.objectMap[G] = { id: G, objectType: "dataPoint", dataSeriesIndex: q, dataPointIndex: u3, x1: B, y1: t }, 0 !== z[u3].markerSize && (0 < z[u3].markerSize || 0 < g.markerSize) && (ca = g.getMarkerProperties(u3, B, t, l2), k3.push(ca), G = V(G), r && k3.push({ x: B, y: t, ctx: f3, type: ca.type, size: ca.size, color: G, borderColor: G, borderThickness: ca.borderThickness })), (z[u3].indexLabel || g.indexLabel || z[u3].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({ chartType: "stepArea", dataPoint: z[u3], dataSeries: g, point: { x: B, y: t }, direction: 0 > z[u3].y === a.axisY.reversed ? 1 : -1, color: E }));
                  }
                b();
                v.drawMarkers(k3);
              }
            }
            r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), l2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && l2.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && l2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), l2.clearRect(m.x1, m.y1, m.width, m.height), this._eventManager.ghostCtx.restore());
            l2.restore();
            return { source: e, dest: this.plotArea.ctx, animationCallback: s.xClipAnimation, easingFunction: s.easing.linear, animationBase: 0 };
          }
        };
        w.prototype.renderStackedArea = function(a) {
          function h2() {
            if (!(1 > m.length)) {
              for (0 < E.lineThickness && b.stroke(); 0 < m.length; ) {
                var a2 = m.pop();
                b.lineTo(a2.x, a2.y);
                r && B.lineTo(a2.x, a2.y);
              }
              b.closePath();
              b.globalAlpha = E.fillOpacity;
              b.fill();
              b.globalAlpha = 1;
              b.beginPath();
              r && (B.closePath(), B.fill(), B.beginPath());
              m = [];
            }
          }
          var c2 = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : c2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = null, l2 = null, f3 = [], d3 = this.plotArea, k3 = [], m = [], n = [], p = [], q = 0, g, z, u3 = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), B = this._eventManager.ghostCtx, t, G, y2;
            r && B.beginPath();
            b.save();
            r && B.save();
            b.beginPath();
            b.rect(d3.x1, d3.y1, d3.width, d3.height);
            b.clip();
            r && (B.beginPath(), B.rect(d3.x1, d3.y1, d3.width, d3.height), B.clip());
            for (var e = [], w2 = 0; w2 < a.dataSeriesIndexes.length; w2++) {
              var x3 = a.dataSeriesIndexes[w2], E = this.data[x3], A2 = E.dataPoints;
              E.dataPointIndexes = [];
              for (q = 0; q < A2.length; q++)
                x3 = A2[q].x.getTime ? A2[q].x.getTime() : A2[q].x, E.dataPointIndexes[x3] = q, e[x3] || (n.push(x3), e[x3] = true);
              n.sort(Ya);
            }
            for (w2 = 0; w2 < a.dataSeriesIndexes.length; w2++) {
              x3 = a.dataSeriesIndexes[w2];
              E = this.data[x3];
              A2 = E.dataPoints;
              G = true;
              m = [];
              q = E.id;
              this._eventManager.objectMap[q] = { objectType: "dataSeries", dataSeriesIndex: x3 };
              q = V(q);
              B.fillStyle = q;
              if (0 < n.length) {
                var e = E._colorSet[0], D2 = E.lineColor = E.options.lineColor || e, Y = D2;
                b.fillStyle = e;
                b.strokeStyle = D2;
                b.lineWidth = E.lineThickness;
                y2 = "solid";
                if (b.setLineDash) {
                  var W = R(E.nullDataLineDashType, E.lineThickness);
                  y2 = E.lineDashType;
                  var fa = R(y2, E.lineThickness);
                  b.setLineDash(fa);
                }
                for (var ca = true, q = 0; q < n.length; q++) {
                  var l2 = n[q], ka = null, ka = 0 <= E.dataPointIndexes[l2] ? A2[E.dataPointIndexes[l2]] : { x: l2, y: null };
                  if (!(l2 < a.axisX.dataInfo.viewPortMin || l2 > a.axisX.dataInfo.viewPortMax && (!E.connectNullData || !ca)))
                    if ("number" !== typeof ka.y)
                      E.connectNullData || (ca || G) || h2(), ca = true;
                    else {
                      g = a.axisX.convertValueToPixel(l2);
                      var va = k3[l2] ? k3[l2] : 0;
                      if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {
                        p[l2] = ka.y + (p[l2] ? p[l2] : 0);
                        if (0 >= p[l2] && a.axisY.logarithmic)
                          continue;
                        z = a.axisY.convertValueToPixel(p[l2]);
                      } else
                        z = a.axisY.convertValueToPixel(ka.y), z -= va;
                      m.push({ x: g, y: u3 - va });
                      k3[l2] = u3 - z;
                      G || ca ? (!G && E.connectNullData ? (b.setLineDash && (E.options.nullDataLineDashType || y2 === E.lineDashType && E.lineDashType !== E.nullDataLineDashType) && (G = m.pop(), y2 = m[m.length - 1], h2(), b.moveTo(t.x, t.y), m.push(y2), m.push(G), y2 = E.nullDataLineDashType, b.setLineDash(W)), b.lineTo(g, z), r && B.lineTo(g, z)) : (b.beginPath(), b.moveTo(g, z), r && (B.beginPath(), B.moveTo(g, z))), ca = G = false) : (b.lineTo(g, z), r && B.lineTo(g, z), 0 == q % 250 && (h2(), b.moveTo(g, z), r && B.moveTo(g, z), m.push({ x: g, y: u3 - va })));
                      t = { x: g, y: z };
                      q < A2.length - 1 && (Y !== (A2[q].lineColor || D2) || y2 !== (A2[q].lineDashType || E.lineDashType)) && (h2(), b.beginPath(), b.moveTo(g, z), m.push({ x: g, y: u3 - va }), Y = A2[q].lineColor || D2, b.strokeStyle = Y, b.setLineDash && (A2[q].lineDashType ? (y2 = A2[q].lineDashType, b.setLineDash(R(y2, E.lineThickness))) : (y2 = E.lineDashType, b.setLineDash(fa))));
                      if (0 <= E.dataPointIndexes[l2]) {
                        var oa = E.dataPointIds[E.dataPointIndexes[l2]];
                        this._eventManager.objectMap[oa] = { id: oa, objectType: "dataPoint", dataSeriesIndex: x3, dataPointIndex: E.dataPointIndexes[l2], x1: g, y1: z };
                      }
                      0 <= E.dataPointIndexes[l2] && 0 !== ka.markerSize && (0 < ka.markerSize || 0 < E.markerSize) && (va = E.getMarkerProperties(E.dataPointIndexes[l2], g, z, b), f3.push(va), l2 = V(oa), r && f3.push({ x: g, y: z, ctx: B, type: va.type, size: va.size, color: l2, borderColor: l2, borderThickness: va.borderThickness }));
                      (ka.indexLabel || E.indexLabel || ka.indexLabelFormatter || E.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedArea", dataPoint: ka, dataSeries: E, point: { x: g, y: z }, direction: 0 > ka.y === a.axisY.reversed ? 1 : -1, color: e });
                    }
                }
                h2();
                b.moveTo(g, z);
                r && B.moveTo(g, z);
              }
              delete E.dataPointIndexes;
            }
            v.drawMarkers(f3);
            r && (c2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(d3.x1, d3.y1, d3.width, d3.height), B.restore());
            b.restore();
            return { source: c2, dest: this.plotArea.ctx, animationCallback: s.xClipAnimation, easingFunction: s.easing.linear, animationBase: 0 };
          }
        };
        w.prototype.renderStackedArea100 = function(a) {
          function h2() {
            for (0 < E.lineThickness && b.stroke(); 0 < m.length; ) {
              var a2 = m.pop();
              b.lineTo(a2.x, a2.y);
              r && y2.lineTo(
                a2.x,
                a2.y
              );
            }
            b.closePath();
            b.globalAlpha = E.fillOpacity;
            b.fill();
            b.globalAlpha = 1;
            b.beginPath();
            r && (y2.closePath(), y2.fill(), y2.beginPath());
            m = [];
          }
          var c2 = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : c2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = null, l2 = null, f3 = this.plotArea, d3 = [], k3 = [], m = [], n = [], p = [], q = 0, g, z, u3, B, t, G = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), y2 = this._eventManager.ghostCtx;
            b.save();
            r && y2.save();
            b.beginPath();
            b.rect(f3.x1, f3.y1, f3.width, f3.height);
            b.clip();
            r && (y2.beginPath(), y2.rect(f3.x1, f3.y1, f3.width, f3.height), y2.clip());
            for (var e = [], w2 = 0; w2 < a.dataSeriesIndexes.length; w2++) {
              var x3 = a.dataSeriesIndexes[w2], E = this.data[x3], A2 = E.dataPoints;
              E.dataPointIndexes = [];
              for (q = 0; q < A2.length; q++)
                x3 = A2[q].x.getTime ? A2[q].x.getTime() : A2[q].x, E.dataPointIndexes[x3] = q, e[x3] || (n.push(x3), e[x3] = true);
              n.sort(Ya);
            }
            for (w2 = 0; w2 < a.dataSeriesIndexes.length; w2++) {
              x3 = a.dataSeriesIndexes[w2];
              E = this.data[x3];
              A2 = E.dataPoints;
              B = true;
              e = E.id;
              this._eventManager.objectMap[e] = { objectType: "dataSeries", dataSeriesIndex: x3 };
              e = V(e);
              y2.fillStyle = e;
              m = [];
              if (0 < n.length) {
                var e = E._colorSet[q % E._colorSet.length], D2 = E.lineColor = E.options.lineColor || e, Y = D2;
                b.fillStyle = e;
                b.strokeStyle = D2;
                b.lineWidth = E.lineThickness;
                t = "solid";
                if (b.setLineDash) {
                  var W = R(E.nullDataLineDashType, E.lineThickness);
                  t = E.lineDashType;
                  var fa = R(t, E.lineThickness);
                  b.setLineDash(fa);
                }
                for (var ca = true, q = 0; q < n.length; q++) {
                  var l2 = n[q], ka = null, ka = 0 <= E.dataPointIndexes[l2] ? A2[E.dataPointIndexes[l2]] : { x: l2, y: null };
                  if (!(l2 < a.axisX.dataInfo.viewPortMin || l2 > a.axisX.dataInfo.viewPortMax && (!E.connectNullData || !ca)))
                    if ("number" !== typeof ka.y)
                      E.connectNullData || (ca || B) || h2(), ca = true;
                    else {
                      var va;
                      va = 0 !== a.dataPointYSums[l2] ? 100 * (ka.y / a.dataPointYSums[l2]) : 0;
                      g = a.axisX.convertValueToPixel(l2);
                      var oa = k3[l2] ? k3[l2] : 0;
                      if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {
                        p[l2] = va + (p[l2] ? p[l2] : 0);
                        if (0 >= p[l2] && a.axisY.logarithmic)
                          continue;
                        z = a.axisY.convertValueToPixel(p[l2]);
                      } else
                        z = a.axisY.convertValueToPixel(va), z -= oa;
                      m.push({ x: g, y: G - oa });
                      k3[l2] = G - z;
                      B || ca ? (!B && E.connectNullData ? (b.setLineDash && (E.options.nullDataLineDashType || t === E.lineDashType && E.lineDashType !== E.nullDataLineDashType) && (B = m.pop(), t = m[m.length - 1], h2(), b.moveTo(u3.x, u3.y), m.push(t), m.push(B), t = E.nullDataLineDashType, b.setLineDash(W)), b.lineTo(g, z), r && y2.lineTo(g, z)) : (b.beginPath(), b.moveTo(g, z), r && (y2.beginPath(), y2.moveTo(g, z))), ca = B = false) : (b.lineTo(g, z), r && y2.lineTo(g, z), 0 == q % 250 && (h2(), b.moveTo(g, z), r && y2.moveTo(g, z), m.push({ x: g, y: G - oa })));
                      u3 = { x: g, y: z };
                      q < A2.length - 1 && (Y !== (A2[q].lineColor || D2) || t !== (A2[q].lineDashType || E.lineDashType)) && (h2(), b.beginPath(), b.moveTo(g, z), m.push({ x: g, y: G - oa }), Y = A2[q].lineColor || D2, b.strokeStyle = Y, b.setLineDash && (A2[q].lineDashType ? (t = A2[q].lineDashType, b.setLineDash(R(t, E.lineThickness))) : (t = E.lineDashType, b.setLineDash(fa))));
                      if (0 <= E.dataPointIndexes[l2]) {
                        var H = E.dataPointIds[E.dataPointIndexes[l2]];
                        this._eventManager.objectMap[H] = { id: H, objectType: "dataPoint", dataSeriesIndex: x3, dataPointIndex: E.dataPointIndexes[l2], x1: g, y1: z };
                      }
                      0 <= E.dataPointIndexes[l2] && 0 !== ka.markerSize && (0 < ka.markerSize || 0 < E.markerSize) && (oa = E.getMarkerProperties(E.dataPointIndexes[l2], g, z, b), d3.push(oa), l2 = V(H), r && d3.push({ x: g, y: z, ctx: y2, type: oa.type, size: oa.size, color: l2, borderColor: l2, borderThickness: oa.borderThickness }));
                      (ka.indexLabel || E.indexLabel || ka.indexLabelFormatter || E.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedArea100", dataPoint: ka, dataSeries: E, point: { x: g, y: z }, direction: 0 > ka.y === a.axisY.reversed ? 1 : -1, color: e });
                    }
                }
                h2();
                b.moveTo(g, z);
                r && y2.moveTo(g, z);
              }
              delete E.dataPointIndexes;
            }
            v.drawMarkers(d3);
            r && (c2.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(f3.x1, f3.y1, f3.width, f3.height), y2.restore());
            b.restore();
            return {
              source: c2,
              dest: this.plotArea.ctx,
              animationCallback: s.xClipAnimation,
              easingFunction: s.easing.linear,
              animationBase: 0
            };
          }
        };
        w.prototype.renderBubble = function(a) {
          var h2 = a.targetCanvasCtx || this.plotArea.ctx, c2 = r ? this._preRenderCtx : h2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = this.plotArea, e = 0, l2, f3;
            c2.save();
            r && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(b.x1, b.y1, b.width, b.height);
            c2.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.clip());
            for (var d3 = -Infinity, k3 = Infinity, m = 0; m < a.dataSeriesIndexes.length; m++)
              for (var n = a.dataSeriesIndexes[m], p = this.data[n], q = p.dataPoints, g = 0, e = 0; e < q.length; e++)
                l2 = q[e].getTime ? l2 = q[e].x.getTime() : l2 = q[e].x, l2 < a.axisX.dataInfo.viewPortMin || l2 > a.axisX.dataInfo.viewPortMax || "undefined" === typeof q[e].z || (g = q[e].z, g > d3 && (d3 = g), g < k3 && (k3 = g));
            for (var z = 25 * Math.PI, u3 = Math.max(Math.pow(0.25 * Math.min(b.height, b.width) / 2, 2) * Math.PI, z), m = 0; m < a.dataSeriesIndexes.length; m++)
              if (n = a.dataSeriesIndexes[m], p = this.data[n], q = p.dataPoints, 0 < q.length) {
                for (c2.strokeStyle = "#4572A7 ", e = 0; e < q.length; e++)
                  if (l2 = q[e].getTime ? l2 = q[e].x.getTime() : l2 = q[e].x, !(l2 < a.axisX.dataInfo.viewPortMin || l2 > a.axisX.dataInfo.viewPortMax) && "number" === typeof q[e].y) {
                    l2 = a.axisX.convertValueToPixel(l2);
                    f3 = a.axisY.convertValueToPixel(q[e].y);
                    var g = q[e].z, B = 2 * Math.max(Math.sqrt((d3 === k3 ? u3 / 2 : z + (u3 - z) / (d3 - k3) * (g - k3)) / Math.PI) << 0, 1), g = p.getMarkerProperties(e, c2);
                    g.size = B;
                    c2.globalAlpha = p.fillOpacity;
                    v.drawMarker(l2, f3, c2, g.type, g.size, g.color, g.borderColor, g.borderThickness);
                    c2.globalAlpha = 1;
                    var t = p.dataPointIds[e];
                    this._eventManager.objectMap[t] = {
                      id: t,
                      objectType: "dataPoint",
                      dataSeriesIndex: n,
                      dataPointIndex: e,
                      x1: l2,
                      y1: f3,
                      size: B
                    };
                    B = V(t);
                    r && v.drawMarker(l2, f3, this._eventManager.ghostCtx, g.type, g.size, B, B, g.borderThickness);
                    (q[e].indexLabel || p.indexLabel || q[e].indexLabelFormatter || p.indexLabelFormatter) && this._indexLabels.push({ chartType: "bubble", dataPoint: q[e], dataSeries: p, point: { x: l2, y: f3 }, direction: 1, bounds: { x1: l2 - g.size / 2, y1: f3 - g.size / 2, x2: l2 + g.size / 2, y2: f3 + g.size / 2 }, color: null });
                  }
              }
            r && (h2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c2.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: h2, dest: this.plotArea.ctx, animationCallback: s.fadeInAnimation, easingFunction: s.easing.easeInQuad, animationBase: 0 };
          }
        };
        w.prototype.renderScatter = function(a) {
          var h2 = a.targetCanvasCtx || this.plotArea.ctx, c2 = r ? this._preRenderCtx : h2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = this.plotArea, e = 0, l2, f3;
            c2.save();
            r && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(b.x1, b.y1, b.width, b.height);
            c2.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.clip());
            for (var d3 = 0; d3 < a.dataSeriesIndexes.length; d3++) {
              var k3 = a.dataSeriesIndexes[d3], m = this.data[k3], n = m.dataPoints;
              if (0 < n.length) {
                c2.strokeStyle = "#4572A7 ";
                Math.pow(0.3 * Math.min(b.height, b.width) / 2, 2);
                for (var p = 0, q = 0, e = 0; e < n.length; e++)
                  if (l2 = n[e].getTime ? l2 = n[e].x.getTime() : l2 = n[e].x, !(l2 < a.axisX.dataInfo.viewPortMin || l2 > a.axisX.dataInfo.viewPortMax) && "number" === typeof n[e].y) {
                    l2 = a.axisX.convertValueToPixel(l2);
                    f3 = a.axisY.convertValueToPixel(n[e].y);
                    var g = m.getMarkerProperties(e, l2, f3, c2);
                    c2.globalAlpha = m.fillOpacity;
                    v.drawMarker(g.x, g.y, g.ctx, g.type, g.size, g.color, g.borderColor, g.borderThickness);
                    c2.globalAlpha = 1;
                    Math.sqrt((p - l2) * (p - l2) + (q - f3) * (q - f3)) < Math.min(g.size, 5) && n.length > Math.min(this.plotArea.width, this.plotArea.height) || (p = m.dataPointIds[e], this._eventManager.objectMap[p] = { id: p, objectType: "dataPoint", dataSeriesIndex: k3, dataPointIndex: e, x1: l2, y1: f3 }, p = V(p), r && v.drawMarker(g.x, g.y, this._eventManager.ghostCtx, g.type, g.size, p, p, g.borderThickness), (n[e].indexLabel || m.indexLabel || n[e].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({
                      chartType: "scatter",
                      dataPoint: n[e],
                      dataSeries: m,
                      point: { x: l2, y: f3 },
                      direction: 1,
                      bounds: { x1: l2 - g.size / 2, y1: f3 - g.size / 2, x2: l2 + g.size / 2, y2: f3 + g.size / 2 },
                      color: null
                    }), p = l2, q = f3);
                  }
              }
            }
            r && (h2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c2.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: h2, dest: this.plotArea.ctx, animationCallback: s.fadeInAnimation, easingFunction: s.easing.easeInQuad, animationBase: 0 };
          }
        };
        w.prototype.renderCandlestick = function(a) {
          var h2 = a.targetCanvasCtx || this.plotArea.ctx, c2 = r ? this._preRenderCtx : h2, b = this._eventManager.ghostCtx;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = null, l2 = null, d3 = this.plotArea, k3 = 0, u3, m, n, p, q, g, e = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, l2 = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.015 * this.width, z = a.axisX.dataInfo.minDiff;
            isFinite(z) || (z = 0.3 * Math.abs(a.axisX.range));
            z = this.options.dataPointWidth ? this.dataPointWidth : 0.7 * d3.width * (a.axisX.logarithmic ? Math.log(z) / Math.log(a.axisX.range) : Math.abs(z) / Math.abs(a.axisX.range)) << 0;
            this.dataPointMaxWidth && e > l2 && (e = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, l2));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && l2 < e) && (l2 = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, e));
            z < e && (z = e);
            z > l2 && (z = l2);
            c2.save();
            r && b.save();
            c2.beginPath();
            c2.rect(d3.x1, d3.y1, d3.width, d3.height);
            c2.clip();
            r && (b.beginPath(), b.rect(d3.x1, d3.y1, d3.width, d3.height), b.clip());
            for (var v2 = 0; v2 < a.dataSeriesIndexes.length; v2++) {
              var B = a.dataSeriesIndexes[v2], t = this.data[B], G = t.dataPoints;
              if (0 < G.length) {
                for (var y2 = 5 < z && t.bevelEnabled ? true : false, k3 = 0; k3 < G.length; k3++)
                  if (G[k3].getTime ? g = G[k3].x.getTime() : g = G[k3].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && !f2(G[k3].y) && G[k3].y.length && "number" === typeof G[k3].y[0] && "number" === typeof G[k3].y[1] && "number" === typeof G[k3].y[2] && "number" === typeof G[k3].y[3]) {
                    u3 = a.axisX.convertValueToPixel(g);
                    m = a.axisY.convertValueToPixel(G[k3].y[0]);
                    n = a.axisY.convertValueToPixel(G[k3].y[1]);
                    p = a.axisY.convertValueToPixel(G[k3].y[2]);
                    q = a.axisY.convertValueToPixel(G[k3].y[3]);
                    var w2 = u3 - z / 2 << 0, x3 = w2 + z << 0, l2 = t.options.fallingColor ? t.fallingColor : t._colorSet[0], e = G[k3].color ? G[k3].color : t._colorSet[0], E = Math.round(Math.max(1, 0.15 * z)), A2 = 0 === E % 2 ? 0 : 0.5, D2 = t.dataPointIds[k3];
                    this._eventManager.objectMap[D2] = { id: D2, objectType: "dataPoint", dataSeriesIndex: B, dataPointIndex: k3, x1: w2, y1: m, x2: x3, y2: n, x3: u3, y3: p, x4: u3, y4: q, borderThickness: E, color: e };
                    c2.strokeStyle = e;
                    c2.beginPath();
                    c2.lineWidth = E;
                    b.lineWidth = Math.max(E, 4);
                    "candlestick" === t.type ? (c2.moveTo(u3 - A2, n), c2.lineTo(u3 - A2, Math.min(m, q)), c2.stroke(), c2.moveTo(u3 - A2, Math.max(m, q)), c2.lineTo(u3 - A2, p), c2.stroke(), ba(c2, w2, Math.min(m, q), x3, Math.max(m, q), G[k3].y[0] <= G[k3].y[3] ? t.risingColor : l2, E, e, y2, y2, false, false, t.fillOpacity), r && (e = V(D2), b.strokeStyle = e, b.moveTo(u3 - A2, n), b.lineTo(u3 - A2, Math.min(
                      m,
                      q
                    )), b.stroke(), b.moveTo(u3 - A2, Math.max(m, q)), b.lineTo(u3 - A2, p), b.stroke(), ba(b, w2, Math.min(m, q), x3, Math.max(m, q), e, 0, null, false, false, false, false))) : "ohlc" === t.type && (c2.moveTo(u3 - A2, n), c2.lineTo(u3 - A2, p), c2.stroke(), c2.beginPath(), c2.moveTo(u3, m), c2.lineTo(w2, m), c2.stroke(), c2.beginPath(), c2.moveTo(u3, q), c2.lineTo(x3, q), c2.stroke(), r && (e = V(D2), b.strokeStyle = e, b.moveTo(u3 - A2, n), b.lineTo(u3 - A2, p), b.stroke(), b.beginPath(), b.moveTo(u3, m), b.lineTo(w2, m), b.stroke(), b.beginPath(), b.moveTo(u3, q), b.lineTo(x3, q), b.stroke()));
                    (G[k3].indexLabel || t.indexLabel || G[k3].indexLabelFormatter || t.indexLabelFormatter) && this._indexLabels.push({ chartType: t.type, dataPoint: G[k3], dataSeries: t, point: { x: w2 + (x3 - w2) / 2, y: a.axisY.reversed ? p : n }, direction: 1, bounds: { x1: w2, y1: Math.min(n, p), x2: x3, y2: Math.max(n, p) }, color: e });
                  }
              }
            }
            r && (h2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c2.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(d3.x1, d3.y1, d3.width, d3.height), b.restore());
            c2.restore();
            return { source: h2, dest: this.plotArea.ctx, animationCallback: s.fadeInAnimation, easingFunction: s.easing.easeInQuad, animationBase: 0 };
          }
        };
        w.prototype.renderBoxAndWhisker = function(a) {
          var h2 = a.targetCanvasCtx || this.plotArea.ctx, c2 = r ? this._preRenderCtx : h2, b = this._eventManager.ghostCtx;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = null, l2 = this.plotArea, d3 = 0, k3, u3, m, n, p, q, g, e = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, d3 = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.015 * this.width, z = a.axisX.dataInfo.minDiff;
            isFinite(z) || (z = 0.3 * Math.abs(a.axisX.range));
            z = this.options.dataPointWidth ? this.dataPointWidth : 0.7 * l2.width * (a.axisX.logarithmic ? Math.log(z) / Math.log(a.axisX.range) : Math.abs(z) / Math.abs(a.axisX.range)) << 0;
            this.dataPointMaxWidth && e > d3 && (e = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, d3));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && d3 < e) && (d3 = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, e));
            z < e && (z = e);
            z > d3 && (z = d3);
            c2.save();
            r && b.save();
            c2.beginPath();
            c2.rect(l2.x1, l2.y1, l2.width, l2.height);
            c2.clip();
            r && (b.beginPath(), b.rect(l2.x1, l2.y1, l2.width, l2.height), b.clip());
            for (var v2 = false, v2 = !!a.axisY.reversed, B = 0; B < a.dataSeriesIndexes.length; B++) {
              var t = a.dataSeriesIndexes[B], G = this.data[t], y2 = G.dataPoints;
              if (0 < y2.length) {
                for (var w2 = 5 < z && G.bevelEnabled ? true : false, d3 = 0; d3 < y2.length; d3++)
                  if (y2[d3].getTime ? g = y2[d3].x.getTime() : g = y2[d3].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && !f2(y2[d3].y) && y2[d3].y.length && "number" === typeof y2[d3].y[0] && "number" === typeof y2[d3].y[1] && "number" === typeof y2[d3].y[2] && "number" === typeof y2[d3].y[3] && "number" === typeof y2[d3].y[4] && 5 === y2[d3].y.length) {
                    k3 = a.axisX.convertValueToPixel(g);
                    u3 = a.axisY.convertValueToPixel(y2[d3].y[0]);
                    m = a.axisY.convertValueToPixel(y2[d3].y[1]);
                    n = a.axisY.convertValueToPixel(y2[d3].y[2]);
                    p = a.axisY.convertValueToPixel(y2[d3].y[3]);
                    q = a.axisY.convertValueToPixel(y2[d3].y[4]);
                    var x3 = k3 - z / 2 << 0, E = k3 + z / 2 << 0, e = y2[d3].color ? y2[d3].color : G._colorSet[0], A2 = Math.round(Math.max(1, 0.15 * z)), D2 = 0 === A2 % 2 ? 0 : 0.5, Y = y2[d3].whiskerColor ? y2[d3].whiskerColor : y2[d3].color ? G.whiskerColor ? G.whiskerColor : y2[d3].color : G.whiskerColor ? G.whiskerColor : e, W = "number" === typeof y2[d3].whiskerThickness ? y2[d3].whiskerThickness : "number" === typeof G.options.whiskerThickness ? G.whiskerThickness : A2, fa = y2[d3].whiskerDashType ? y2[d3].whiskerDashType : G.whiskerDashType, ca = f2(y2[d3].whiskerLength) ? f2(G.options.whiskerLength) ? z : G.whiskerLength : y2[d3].whiskerLength, ca = "number" === typeof ca ? 0 >= ca ? 0 : ca >= z ? z : ca : "string" === typeof ca ? parseInt(ca) * z / 100 > z ? z : parseInt(ca) * z / 100 : z, ka = 1 === Math.round(W) % 2 ? 0.5 : 0, va = y2[d3].stemColor ? y2[d3].stemColor : y2[d3].color ? G.stemColor ? G.stemColor : y2[d3].color : G.stemColor ? G.stemColor : e, oa = "number" === typeof y2[d3].stemThickness ? y2[d3].stemThickness : "number" === typeof G.options.stemThickness ? G.stemThickness : A2, H = 1 === Math.round(oa) % 2 ? 0.5 : 0, K = y2[d3].stemDashType ? y2[d3].stemDashType : G.stemDashType, F3 = y2[d3].lineColor ? y2[d3].lineColor : y2[d3].color ? G.lineColor ? G.lineColor : y2[d3].color : G.lineColor ? G.lineColor : e, J = "number" === typeof y2[d3].lineThickness ? y2[d3].lineThickness : "number" === typeof G.options.lineThickness ? G.lineThickness : A2, L3 = y2[d3].lineDashType ? y2[d3].lineDashType : G.lineDashType, S2 = 1 === Math.round(J) % 2 ? 0.5 : 0, O2 = G.upperBoxColor, Q2 = G.lowerBoxColor, P2 = f2(G.options.fillOpacity) ? 1 : G.fillOpacity, U = G.dataPointIds[d3];
                    this._eventManager.objectMap[U] = {
                      id: U,
                      objectType: "dataPoint",
                      dataSeriesIndex: t,
                      dataPointIndex: d3,
                      x1: x3,
                      y1: u3,
                      x2: E,
                      y2: m,
                      x3: k3,
                      y3: n,
                      x4: k3,
                      y4: p,
                      y5: q,
                      borderThickness: A2,
                      color: e,
                      stemThickness: oa,
                      stemColor: va,
                      whiskerThickness: W,
                      whiskerLength: ca,
                      whiskerColor: Y,
                      lineThickness: J,
                      lineColor: F3
                    };
                    c2.save();
                    0 < oa && (c2.beginPath(), c2.strokeStyle = va, c2.lineWidth = oa, c2.setLineDash && c2.setLineDash(R(K, oa)), c2.moveTo(k3 - H, m), c2.lineTo(k3 - H, u3), c2.stroke(), c2.moveTo(k3 - H, p), c2.lineTo(k3 - H, n), c2.stroke());
                    c2.restore();
                    b.lineWidth = Math.max(A2, 4);
                    c2.beginPath();
                    ba(c2, x3, Math.min(q, m), E, Math.max(m, q), Q2, 0, e, v2 ? w2 : false, v2 ? false : w2, false, false, P2);
                    c2.beginPath();
                    ba(
                      c2,
                      x3,
                      Math.min(n, q),
                      E,
                      Math.max(q, n),
                      O2,
                      0,
                      e,
                      v2 ? false : w2,
                      v2 ? w2 : false,
                      false,
                      false,
                      P2
                    );
                    c2.beginPath();
                    c2.lineWidth = A2;
                    c2.strokeStyle = e;
                    c2.rect(x3 - D2, Math.min(m, n) - D2, E - x3 + 2 * D2, Math.max(m, n) - Math.min(m, n) + 2 * D2);
                    c2.stroke();
                    c2.save();
                    0 < J && (c2.beginPath(), c2.globalAlpha = 1, c2.setLineDash && c2.setLineDash(R(L3, J)), c2.strokeStyle = F3, c2.lineWidth = J, c2.moveTo(x3, q - S2), c2.lineTo(E, q - S2), c2.stroke());
                    c2.restore();
                    c2.save();
                    0 < W && (c2.beginPath(), c2.setLineDash && c2.setLineDash(R(fa, W)), c2.strokeStyle = Y, c2.lineWidth = W, c2.moveTo(k3 - ca / 2 << 0, p - ka), c2.lineTo(k3 + ca / 2 << 0, p - ka), c2.stroke(), c2.moveTo(k3 - ca / 2 << 0, u3 + ka), c2.lineTo(k3 + ca / 2 << 0, u3 + ka), c2.stroke());
                    c2.restore();
                    r && (e = V(U), b.strokeStyle = e, b.lineWidth = oa, 0 < oa && (b.moveTo(k3 - D2 - H, m), b.lineTo(k3 - D2 - H, Math.max(u3, p)), b.stroke(), b.moveTo(k3 - D2 - H, Math.min(u3, p)), b.lineTo(k3 - D2 - H, n), b.stroke()), ba(b, x3, Math.max(m, n), E, Math.min(m, n), e, 0, null, false, false, false, false), 0 < W && (b.beginPath(), b.lineWidth = W, b.moveTo(k3 + ca / 2, p - ka), b.lineTo(k3 - ca / 2, p - ka), b.stroke(), b.moveTo(k3 + ca / 2, u3 + ka), b.lineTo(k3 - ca / 2, u3 + ka), b.stroke()));
                    (y2[d3].indexLabel || G.indexLabel || y2[d3].indexLabelFormatter || G.indexLabelFormatter) && this._indexLabels.push({ chartType: G.type, dataPoint: y2[d3], dataSeries: G, point: { x: x3 + (E - x3) / 2, y: a.axisY.reversed ? u3 : p }, direction: 1, bounds: { x1: x3, y1: Math.min(u3, p), x2: E, y2: Math.max(u3, p) }, color: e });
                  }
              }
            }
            r && (h2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c2.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), c2.clearRect(l2.x1, l2.y1, l2.width, l2.height), b.restore());
            c2.restore();
            return { source: h2, dest: this.plotArea.ctx, animationCallback: s.fadeInAnimation, easingFunction: s.easing.easeInQuad, animationBase: 0 };
          }
        };
        w.prototype.renderRangeColumn = function(a) {
          var h2 = a.targetCanvasCtx || this.plotArea.ctx, c2 = r ? this._preRenderCtx : h2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = null, e = this.plotArea, l2 = 0, d3, k3, u3, l2 = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
            d3 = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.03 * this.width;
            var m = a.axisX.dataInfo.minDiff;
            isFinite(m) || (m = 0.3 * Math.abs(a.axisX.range));
            m = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(m) / Math.log(a.axisX.range) : Math.abs(m) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && l2 > d3 && (l2 = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, d3));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && d3 < l2) && (d3 = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, l2));
            m < l2 && (m = l2);
            m > d3 && (m = d3);
            c2.save();
            r && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (var n = 0; n < a.dataSeriesIndexes.length; n++) {
              var p = a.dataSeriesIndexes[n], q = this.data[p], g = q.dataPoints;
              if (0 < g.length) {
                for (var z = 5 < m && q.bevelEnabled ? true : false, l2 = 0; l2 < g.length; l2++)
                  if (g[l2].getTime ? u3 = g[l2].x.getTime() : u3 = g[l2].x, !(u3 < a.axisX.dataInfo.viewPortMin || u3 > a.axisX.dataInfo.viewPortMax) && !f2(g[l2].y) && g[l2].y.length && "number" === typeof g[l2].y[0] && "number" === typeof g[l2].y[1]) {
                    b = a.axisX.convertValueToPixel(u3);
                    d3 = a.axisY.convertValueToPixel(g[l2].y[0]);
                    k3 = a.axisY.convertValueToPixel(g[l2].y[1]);
                    var v2 = a.axisX.reversed ? b + a.plotType.totalDataSeries * m / 2 - (a.previousDataSeriesCount + n) * m << 0 : b - a.plotType.totalDataSeries * m / 2 + (a.previousDataSeriesCount + n) * m << 0, B = a.axisX.reversed ? v2 - m << 0 : v2 + m << 0, b = g[l2].color ? g[l2].color : q._colorSet[l2 % q._colorSet.length];
                    if (d3 > k3) {
                      var t = d3;
                      d3 = k3;
                      k3 = t;
                    }
                    t = q.dataPointIds[l2];
                    this._eventManager.objectMap[t] = { id: t, objectType: "dataPoint", dataSeriesIndex: p, dataPointIndex: l2, x1: v2, y1: d3, x2: B, y2: k3 };
                    ba(c2, a.axisX.reversed ? B : v2, d3, a.axisX.reversed ? v2 : B, k3, b, 0, b, z, z, false, false, q.fillOpacity);
                    b = V(t);
                    r && ba(this._eventManager.ghostCtx, a.axisX.reversed ? B : v2, d3, a.axisX.reversed ? v2 : B, k3, b, 0, null, false, false, false, false);
                    if (g[l2].indexLabel || q.indexLabel || g[l2].indexLabelFormatter || q.indexLabelFormatter)
                      this._indexLabels.push({ chartType: "rangeColumn", dataPoint: g[l2], dataSeries: q, indexKeyword: 0, point: { x: v2 + (B - v2) / 2, y: g[l2].y[1] >= g[l2].y[0] ? k3 : d3 }, direction: g[l2].y[1] >= g[l2].y[0] ? -1 : 1, bounds: { x1: v2, y1: Math.min(d3, k3), x2: B, y2: Math.max(d3, k3) }, color: b }), this._indexLabels.push({ chartType: "rangeColumn", dataPoint: g[l2], dataSeries: q, indexKeyword: 1, point: { x: v2 + (B - v2) / 2, y: g[l2].y[1] >= g[l2].y[0] ? d3 : k3 }, direction: g[l2].y[1] >= g[l2].y[0] ? 1 : -1, bounds: { x1: v2, y1: Math.min(d3, k3), x2: B, y2: Math.max(d3, k3) }, color: b });
                  }
              }
            }
            r && (h2.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), c2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c2.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return {
              source: h2,
              dest: this.plotArea.ctx,
              animationCallback: s.fadeInAnimation,
              easingFunction: s.easing.easeInQuad,
              animationBase: 0
            };
          }
        };
        w.prototype.renderError = function(a) {
          var h2 = a.targetCanvasCtx || this.plotArea.ctx, c2 = r ? this._preRenderCtx : h2, b = a.axisY._position ? "left" === a.axisY._position || "right" === a.axisY._position ? false : true : false;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = null, l2 = false, d3 = this.plotArea, k3 = 0, u3, m, n, p, q, g, z, v2 = a.axisX.dataInfo.minDiff;
            isFinite(v2) || (v2 = 0.3 * Math.abs(a.axisX.range));
            c2.save();
            r && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(d3.x1, d3.y1, d3.width, d3.height);
            c2.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(d3.x1, d3.y1, d3.width, d3.height), this._eventManager.ghostCtx.clip());
            for (var B = 0, t = 0; t < this.data.length; t++)
              !this.data[t].type.match(/(bar|column)/ig) || !this.data[t].visible || this.data[t].type.match(/(stacked)/ig) && B || B++;
            for (var G = 0; G < a.dataSeriesIndexes.length; G++) {
              var y2 = a.dataSeriesIndexes[G], w2 = this.data[y2], x3 = w2.dataPoints, E = f2(w2._linkedSeries) ? false : w2._linkedSeries.type.match(/(bar|column)/ig) && w2._linkedSeries.visible ? true : false, A2 = 0;
              if (E)
                for (e = w2._linkedSeries.id, t = 0; t < e; t++)
                  !this.data[t].type.match(/(bar|column)/ig) || !this.data[t].visible || this.data[t].type.match(/(stacked)/ig) && A2 || (this.data[t].type.match(/(range)/ig) && (l2 = true), A2++);
              e = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
              k3 = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : b ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (E ? B : 1))) << 0 : 0.3 * this.width;
              l2 && (k3 = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : b ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (E ? B : 1))) << 0 : 0.03 * this.width);
              t = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * ((b ? d3.height : d3.width) * (a.axisX.logarithmic ? Math.log(v2) / Math.log(a.axisX.range) : Math.abs(v2) / Math.abs(a.axisX.range)) / (E ? B : 1)) << 0;
              this.dataPointMaxWidth && e > k3 && (e = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, k3));
              !this.dataPointMaxWidth && (this.dataPointMinWidth && k3 < e) && (k3 = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, e));
              t < e && (t = e);
              t > k3 && (t = k3);
              if (0 < x3.length)
                for (var D2 = w2._colorSet, k3 = 0; k3 < x3.length; k3++) {
                  var e = w2.lineColor = w2.options.color ? w2.options.color : D2[0], Y = {
                    color: x3[k3].whiskerColor ? x3[k3].whiskerColor : x3[k3].color ? w2.whiskerColor ? w2.whiskerColor : x3[k3].color : w2.whiskerColor ? w2.whiskerColor : e,
                    thickness: f2(x3[k3].whiskerThickness) ? w2.whiskerThickness : x3[k3].whiskerThickness,
                    dashType: x3[k3].whiskerDashType ? x3[k3].whiskerDashType : w2.whiskerDashType,
                    length: f2(x3[k3].whiskerLength) ? f2(w2.options.whiskerLength) ? t : w2.options.whiskerLength : x3[k3].whiskerLength,
                    trimLength: f2(x3[k3].whiskerLength) ? f2(w2.options.whiskerLength) ? 50 : 0 : 0
                  };
                  Y.length = "number" === typeof Y.length ? 0 >= Y.length ? 0 : Y.length >= t ? t : Y.length : "string" === typeof Y.length ? parseInt(Y.length) * t / 100 > t ? t : parseInt(Y.length) * t / 100 > t : t;
                  Y.thickness = "number" === typeof Y.thickness ? 0 > Y.thickness ? 0 : Math.round(Y.thickness) : 2;
                  var W = { color: x3[k3].stemColor ? x3[k3].stemColor : x3[k3].color ? w2.stemColor ? w2.stemColor : x3[k3].color : w2.stemColor ? w2.stemColor : e, thickness: x3[k3].stemThickness ? x3[k3].stemThickness : w2.stemThickness, dashType: x3[k3].stemDashType ? x3[k3].stemDashType : w2.stemDashType };
                  W.thickness = "number" === typeof W.thickness ? 0 > W.thickness ? 0 : Math.round(W.thickness) : 2;
                  x3[k3].getTime ? z = x3[k3].x.getTime() : z = x3[k3].x;
                  if (!(z < a.axisX.dataInfo.viewPortMin || z > a.axisX.dataInfo.viewPortMax) && !f2(x3[k3].y) && x3[k3].y.length && "number" === typeof x3[k3].y[0] && "number" === typeof x3[k3].y[1]) {
                    var fa = a.axisX.convertValueToPixel(z);
                    b ? m = fa : u3 = fa;
                    fa = a.axisY.convertValueToPixel(x3[k3].y[0]);
                    b ? n = fa : q = fa;
                    fa = a.axisY.convertValueToPixel(x3[k3].y[1]);
                    b ? p = fa : g = fa;
                    b ? (q = a.axisX.reversed ? m + (E ? B : 1) * t / 2 - (E ? A2 - 1 : 0) * t << 0 : m - (E ? B : 1) * t / 2 + (E ? A2 - 1 : 0) * t << 0, g = a.axisX.reversed ? q - t << 0 : q + t << 0) : (n = a.axisX.reversed ? u3 + (E ? B : 1) * t / 2 - (E ? A2 - 1 : 0) * t << 0 : u3 - (E ? B : 1) * t / 2 + (E ? A2 - 1 : 0) * t << 0, p = a.axisX.reversed ? n - t << 0 : n + t << 0);
                    !b && q > g && (fa = q, q = g, g = fa);
                    b && n > p && (fa = n, n = p, p = fa);
                    fa = w2.dataPointIds[k3];
                    this._eventManager.objectMap[fa] = { id: fa, objectType: "dataPoint", dataSeriesIndex: y2, dataPointIndex: k3, x1: Math.min(n, p), y1: Math.min(q, g), x2: Math.max(p, n), y2: Math.max(g, q), isXYSwapped: b, stemProperties: W, whiskerProperties: Y };
                    F2(
                      c2,
                      Math.min(n, p),
                      Math.min(q, g),
                      Math.max(p, n),
                      Math.max(g, q),
                      e,
                      Y,
                      W,
                      b
                    );
                    r && F2(this._eventManager.ghostCtx, n, q, p, g, e, Y, W, b);
                    if (x3[k3].indexLabel || w2.indexLabel || x3[k3].indexLabelFormatter || w2.indexLabelFormatter)
                      this._indexLabels.push({ chartType: "error", dataPoint: x3[k3], dataSeries: w2, indexKeyword: 0, point: { x: b ? x3[k3].y[1] >= x3[k3].y[0] ? n : p : n + (p - n) / 2, y: b ? q + (g - q) / 2 : x3[k3].y[1] >= x3[k3].y[0] ? g : q }, direction: x3[k3].y[1] >= x3[k3].y[0] ? -1 : 1, bounds: { x1: b ? Math.min(n, p) : n, y1: b ? q : Math.min(q, g), x2: b ? Math.max(n, p) : p, y2: b ? g : Math.max(q, g) }, color: e, axisSwapped: b }), this._indexLabels.push({ chartType: "error", dataPoint: x3[k3], dataSeries: w2, indexKeyword: 1, point: { x: b ? x3[k3].y[1] >= x3[k3].y[0] ? p : n : n + (p - n) / 2, y: b ? q + (g - q) / 2 : x3[k3].y[1] >= x3[k3].y[0] ? q : g }, direction: x3[k3].y[1] >= x3[k3].y[0] ? 1 : -1, bounds: { x1: b ? Math.min(n, p) : n, y1: b ? q : Math.min(q, g), x2: b ? Math.max(n, p) : p, y2: b ? g : Math.max(q, g) }, color: e, axisSwapped: b });
                  }
                }
            }
            r && (h2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c2.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(d3.x1, d3.y1, d3.width, d3.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: h2, dest: this.plotArea.ctx, animationCallback: s.fadeInAnimation, easingFunction: s.easing.easeInQuad, animationBase: 0 };
          }
        };
        w.prototype.renderRangeBar = function(a) {
          var h2 = a.targetCanvasCtx || this.plotArea.ctx, c2 = r ? this._preRenderCtx : h2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = null, e = this.plotArea, l2 = 0, d3, k3, u3, m, l2 = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
            d3 = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0;
            var n = a.axisX.dataInfo.minDiff;
            isFinite(n) || (n = 0.3 * Math.abs(a.axisX.range));
            n = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(n) / Math.log(a.axisX.range) : Math.abs(n) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && l2 > d3 && (l2 = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, d3));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && d3 < l2) && (d3 = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, l2));
            n < l2 && (n = l2);
            n > d3 && (n = d3);
            c2.save();
            r && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (var p = 0; p < a.dataSeriesIndexes.length; p++) {
              var q = a.dataSeriesIndexes[p], g = this.data[q], z = g.dataPoints;
              if (0 < z.length) {
                var v2 = 5 < n && g.bevelEnabled ? true : false;
                c2.strokeStyle = "#4572A7 ";
                for (l2 = 0; l2 < z.length; l2++)
                  if (z[l2].getTime ? m = z[l2].x.getTime() : m = z[l2].x, !(m < a.axisX.dataInfo.viewPortMin || m > a.axisX.dataInfo.viewPortMax) && !f2(z[l2].y) && z[l2].y.length && "number" === typeof z[l2].y[0] && "number" === typeof z[l2].y[1]) {
                    d3 = a.axisY.convertValueToPixel(z[l2].y[0]);
                    k3 = a.axisY.convertValueToPixel(z[l2].y[1]);
                    u3 = a.axisX.convertValueToPixel(m);
                    u3 = a.axisX.reversed ? u3 + a.plotType.totalDataSeries * n / 2 - (a.previousDataSeriesCount + p) * n << 0 : u3 - a.plotType.totalDataSeries * n / 2 + (a.previousDataSeriesCount + p) * n << 0;
                    var B = a.axisX.reversed ? u3 - n << 0 : u3 + n << 0;
                    d3 > k3 && (b = d3, d3 = k3, k3 = b);
                    b = z[l2].color ? z[l2].color : g._colorSet[l2 % g._colorSet.length];
                    ba(c2, d3, a.axisX.reversed ? B : u3, k3, a.axisX.reversed ? u3 : B, b, 0, null, v2, false, false, false, g.fillOpacity);
                    b = g.dataPointIds[l2];
                    this._eventManager.objectMap[b] = {
                      id: b,
                      objectType: "dataPoint",
                      dataSeriesIndex: q,
                      dataPointIndex: l2,
                      x1: d3,
                      y1: u3,
                      x2: k3,
                      y2: B
                    };
                    b = V(b);
                    r && ba(this._eventManager.ghostCtx, d3, a.axisX.reversed ? B : u3, k3, a.axisX.reversed ? u3 : B, b, 0, null, false, false, false, false);
                    if (z[l2].indexLabel || g.indexLabel || z[l2].indexLabelFormatter || g.indexLabelFormatter)
                      this._indexLabels.push({ chartType: "rangeBar", dataPoint: z[l2], dataSeries: g, indexKeyword: 0, point: { x: z[l2].y[1] >= z[l2].y[0] ? d3 : k3, y: u3 + (B - u3) / 2 }, direction: z[l2].y[1] >= z[l2].y[0] ? -1 : 1, bounds: { x1: Math.min(d3, k3), y1: u3, x2: Math.max(d3, k3), y2: B }, color: b }), this._indexLabels.push({
                        chartType: "rangeBar",
                        dataPoint: z[l2],
                        dataSeries: g,
                        indexKeyword: 1,
                        point: { x: z[l2].y[1] >= z[l2].y[0] ? k3 : d3, y: u3 + (B - u3) / 2 },
                        direction: z[l2].y[1] >= z[l2].y[0] ? 1 : -1,
                        bounds: { x1: Math.min(d3, k3), y1: u3, x2: Math.max(d3, k3), y2: B },
                        color: b
                      });
                  }
              }
            }
            r && (h2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c2.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), c2.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: h2, dest: this.plotArea.ctx, animationCallback: s.fadeInAnimation, easingFunction: s.easing.easeInQuad, animationBase: 0 };
          }
        };
        w.prototype.renderRangeArea = function(a) {
          function h2() {
            if (w2) {
              for (var a2 = null, c3 = k3.length - 1; 0 <= c3; c3--)
                a2 = k3[c3], b.lineTo(a2.x, a2.y2), e.lineTo(a2.x, a2.y2);
              b.closePath();
              b.globalAlpha = n.fillOpacity;
              b.fill();
              b.globalAlpha = 1;
              e.fill();
              if (0 < n.lineThickness) {
                b.beginPath();
                b.moveTo(a2.x, a2.y2);
                for (c3 = 0; c3 < k3.length; c3++)
                  a2 = k3[c3], b.lineTo(a2.x, a2.y2);
                b.moveTo(k3[0].x, k3[0].y1);
                for (c3 = 0; c3 < k3.length; c3++)
                  a2 = k3[c3], b.lineTo(a2.x, a2.y1);
                b.stroke();
              }
              b.beginPath();
              b.moveTo(z, u3);
              e.beginPath();
              e.moveTo(z, u3);
              w2 = { x: z, y: u3 };
              k3 = [];
              k3.push({ x: z, y1: u3, y2: B });
            }
          }
          var c2 = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : c2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = this._eventManager.ghostCtx, l2 = [], f3 = this.plotArea;
            b.save();
            r && e.save();
            b.beginPath();
            b.rect(f3.x1, f3.y1, f3.width, f3.height);
            b.clip();
            r && (e.beginPath(), e.rect(f3.x1, f3.y1, f3.width, f3.height), e.clip());
            for (var d3 = 0; d3 < a.dataSeriesIndexes.length; d3++) {
              var k3 = [], m = a.dataSeriesIndexes[d3], n = this.data[m], p = n.dataPoints, l2 = n.id;
              this._eventManager.objectMap[l2] = { objectType: "dataSeries", dataSeriesIndex: m };
              l2 = V(l2);
              e.fillStyle = l2;
              var l2 = [], q = true, g = 0, z, u3, B, t, w2 = null;
              if (0 < p.length) {
                var y2 = n._colorSet[g % n._colorSet.length], x3 = n.lineColor = n.options.lineColor || y2, A2 = x3;
                b.fillStyle = y2;
                b.strokeStyle = x3;
                b.lineWidth = n.lineThickness;
                var E = "solid";
                if (b.setLineDash) {
                  var D2 = R(
                    n.nullDataLineDashType,
                    n.lineThickness
                  ), E = n.lineDashType, K = R(E, n.lineThickness);
                  b.setLineDash(K);
                }
                for (var Y = true; g < p.length; g++)
                  if (t = p[g].x.getTime ? p[g].x.getTime() : p[g].x, !(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax && (!n.connectNullData || !Y)))
                    if (null !== p[g].y && p[g].y.length && "number" === typeof p[g].y[0] && "number" === typeof p[g].y[1]) {
                      z = a.axisX.convertValueToPixel(t);
                      u3 = a.axisY.convertValueToPixel(p[g].y[0]);
                      B = a.axisY.convertValueToPixel(p[g].y[1]);
                      q || Y ? (n.connectNullData && !q ? (b.setLineDash && (n.options.nullDataLineDashType || E === n.lineDashType && n.lineDashType !== n.nullDataLineDashType) && (k3[k3.length - 1].newLineDashArray = K, E = n.nullDataLineDashType, b.setLineDash(D2)), b.lineTo(z, u3), r && e.lineTo(z, u3), k3.push({ x: z, y1: u3, y2: B })) : (b.beginPath(), b.moveTo(z, u3), w2 = { x: z, y: u3 }, k3 = [], k3.push({ x: z, y1: u3, y2: B }), r && (e.beginPath(), e.moveTo(z, u3))), Y = q = false) : (b.lineTo(z, u3), k3.push({ x: z, y1: u3, y2: B }), r && e.lineTo(z, u3), 0 == g % 250 && h2());
                      t = n.dataPointIds[g];
                      this._eventManager.objectMap[t] = {
                        id: t,
                        objectType: "dataPoint",
                        dataSeriesIndex: m,
                        dataPointIndex: g,
                        x1: z,
                        y1: u3,
                        y2: B
                      };
                      g < p.length - 1 && (A2 !== (p[g].lineColor || x3) || E !== (p[g].lineDashType || n.lineDashType)) && (h2(), A2 = p[g].lineColor || x3, k3[k3.length - 1].newStrokeStyle = A2, b.strokeStyle = A2, b.setLineDash && (p[g].lineDashType ? (E = p[g].lineDashType, k3[k3.length - 1].newLineDashArray = R(E, n.lineThickness), b.setLineDash(k3[k3.length - 1].newLineDashArray)) : (E = n.lineDashType, k3[k3.length - 1].newLineDashArray = K, b.setLineDash(K))));
                      if (0 !== p[g].markerSize && (0 < p[g].markerSize || 0 < n.markerSize)) {
                        var W = n.getMarkerProperties(g, z, B, b);
                        l2.push(W);
                        var fa = V(t);
                        r && l2.push({ x: z, y: B, ctx: e, type: W.type, size: W.size, color: fa, borderColor: fa, borderThickness: W.borderThickness });
                        W = n.getMarkerProperties(g, z, u3, b);
                        l2.push(W);
                        fa = V(t);
                        r && l2.push({ x: z, y: u3, ctx: e, type: W.type, size: W.size, color: fa, borderColor: fa, borderThickness: W.borderThickness });
                      }
                      if (p[g].indexLabel || n.indexLabel || p[g].indexLabelFormatter || n.indexLabelFormatter)
                        this._indexLabels.push({ chartType: "rangeArea", dataPoint: p[g], dataSeries: n, indexKeyword: 0, point: { x: z, y: u3 }, direction: p[g].y[0] > p[g].y[1] === a.axisY.reversed ? -1 : 1, color: y2 }), this._indexLabels.push({ chartType: "rangeArea", dataPoint: p[g], dataSeries: n, indexKeyword: 1, point: { x: z, y: B }, direction: p[g].y[0] > p[g].y[1] === a.axisY.reversed ? 1 : -1, color: y2 });
                    } else
                      Y || q || h2(), Y = true;
                h2();
                v.drawMarkers(l2);
              }
            }
            r && (c2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(f3.x1, f3.y1, f3.width, f3.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: c2, dest: this.plotArea.ctx, animationCallback: s.xClipAnimation, easingFunction: s.easing.linear, animationBase: 0 };
          }
        };
        w.prototype.renderRangeSplineArea = function(a) {
          function h2(a2, c3) {
            var h3 = x2(w2, 2);
            if (0 < h3.length) {
              if (0 < m.lineThickness) {
                b.strokeStyle = c3;
                b.setLineDash && b.setLineDash(a2);
                b.beginPath();
                b.moveTo(h3[0].x, h3[0].y);
                for (var g2 = 0; g2 < h3.length - 3; g2 += 3) {
                  if (h3[g2].newStrokeStyle || h3[g2].newLineDashArray)
                    b.stroke(), b.beginPath(), b.moveTo(h3[g2].x, h3[g2].y), h3[g2].newStrokeStyle && (b.strokeStyle = h3[g2].newStrokeStyle), h3[g2].newLineDashArray && b.setLineDash(h3[g2].newLineDashArray);
                  b.bezierCurveTo(h3[g2 + 1].x, h3[g2 + 1].y, h3[g2 + 2].x, h3[g2 + 2].y, h3[g2 + 3].x, h3[g2 + 3].y);
                }
              }
              b.beginPath();
              b.moveTo(h3[0].x, h3[0].y);
              r && (e.beginPath(), e.moveTo(h3[0].x, h3[0].y));
              for (g2 = 0; g2 < h3.length - 3; g2 += 3)
                b.bezierCurveTo(h3[g2 + 1].x, h3[g2 + 1].y, h3[g2 + 2].x, h3[g2 + 2].y, h3[g2 + 3].x, h3[g2 + 3].y), r && e.bezierCurveTo(h3[g2 + 1].x, h3[g2 + 1].y, h3[g2 + 2].x, h3[g2 + 2].y, h3[g2 + 3].x, h3[g2 + 3].y);
              h3 = x2(B, 2);
              b.lineTo(B[B.length - 1].x, B[B.length - 1].y);
              for (g2 = h3.length - 1; 2 < g2; g2 -= 3)
                b.bezierCurveTo(h3[g2 - 1].x, h3[g2 - 1].y, h3[g2 - 2].x, h3[g2 - 2].y, h3[g2 - 3].x, h3[g2 - 3].y), r && e.bezierCurveTo(h3[g2 - 1].x, h3[g2 - 1].y, h3[g2 - 2].x, h3[g2 - 2].y, h3[g2 - 3].x, h3[g2 - 3].y);
              b.closePath();
              b.globalAlpha = m.fillOpacity;
              b.fill();
              r && (e.closePath(), e.fill());
              b.globalAlpha = 1;
              if (0 < m.lineThickness) {
                b.strokeStyle = c3;
                b.setLineDash && b.setLineDash(a2);
                b.beginPath();
                b.moveTo(h3[0].x, h3[0].y);
                for (var l3 = g2 = 0; g2 < h3.length - 3; g2 += 3, l3++) {
                  if (w2[l3].newStrokeStyle || w2[l3].newLineDashArray)
                    b.stroke(), b.beginPath(), b.moveTo(h3[g2].x, h3[g2].y), w2[l3].newStrokeStyle && (b.strokeStyle = w2[l3].newStrokeStyle), w2[l3].newLineDashArray && b.setLineDash(w2[l3].newLineDashArray);
                  b.bezierCurveTo(h3[g2 + 1].x, h3[g2 + 1].y, h3[g2 + 2].x, h3[g2 + 2].y, h3[g2 + 3].x, h3[g2 + 3].y);
                }
                h3 = x2(w2, 2);
                b.moveTo(h3[0].x, h3[0].y);
                for (l3 = g2 = 0; g2 < h3.length - 3; g2 += 3, l3++) {
                  if (w2[l3].newStrokeStyle || w2[l3].newLineDashArray)
                    b.stroke(), b.beginPath(), b.moveTo(h3[g2].x, h3[g2].y), w2[l3].newStrokeStyle && (b.strokeStyle = w2[l3].newStrokeStyle), w2[l3].newLineDashArray && b.setLineDash(w2[l3].newLineDashArray);
                  b.bezierCurveTo(h3[g2 + 1].x, h3[g2 + 1].y, h3[g2 + 2].x, h3[g2 + 2].y, h3[g2 + 3].x, h3[g2 + 3].y);
                }
                b.stroke();
              }
              b.beginPath();
            }
          }
          var c2 = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : c2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = this._eventManager.ghostCtx, l2 = [], f3 = this.plotArea;
            b.save();
            r && e.save();
            b.beginPath();
            b.rect(f3.x1, f3.y1, f3.width, f3.height);
            b.clip();
            r && (e.beginPath(), e.rect(f3.x1, f3.y1, f3.width, f3.height), e.clip());
            for (var d3 = 0; d3 < a.dataSeriesIndexes.length; d3++) {
              var k3 = a.dataSeriesIndexes[d3], m = this.data[k3], n = m.dataPoints, l2 = m.id;
              this._eventManager.objectMap[l2] = { objectType: "dataSeries", dataSeriesIndex: k3 };
              l2 = V(l2);
              e.fillStyle = l2;
              var l2 = [], p = 0, q, g, u3, w2 = [], B = [];
              if (0 < n.length) {
                var t = m._colorSet[p % m._colorSet.length], G = m.lineColor = m.options.lineColor || t, y2 = G;
                b.fillStyle = t;
                b.lineWidth = m.lineThickness;
                var A2 = "solid", D2;
                if (b.setLineDash) {
                  var E = R(m.nullDataLineDashType, m.lineThickness), A2 = m.lineDashType;
                  D2 = R(A2, m.lineThickness);
                }
                for (g = false; p < n.length; p++)
                  if (q = n[p].x.getTime ? n[p].x.getTime() : n[p].x, !(q < a.axisX.dataInfo.viewPortMin || q > a.axisX.dataInfo.viewPortMax && (!m.connectNullData || !g)))
                    if (null !== n[p].y && n[p].y.length && "number" === typeof n[p].y[0] && "number" === typeof n[p].y[1]) {
                      q = a.axisX.convertValueToPixel(q);
                      g = a.axisY.convertValueToPixel(n[p].y[0]);
                      u3 = a.axisY.convertValueToPixel(n[p].y[1]);
                      var F3 = m.dataPointIds[p];
                      this._eventManager.objectMap[F3] = { id: F3, objectType: "dataPoint", dataSeriesIndex: k3, dataPointIndex: p, x1: q, y1: g, y2: u3 };
                      w2[w2.length] = { x: q, y: g };
                      B[B.length] = { x: q, y: u3 };
                      p < n.length - 1 && (y2 !== (n[p].lineColor || G) || A2 !== (n[p].lineDashType || m.lineDashType)) && (y2 = n[p].lineColor || G, w2[w2.length - 1].newStrokeStyle = y2, b.setLineDash && (n[p].lineDashType ? (A2 = n[p].lineDashType, w2[w2.length - 1].newLineDashArray = R(A2, m.lineThickness)) : (A2 = m.lineDashType, w2[w2.length - 1].newLineDashArray = D2)));
                      if (0 !== n[p].markerSize && (0 < n[p].markerSize || 0 < m.markerSize)) {
                        var J = m.getMarkerProperties(p, q, g, b);
                        l2.push(J);
                        var Y = V(F3);
                        r && l2.push({ x: q, y: g, ctx: e, type: J.type, size: J.size, color: Y, borderColor: Y, borderThickness: J.borderThickness });
                        J = m.getMarkerProperties(p, q, u3, b);
                        l2.push(J);
                        Y = V(F3);
                        r && l2.push({ x: q, y: u3, ctx: e, type: J.type, size: J.size, color: Y, borderColor: Y, borderThickness: J.borderThickness });
                      }
                      if (n[p].indexLabel || m.indexLabel || n[p].indexLabelFormatter || m.indexLabelFormatter)
                        this._indexLabels.push({ chartType: "rangeSplineArea", dataPoint: n[p], dataSeries: m, indexKeyword: 0, point: { x: q, y: g }, direction: n[p].y[0] <= n[p].y[1] ? -1 : 1, color: t }), this._indexLabels.push({ chartType: "rangeSplineArea", dataPoint: n[p], dataSeries: m, indexKeyword: 1, point: {
                          x: q,
                          y: u3
                        }, direction: n[p].y[0] <= n[p].y[1] ? 1 : -1, color: t });
                      g = false;
                    } else
                      0 < p && !g && (m.connectNullData ? b.setLineDash && (0 < w2.length && (m.options.nullDataLineDashType || !n[p - 1].lineDashType)) && (w2[w2.length - 1].newLineDashArray = E, A2 = m.nullDataLineDashType) : (h2(D2, G), w2 = [], B = [])), g = true;
                h2(D2, G);
                v.drawMarkers(l2);
              }
            }
            r && (c2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(
              a.axisY.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(f3.x1, f3.y1, f3.width, f3.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: c2, dest: this.plotArea.ctx, animationCallback: s.xClipAnimation, easingFunction: s.easing.linear, animationBase: 0 };
          }
        };
        w.prototype.renderWaterfall = function(a) {
          var h2 = a.targetCanvasCtx || this.plotArea.ctx, c2 = r ? this._preRenderCtx : h2;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var b = this._eventManager.ghostCtx, e = null, l2 = this.plotArea, f3 = 0, d3, k3, m, n, p = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), f3 = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
            k3 = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0;
            var q = a.axisX.dataInfo.minDiff;
            isFinite(q) || (q = 0.3 * Math.abs(a.axisX.range));
            q = this.options.dataPointWidth ? this.dataPointWidth : 0.6 * (l2.width * (a.axisX.logarithmic ? Math.log(q) / Math.log(a.axisX.range) : Math.abs(q) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && f3 > k3 && (f3 = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, k3));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && k3 < f3) && (k3 = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, f3));
            q < f3 && (q = f3);
            q > k3 && (q = k3);
            c2.save();
            r && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(l2.x1, l2.y1, l2.width, l2.height);
            c2.clip();
            r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(l2.x1, l2.y1, l2.width, l2.height), this._eventManager.ghostCtx.clip());
            for (var g = 0; g < a.dataSeriesIndexes.length; g++) {
              var u3 = a.dataSeriesIndexes[g], v2 = this.data[u3], B = v2.dataPoints, e = v2._colorSet[0];
              v2.risingColor = v2.options.risingColor ? v2.options.risingColor : e;
              v2.fallingColor = v2.options.fallingColor ? v2.options.fallingColor : "#e40a0a";
              var t = "number" === typeof v2.options.lineThickness ? Math.round(v2.lineThickness) : 1, w2 = 1 === Math.round(t) % 2 ? -0.5 : 0;
              if (0 < B.length)
                for (var y2 = 5 < q && v2.bevelEnabled ? true : false, x3 = false, A2 = null, E = null, f3 = 0; f3 < B.length; f3++)
                  if (B[f3].getTime ? n = B[f3].x.getTime() : n = B[f3].x, "number" !== typeof B[f3].y) {
                    if (0 < f3 && !x3 && v2.connectNullData)
                      var D2 = v2.options.nullDataLineDashType || !B[f3 - 1].lineDashType ? v2.nullDataLineDashType : B[f3 - 1].lineDashType;
                    x3 = true;
                  } else {
                    d3 = a.axisX.convertValueToPixel(n);
                    k3 = 0 === v2.dataPointEOs[f3].cumulativeSum ? p : a.axisY.convertValueToPixel(v2.dataPointEOs[f3].cumulativeSum);
                    m = 0 === v2.dataPointEOs[f3].cumulativeSumYStartValue ? p : a.axisY.convertValueToPixel(v2.dataPointEOs[f3].cumulativeSumYStartValue);
                    d3 = a.axisX.reversed ? d3 + a.plotType.totalDataSeries * q / 2 - (a.previousDataSeriesCount + g) * q << 0 : d3 - a.plotType.totalDataSeries * q / 2 + (a.previousDataSeriesCount + g) * q << 0;
                    var K = a.axisX.reversed ? d3 - q << 0 : d3 + q << 0;
                    k3 > m && (e = k3, k3 = m, m = e);
                    a.axisY.reversed && (e = k3, k3 = m, m = e);
                    e = v2.dataPointIds[f3];
                    this._eventManager.objectMap[e] = { id: e, objectType: "dataPoint", dataSeriesIndex: u3, dataPointIndex: f3, x1: d3, y1: k3, x2: K, y2: m };
                    var Y = B[f3].color ? B[f3].color : 0 < B[f3].y ? v2.risingColor : v2.fallingColor;
                    ba(c2, a.axisX.reversed ? K : d3, a.axisY.reversed ? m : k3, a.axisX.reversed ? d3 : K, a.axisY.reversed ? k3 : m, Y, 0, Y, y2, y2, false, false, v2.fillOpacity);
                    e = V(e);
                    r && ba(this._eventManager.ghostCtx, a.axisX.reversed ? K : d3, k3, a.axisX.reversed ? d3 : K, m, e, 0, null, false, false, false, false);
                    var W, Y = d3;
                    W = "undefined" !== typeof B[f3].isIntermediateSum && true === B[f3].isIntermediateSum || "undefined" !== typeof B[f3].isCumulativeSum && true === B[f3].isCumulativeSum ? 0 < B[f3].y ? k3 : m : 0 < B[f3].y ? m : k3;
                    0 < f3 && A2 && (!x3 || v2.connectNullData) && (x3 && c2.setLineDash && c2.setLineDash(R(D2, t)), c2.beginPath(), c2.moveTo(A2, E - w2), c2.lineTo(Y, W - w2), 0 < t && c2.stroke(), r && (b.beginPath(), b.moveTo(
                      A2,
                      E - w2
                    ), b.lineTo(Y, W - w2), 0 < t && b.stroke()));
                    x3 = false;
                    A2 = K;
                    E = 0 < B[f3].y ? k3 : m;
                    Y = B[f3].lineDashType ? B[f3].lineDashType : v2.options.lineDashType ? v2.options.lineDashType : "shortDash";
                    c2.strokeStyle = B[f3].lineColor ? B[f3].lineColor : v2.options.lineColor ? v2.options.lineColor : "#9e9e9e";
                    c2.lineWidth = t;
                    c2.setLineDash && (Y = R(Y, t), c2.setLineDash(Y));
                    (B[f3].indexLabel || v2.indexLabel || B[f3].indexLabelFormatter || v2.indexLabelFormatter) && this._indexLabels.push({
                      chartType: "waterfall",
                      dataPoint: B[f3],
                      dataSeries: v2,
                      point: { x: d3 + (K - d3) / 2, y: 0 <= B[f3].y ? k3 : m },
                      direction: 0 > B[f3].y === a.axisY.reversed ? 1 : -1,
                      bounds: { x1: d3, y1: Math.min(k3, m), x2: K, y2: Math.max(k3, m) },
                      color: e
                    });
                  }
            }
            r && (h2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c2.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c2.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(
              l2.x1,
              l2.y1,
              l2.width,
              l2.height
            ), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: h2, dest: this.plotArea.ctx, animationCallback: s.fadeInAnimation, easingFunction: s.easing.easeInQuad, animationBase: 0 };
          }
        };
        var d2 = function(a, h2, c2, b, e, l2, f3, d3, k3) {
          if (!(0 > c2)) {
            "undefined" === typeof d3 && (d3 = 1);
            if (!r) {
              var m = Number((f3 % (2 * Math.PI)).toFixed(8));
              Number((l2 % (2 * Math.PI)).toFixed(8)) === m && (f3 -= 1e-4);
            }
            a.save();
            a.globalAlpha = d3;
            "pie" === e ? (a.beginPath(), a.moveTo(h2.x, h2.y), a.arc(h2.x, h2.y, c2, l2, f3, false), a.fillStyle = b, a.strokeStyle = "white", a.lineWidth = 2, a.closePath(), a.fill()) : "doughnut" === e && (a.beginPath(), a.arc(h2.x, h2.y, c2, l2, f3, false), 0 <= k3 && a.arc(h2.x, h2.y, k3 * c2, f3, l2, true), a.closePath(), a.fillStyle = b, a.strokeStyle = "white", a.lineWidth = 2, a.fill());
            a.globalAlpha = 1;
            a.restore();
          }
        };
        w.prototype.renderPie = function(a) {
          function h2() {
            if (m && n) {
              var a2 = 0, b2 = 0, c3 = 0, h3 = 0;
              f2(m.options.indexLabelMaxWidth) && (m.indexLabelMaxWidth = 0.33 * q.width);
              for (var e2 = 0; e2 < n.length; e2++) {
                var l3 = n[e2], d3 = m.dataPointIds[e2];
                g[e2].id = d3;
                g[e2].objectType = "dataPoint";
                g[e2].dataPointIndex = e2;
                g[e2].dataSeriesIndex = 0;
                var p2 = g[e2], k4 = { percent: null, total: null }, C2 = null, k4 = u3.getPercentAndTotal(m, l3);
                if (m.indexLabelFormatter || l3.indexLabelFormatter)
                  C2 = { chart: u3.options, dataSeries: m, dataPoint: l3, total: k4.total, percent: k4.percent };
                k4 = l3.indexLabelFormatter ? l3.indexLabelFormatter(C2) : l3.indexLabel ? u3.replaceKeywordsWithValue(l3.indexLabel, l3, m, e2) : m.indexLabelFormatter ? m.indexLabelFormatter(C2) : m.indexLabel ? u3.replaceKeywordsWithValue(m.indexLabel, l3, m, e2) : l3.label ? l3.label : "";
                u3._eventManager.objectMap[d3] = p2;
                p2.center = { x: y2.x, y: y2.y };
                p2.y = l3.y;
                p2.radius = E;
                p2.percentInnerRadius = K;
                p2.indexLabelText = k4;
                p2.indexLabelPlacement = m.indexLabelPlacement;
                p2.indexLabelLineColor = l3.indexLabelLineColor ? l3.indexLabelLineColor : m.options.indexLabelLineColor ? m.options.indexLabelLineColor : l3.color ? l3.color : m._colorSet[e2 % m._colorSet.length];
                p2.indexLabelLineThickness = f2(l3.indexLabelLineThickness) ? m.indexLabelLineThickness : l3.indexLabelLineThickness;
                p2.indexLabelLineDashType = l3.indexLabelLineDashType ? l3.indexLabelLineDashType : m.indexLabelLineDashType;
                p2.indexLabelFontColor = l3.indexLabelFontColor ? l3.indexLabelFontColor : m.indexLabelFontColor;
                p2.indexLabelFontStyle = l3.indexLabelFontStyle ? l3.indexLabelFontStyle : m.indexLabelFontStyle;
                p2.indexLabelFontWeight = l3.indexLabelFontWeight ? l3.indexLabelFontWeight : m.indexLabelFontWeight;
                p2.indexLabelFontSize = f2(l3.indexLabelFontSize) ? m.indexLabelFontSize : l3.indexLabelFontSize;
                p2.indexLabelFontFamily = l3.indexLabelFontFamily ? l3.indexLabelFontFamily : m.indexLabelFontFamily;
                p2.indexLabelBackgroundColor = l3.indexLabelBackgroundColor ? l3.indexLabelBackgroundColor : m.options.indexLabelBackgroundColor ? m.options.indexLabelBackgroundColor : m.indexLabelBackgroundColor;
                p2.indexLabelMaxWidth = l3.indexLabelMaxWidth ? l3.indexLabelMaxWidth : m.indexLabelMaxWidth;
                p2.indexLabelWrap = "undefined" !== typeof l3.indexLabelWrap ? l3.indexLabelWrap : m.indexLabelWrap;
                p2.indexLabelTextAlign = l3.indexLabelTextAlign ? l3.indexLabelTextAlign : m.indexLabelTextAlign ? m.indexLabelTextAlign : "left";
                p2.startAngle = 0 === e2 ? m.startAngle ? m.startAngle / 180 * Math.PI : 0 : g[e2 - 1].endAngle;
                p2.startAngle = (p2.startAngle + 2 * Math.PI) % (2 * Math.PI);
                p2.endAngle = p2.startAngle + 2 * Math.PI / x3 * Math.abs(l3.y);
                l3 = (p2.endAngle + p2.startAngle) / 2;
                l3 = (l3 + 2 * Math.PI) % (2 * Math.PI);
                p2.midAngle = l3;
                if (p2.midAngle > Math.PI / 2 - t && p2.midAngle < Math.PI / 2 + t) {
                  if (0 === a2 || g[c3].midAngle > p2.midAngle)
                    c3 = e2;
                  a2++;
                } else if (p2.midAngle > 3 * Math.PI / 2 - t && p2.midAngle < 3 * Math.PI / 2 + t) {
                  if (0 === b2 || g[h3].midAngle > p2.midAngle)
                    h3 = e2;
                  b2++;
                }
                p2.hemisphere = l3 > Math.PI / 2 && l3 <= 3 * Math.PI / 2 ? "left" : "right";
                p2.indexLabelTextBlock = new ma(u3.plotArea.ctx, {
                  fontSize: p2.indexLabelFontSize,
                  fontFamily: p2.indexLabelFontFamily,
                  fontColor: p2.indexLabelFontColor,
                  fontStyle: p2.indexLabelFontStyle,
                  fontWeight: p2.indexLabelFontWeight,
                  textAlign: p2.indexLabelTextAlign,
                  backgroundColor: p2.indexLabelBackgroundColor,
                  maxWidth: p2.indexLabelMaxWidth,
                  maxHeight: p2.indexLabelWrap ? 5 * p2.indexLabelFontSize : 1.5 * p2.indexLabelFontSize,
                  text: p2.indexLabelText,
                  padding: 0,
                  textBaseline: "middle"
                });
                p2.indexLabelTextBlock.measureText();
              }
              d3 = l3 = 0;
              k4 = false;
              for (e2 = 0; e2 < n.length; e2++)
                p2 = g[(c3 + e2) % n.length], 1 < a2 && (p2.midAngle > Math.PI / 2 - t && p2.midAngle < Math.PI / 2 + t) && (l3 <= a2 / 2 && !k4 ? (p2.hemisphere = "right", l3++) : (p2.hemisphere = "left", k4 = true));
              k4 = false;
              for (e2 = 0; e2 < n.length; e2++)
                p2 = g[(h3 + e2) % n.length], 1 < b2 && (p2.midAngle > 3 * Math.PI / 2 - t && p2.midAngle < 3 * Math.PI / 2 + t) && (d3 <= b2 / 2 && !k4 ? (p2.hemisphere = "left", d3++) : (p2.hemisphere = "right", k4 = true));
            }
          }
          function c2(a2, b2) {
            var c3 = u3.plotArea.ctx;
            c3.clearRect(q.x1, q.y1, q.width, q.height);
            c3.fillStyle = u3.backgroundColor;
            c3.fillRect(q.x1, q.y1, q.width, q.height);
            for (c3 = 0; c3 < n.length; c3++) {
              var h3 = g[c3].startAngle, e2 = g[c3].endAngle;
              if (e2 > h3) {
                var l3 = 0.07 * E * Math.cos(g[c3].midAngle), f3 = 0.07 * E * Math.sin(g[c3].midAngle), k4 = false;
                if (n[c3].exploded) {
                  if (1e-9 < Math.abs(g[c3].center.x - (y2.x + l3)) || 1e-9 < Math.abs(g[c3].center.y - (y2.y + f3)))
                    g[c3].center.x = y2.x + l3 * a2, g[c3].center.y = y2.y + f3 * a2, k4 = true;
                } else if (0 < Math.abs(g[c3].center.x - y2.x) || 0 < Math.abs(g[c3].center.y - y2.y))
                  g[c3].center.x = y2.x + l3 * (1 - a2), g[c3].center.y = y2.y + f3 * (1 - a2), k4 = true;
                k4 && b2 && (l3 = {}, l3.dataSeries = m, l3.dataPoint = m.dataPoints[c3], l3.index = c3, u3.toolTip.highlightObjects([l3]));
                d2(u3.plotArea.ctx, g[c3].center, g[c3].radius, n[c3].color ? n[c3].color : m._colorSet[c3 % m._colorSet.length], m.type, h3, e2, m.fillOpacity, g[c3].percentInnerRadius);
              }
            }
            c3 = u3.plotArea.ctx;
            c3.save();
            c3.fillStyle = "black";
            c3.strokeStyle = "grey";
            c3.textBaseline = "middle";
            c3.lineJoin = "round";
            for (h3 = h3 = 0; h3 < n.length; h3++)
              e2 = g[h3], e2.indexLabelText && (e2.indexLabelTextBlock.y -= e2.indexLabelTextBlock.height / 2 - e2.indexLabelTextBlock.fontSize / 2, l3 = 0, l3 = "left" === e2.hemisphere ? "inside" !== m.indexLabelPlacement ? -(e2.indexLabelTextBlock.width + p) : -e2.indexLabelTextBlock.width / 2 : "inside" !== m.indexLabelPlacement ? p : -e2.indexLabelTextBlock.width / 2, e2.indexLabelTextBlock.x += l3, e2.indexLabelTextBlock.render(true), e2.indexLabelTextBlock.x -= l3, e2.indexLabelTextBlock.y += e2.indexLabelTextBlock.height / 2 - e2.indexLabelTextBlock.fontSize / 2, "inside" !== e2.indexLabelPlacement && 0 < e2.indexLabelLineThickness && (l3 = e2.center.x + E * Math.cos(e2.midAngle), f3 = e2.center.y + E * Math.sin(e2.midAngle), c3.strokeStyle = e2.indexLabelLineColor, c3.lineWidth = e2.indexLabelLineThickness, c3.setLineDash && c3.setLineDash(R(e2.indexLabelLineDashType, e2.indexLabelLineThickness)), c3.beginPath(), c3.moveTo(l3, f3), c3.lineTo(e2.indexLabelTextBlock.x, e2.indexLabelTextBlock.y), c3.lineTo(e2.indexLabelTextBlock.x + ("left" === e2.hemisphere ? -p : p), e2.indexLabelTextBlock.y), c3.stroke()), c3.lineJoin = "miter");
            c3.save();
          }
          function b(a2, b2) {
            var c3 = 0, c3 = a2.indexLabelTextBlock.y - a2.indexLabelTextBlock.height / 2, h3 = a2.indexLabelTextBlock.y + a2.indexLabelTextBlock.height / 2, e2 = b2.indexLabelTextBlock.y - b2.indexLabelTextBlock.height / 2, g2 = b2.indexLabelTextBlock.y + b2.indexLabelTextBlock.height / 2;
            return c3 = b2.indexLabelTextBlock.y > a2.indexLabelTextBlock.y ? e2 - h3 : c3 - g2;
          }
          function e(a2) {
            for (var c3 = null, h3 = 1; h3 < n.length; h3++)
              if (c3 = (a2 + h3 + g.length) % g.length, g[c3].hemisphere !== g[a2].hemisphere) {
                c3 = null;
                break;
              } else if (g[c3].indexLabelText && c3 !== a2 && (0 > b(g[c3], g[a2]) || ("right" === g[a2].hemisphere ? g[c3].indexLabelTextBlock.y >= g[a2].indexLabelTextBlock.y : g[c3].indexLabelTextBlock.y <= g[a2].indexLabelTextBlock.y)))
                break;
              else
                c3 = null;
            return c3;
          }
          function l2(a2, c3, h3) {
            h3 = (h3 || 0) + 1;
            if (1e3 < h3)
              return 0;
            c3 = c3 || 0;
            var f3 = 0, d3 = y2.y - 1 * r2, m2 = y2.y + 1 * r2;
            if (0 <= a2 && a2 < n.length) {
              var p2 = g[a2];
              if (0 > c3 && p2.indexLabelTextBlock.y < d3 || 0 < c3 && p2.indexLabelTextBlock.y > m2)
                return 0;
              var q2 = 0, k4 = 0, k4 = q2 = q2 = 0;
              0 > c3 ? p2.indexLabelTextBlock.y - p2.indexLabelTextBlock.height / 2 > d3 && p2.indexLabelTextBlock.y - p2.indexLabelTextBlock.height / 2 + c3 < d3 && (c3 = -(d3 - (p2.indexLabelTextBlock.y - p2.indexLabelTextBlock.height / 2 + c3))) : p2.indexLabelTextBlock.y + p2.indexLabelTextBlock.height / 2 < d3 && p2.indexLabelTextBlock.y + p2.indexLabelTextBlock.height / 2 + c3 > m2 && (c3 = p2.indexLabelTextBlock.y + p2.indexLabelTextBlock.height / 2 + c3 - m2);
              c3 = p2.indexLabelTextBlock.y + c3;
              d3 = 0;
              d3 = "right" === p2.hemisphere ? y2.x + Math.sqrt(Math.pow(r2, 2) - Math.pow(c3 - y2.y, 2)) : y2.x - Math.sqrt(Math.pow(r2, 2) - Math.pow(c3 - y2.y, 2));
              k4 = y2.x + E * Math.cos(p2.midAngle);
              q2 = y2.y + E * Math.sin(p2.midAngle);
              q2 = Math.sqrt(Math.pow(d3 - k4, 2) + Math.pow(c3 - q2, 2));
              k4 = Math.acos(E / r2);
              q2 = Math.acos((r2 * r2 + E * E - q2 * q2) / (2 * E * r2));
              c3 = q2 < k4 ? c3 - p2.indexLabelTextBlock.y : 0;
              d3 = null;
              for (m2 = 1; m2 < n.length; m2++)
                if (d3 = (a2 - m2 + g.length) % g.length, g[d3].hemisphere !== g[a2].hemisphere) {
                  d3 = null;
                  break;
                } else if (g[d3].indexLabelText && g[d3].hemisphere === g[a2].hemisphere && d3 !== a2 && (0 > b(g[d3], g[a2]) || ("right" === g[a2].hemisphere ? g[d3].indexLabelTextBlock.y <= g[a2].indexLabelTextBlock.y : g[d3].indexLabelTextBlock.y >= g[a2].indexLabelTextBlock.y)))
                  break;
                else
                  d3 = null;
              k4 = d3;
              q2 = e(a2);
              m2 = d3 = 0;
              0 > c3 ? (m2 = "right" === p2.hemisphere ? k4 : q2, f3 = c3, null !== m2 && (k4 = -c3, c3 = p2.indexLabelTextBlock.y - p2.indexLabelTextBlock.height / 2 - (g[m2].indexLabelTextBlock.y + g[m2].indexLabelTextBlock.height / 2), c3 - k4 < z && (d3 = -k4, m2 = l2(m2, d3, h3 + 1), +m2.toFixed(w2) > +d3.toFixed(w2) && (f3 = c3 > z ? -(c3 - z) : -(k4 - (m2 - d3)))))) : 0 < c3 && (m2 = "right" === p2.hemisphere ? q2 : k4, f3 = c3, null !== m2 && (k4 = c3, c3 = g[m2].indexLabelTextBlock.y - g[m2].indexLabelTextBlock.height / 2 - (p2.indexLabelTextBlock.y + p2.indexLabelTextBlock.height / 2), c3 - k4 < z && (d3 = k4, m2 = l2(m2, d3, h3 + 1), +m2.toFixed(w2) < +d3.toFixed(w2) && (f3 = c3 > z ? c3 - z : k4 - (d3 - m2)))));
              f3 && (h3 = p2.indexLabelTextBlock.y + f3, c3 = 0, c3 = "right" === p2.hemisphere ? y2.x + Math.sqrt(Math.pow(r2, 2) - Math.pow(h3 - y2.y, 2)) : y2.x - Math.sqrt(Math.pow(r2, 2) - Math.pow(h3 - y2.y, 2)), p2.midAngle > Math.PI / 2 - t && p2.midAngle < Math.PI / 2 + t ? (d3 = (a2 - 1 + g.length) % g.length, d3 = g[d3], a2 = g[(a2 + 1 + g.length) % g.length], "left" === p2.hemisphere && "right" === d3.hemisphere && c3 > d3.indexLabelTextBlock.x ? c3 = d3.indexLabelTextBlock.x - 15 : "right" === p2.hemisphere && ("left" === a2.hemisphere && c3 < a2.indexLabelTextBlock.x) && (c3 = a2.indexLabelTextBlock.x + 15)) : p2.midAngle > 3 * Math.PI / 2 - t && p2.midAngle < 3 * Math.PI / 2 + t && (d3 = (a2 - 1 + g.length) % g.length, d3 = g[d3], a2 = g[(a2 + 1 + g.length) % g.length], "right" === p2.hemisphere && "left" === d3.hemisphere && c3 < d3.indexLabelTextBlock.x ? c3 = d3.indexLabelTextBlock.x + 15 : "left" === p2.hemisphere && ("right" === a2.hemisphere && c3 > a2.indexLabelTextBlock.x) && (c3 = a2.indexLabelTextBlock.x - 15)), p2.indexLabelTextBlock.y = h3, p2.indexLabelTextBlock.x = c3, p2.indexLabelAngle = Math.atan2(p2.indexLabelTextBlock.y - y2.y, p2.indexLabelTextBlock.x - y2.x));
            }
            return f3;
          }
          function k3() {
            var a2 = u3.plotArea.ctx;
            a2.fillStyle = "grey";
            a2.strokeStyle = "grey";
            a2.font = "16px Arial";
            a2.textBaseline = "middle";
            for (var c3 = a2 = 0, h3 = 0, f3 = true, c3 = 0; 10 > c3 && (1 > c3 || 0 < h3); c3++) {
              if (m.radius || !m.radius && "undefined" !== typeof m.innerRadius && null !== m.innerRadius && E - h3 <= D2)
                f3 = false;
              f3 && (E -= h3);
              h3 = 0;
              if ("inside" !== m.indexLabelPlacement) {
                r2 = E * v2;
                for (a2 = 0; a2 < n.length; a2++) {
                  var d3 = g[a2];
                  d3.indexLabelTextBlock.x = y2.x + r2 * Math.cos(d3.midAngle);
                  d3.indexLabelTextBlock.y = y2.y + r2 * Math.sin(d3.midAngle);
                  d3.indexLabelAngle = d3.midAngle;
                  d3.radius = E;
                  d3.percentInnerRadius = K;
                }
                for (var C2, t2, a2 = 0; a2 < n.length; a2++) {
                  var d3 = g[a2], s3 = e(a2);
                  if (null !== s3) {
                    C2 = g[a2];
                    t2 = g[s3];
                    var x4 = 0, x4 = b(C2, t2) - z;
                    if (0 > x4) {
                      for (var A3 = t2 = 0, ua = 0; ua < n.length; ua++)
                        ua !== a2 && g[ua].hemisphere === d3.hemisphere && (g[ua].indexLabelTextBlock.y < d3.indexLabelTextBlock.y ? t2++ : A3++);
                      t2 = x4 / (t2 + A3 || 1) * A3;
                      var A3 = -1 * (x4 - t2), N = ua = 0;
                      "right" === d3.hemisphere ? (ua = l2(a2, t2), A3 = -1 * (x4 - ua), N = l2(s3, A3), +N.toFixed(w2) < +A3.toFixed(w2) && +ua.toFixed(w2) <= +t2.toFixed(w2) && l2(a2, -(A3 - N))) : (ua = l2(s3, t2), A3 = -1 * (x4 - ua), N = l2(a2, A3), +N.toFixed(w2) < +A3.toFixed(w2) && +ua.toFixed(w2) <= +t2.toFixed(w2) && l2(s3, -(A3 - N)));
                    }
                  }
                }
              } else
                for (a2 = 0; a2 < n.length; a2++)
                  d3 = g[a2], r2 = "pie" === m.type ? 0.7 * E : 0.85 * E, s3 = y2.x + r2 * Math.cos(d3.midAngle), t2 = y2.y + r2 * Math.sin(d3.midAngle), d3.indexLabelTextBlock.x = s3, d3.indexLabelTextBlock.y = t2;
              for (a2 = 0; a2 < n.length; a2++)
                if (d3 = g[a2], s3 = d3.indexLabelTextBlock.measureText(), 0 !== s3.height && 0 !== s3.width)
                  s3 = s3 = 0, "right" === d3.hemisphere ? (s3 = q.x2 - (d3.indexLabelTextBlock.x + d3.indexLabelTextBlock.width + p), s3 *= -1) : s3 = q.x1 - (d3.indexLabelTextBlock.x - d3.indexLabelTextBlock.width - p), 0 < s3 && (!f3 && d3.indexLabelText && (t2 = "right" === d3.hemisphere ? q.x2 - d3.indexLabelTextBlock.x : d3.indexLabelTextBlock.x - q.x1, 0.3 * d3.indexLabelTextBlock.maxWidth > t2 ? d3.indexLabelText = "" : d3.indexLabelTextBlock.maxWidth = 0.85 * t2, 0.3 * d3.indexLabelTextBlock.maxWidth < t2 && (d3.indexLabelTextBlock.x -= "right" === d3.hemisphere ? 2 : -2)), Math.abs(d3.indexLabelTextBlock.y - d3.indexLabelTextBlock.height / 2 - y2.y) < E || Math.abs(d3.indexLabelTextBlock.y + d3.indexLabelTextBlock.height / 2 - y2.y) < E) && (s3 /= Math.abs(Math.cos(d3.indexLabelAngle)), 9 < s3 && (s3 *= 0.3), s3 > h3 && (h3 = s3)), s3 = s3 = 0, 0 < d3.indexLabelAngle && d3.indexLabelAngle < Math.PI ? (s3 = q.y2 - (d3.indexLabelTextBlock.y + d3.indexLabelTextBlock.height / 2 + 5), s3 *= -1) : s3 = q.y1 - (d3.indexLabelTextBlock.y - d3.indexLabelTextBlock.height / 2 - 5), 0 < s3 && (!f3 && d3.indexLabelText && (t2 = 0 < d3.indexLabelAngle && d3.indexLabelAngle < Math.PI ? -1 : 1, 0 === l2(a2, s3 * t2) && l2(a2, 2 * t2)), Math.abs(d3.indexLabelTextBlock.x - y2.x) < E && (s3 /= Math.abs(Math.sin(d3.indexLabelAngle)), 9 < s3 && (s3 *= 0.3), s3 > h3 && (h3 = s3)));
              var F3 = function(a3, b2, c4) {
                for (var h4 = [], e2 = 0; h4.push(g[b2]), b2 !== c4; b2 = (b2 + 1 + n.length) % n.length)
                  ;
                h4.sort(function(a4, b3) {
                  return a4.y - b3.y;
                });
                for (b2 = 0; b2 < h4.length; b2++)
                  if (c4 = h4[b2], e2 < 0.7 * a3)
                    e2 += c4.indexLabelTextBlock.height, c4.indexLabelTextBlock.text = "", c4.indexLabelText = "", c4.indexLabelTextBlock.measureText();
                  else
                    break;
              };
              (function() {
                for (var a3 = -1, c4 = -1, h4 = 0, l3 = false, f4 = 0; f4 < n.length; f4++)
                  if (l3 = false, C2 = g[f4], C2.indexLabelText) {
                    var d4 = e(f4);
                    if (null !== d4) {
                      var m2 = g[d4];
                      x4 = 0;
                      x4 = b(C2, m2);
                      var q2;
                      if (q2 = 0 > x4) {
                        q2 = C2.indexLabelTextBlock.x;
                        var k4 = C2.indexLabelTextBlock.y - C2.indexLabelTextBlock.height / 2, s4 = C2.indexLabelTextBlock.y + C2.indexLabelTextBlock.height / 2, t3 = m2.indexLabelTextBlock.y - m2.indexLabelTextBlock.height / 2, u4 = m2.indexLabelTextBlock.x + m2.indexLabelTextBlock.width, r3 = m2.indexLabelTextBlock.y + m2.indexLabelTextBlock.height / 2;
                        q2 = C2.indexLabelTextBlock.x + C2.indexLabelTextBlock.width < m2.indexLabelTextBlock.x - p || q2 > u4 + p || k4 > r3 + p || s4 < t3 - p ? false : true;
                      }
                      q2 ? (0 > a3 && (a3 = f4), d4 !== a3 && (c4 = d4, h4 += -x4), 0 === f4 % Math.max(n.length / 10, 3) && (l3 = true)) : l3 = true;
                      l3 && (0 < h4 && 0 <= a3 && 0 <= c4) && (F3(h4, a3, c4), c4 = a3 = -1, h4 = 0);
                    }
                  }
                0 < h4 && F3(h4, a3, c4);
              })();
            }
          }
          function s2() {
            u3.plotArea.layoutManager.reset();
            u3.title && (u3.title.dockInsidePlotArea || "center" === u3.title.horizontalAlign && "center" === u3.title.verticalAlign) && u3.title.render();
            if (u3.subtitles)
              for (var a2 = 0; a2 < u3.subtitles.length; a2++) {
                var b2 = u3.subtitles[a2];
                (b2.dockInsidePlotArea || "center" === b2.horizontalAlign && "center" === b2.verticalAlign) && b2.render();
              }
            u3.legend && (u3.legend.dockInsidePlotArea || "center" === u3.legend.horizontalAlign && "center" === u3.legend.verticalAlign) && (u3.legend.setLayout(), u3.legend.render());
          }
          var u3 = this;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            var m = this.data[a.dataSeriesIndexes[0]], n = m.dataPoints, p = 10, q = this.plotArea, g = m.dataPointEOs, z = 2, r2, v2 = 1.3, t = 20 / 180 * Math.PI, w2 = 6, y2 = { x: (q.x2 + q.x1) / 2, y: (q.y2 + q.y1) / 2 }, x3 = 0;
            a = false;
            for (var A2 = 0; A2 < n.length; A2++)
              x3 += Math.abs(n[A2].y), !a && ("undefined" !== typeof n[A2].indexLabel && null !== n[A2].indexLabel && 0 < n[A2].indexLabel.toString().length) && (a = true), !a && ("undefined" !== typeof n[A2].label && null !== n[A2].label && 0 < n[A2].label.toString().length) && (a = true);
            if (0 !== x3) {
              a = a || "undefined" !== typeof m.indexLabel && null !== m.indexLabel && 0 < m.indexLabel.toString().length;
              var E = "inside" !== m.indexLabelPlacement && a ? 0.75 * Math.min(q.width, q.height) / 2 : 0.92 * Math.min(q.width, q.height) / 2;
              m.radius && (E = Wa(m.radius, E));
              var D2 = "undefined" !== typeof m.innerRadius && null !== m.innerRadius ? Wa(m.innerRadius, E) : 0.7 * E;
              m.radius = E;
              "doughnut" === m.type && (m.innerRadius = D2);
              var K = Math.min(D2 / E, (E - 1) / E);
              this.pieDoughnutClickHandler = function(a2) {
                u3.isAnimating || !f2(a2.dataSeries.explodeOnClick) && !a2.dataSeries.explodeOnClick || (a2 = a2.dataPoint, a2.exploded = a2.exploded ? false : true, 1 < this.dataPoints.length && u3._animator.animate(0, 500, function(a3) {
                  c2(a3, true);
                  s2();
                  u3.dispatchEvent("dataAnimationIterationEnd", { chart: u3 });
                  u3.dispatchEvent("dataAnimationEnd", { chart: u3 });
                }));
              };
              h2();
              k3();
              k3();
              k3();
              k3();
              this.disableToolTip = true;
              this._animator.animate(0, this.animatedRender ? this.animationDuration : 0, function(a2) {
                var b2 = u3.plotArea.ctx;
                b2.clearRect(q.x1, q.y1, q.width, q.height);
                b2.fillStyle = u3.backgroundColor;
                b2.fillRect(q.x1, q.y1, q.width, q.height);
                for (var b2 = g[0].startAngle + 2 * Math.PI * a2, c3 = 0; c3 < n.length; c3++) {
                  var h3 = 0 === c3 ? g[c3].startAngle : e2, e2 = h3 + (g[c3].endAngle - g[c3].startAngle), l3 = false;
                  e2 > b2 && (e2 = b2, l3 = true);
                  var f3 = n[c3].color ? n[c3].color : m._colorSet[c3 % m._colorSet.length];
                  e2 > h3 && d2(u3.plotArea.ctx, g[c3].center, g[c3].radius, f3, m.type, h3, e2, m.fillOpacity, g[c3].percentInnerRadius);
                  if (l3)
                    break;
                }
                s2();
                u3.dispatchEvent(
                  "dataAnimationIterationEnd",
                  { chart: u3 }
                );
                1 <= a2 && u3.dispatchEvent("dataAnimationEnd", { chart: u3 });
              }, function() {
                u3.disableToolTip = false;
                u3._animator.animate(0, u3.animatedRender ? 500 : 0, function(a2) {
                  c2(a2, false);
                  s2();
                  u3.dispatchEvent("dataAnimationIterationEnd", { chart: u3 });
                });
                u3.dispatchEvent("dataAnimationEnd", { chart: u3 });
              });
            }
          }
        };
        var u2 = function(a, h2, c2, b) {
          "undefined" === typeof c2 && (c2 = 1);
          0 >= Math.round(h2.y4 - h2.y1) || (a.save(), a.globalAlpha = c2, a.beginPath(), a.moveTo(Math.round(h2.x1), Math.round(h2.y1)), a.lineTo(Math.round(h2.x2), Math.round(h2.y2)), a.lineTo(
            Math.round(h2.x3),
            Math.round(h2.y3)
          ), a.lineTo(Math.round(h2.x4), Math.round(h2.y4)), "undefined" !== h2.x5 && (a.lineTo(Math.round(h2.x5), Math.round(h2.y5)), a.lineTo(Math.round(h2.x6), Math.round(h2.y6))), a.closePath(), a.fillStyle = b ? b : h2.color, a.fill(), a.globalAplha = 1, a.restore());
        };
        w.prototype.renderFunnel = function(a) {
          function h2() {
            for (var a2 = 0, b2 = [], c3 = 0; c3 < x3.length; c3++) {
              if ("undefined" === typeof x3[c3].y)
                return -1;
              x3[c3].y = "number" === typeof x3[c3].y ? x3[c3].y : 0;
              a2 += Math.abs(x3[c3].y);
            }
            if (0 === a2)
              return -1;
            for (c3 = b2[0] = 0; c3 < x3.length; c3++)
              b2.push(Math.abs(x3[c3].y) * K / a2);
            return b2;
          }
          function c2() {
            var a2 = Z, b2 = $2, c3 = S2, h3 = aa2, e2, g2;
            e2 = O2;
            g2 = Q2 - M3;
            h3 = Math.abs((g2 - e2) * (b2 - a2 + (h3 - c3)) / 2);
            c3 = aa2 - S2;
            e2 = g2 - e2;
            g2 = c3 * (g2 - Q2);
            g2 = Math.abs(g2);
            g2 = h3 + g2;
            for (var h3 = [], l3 = 0, f3 = 0; f3 < x3.length; f3++) {
              if ("undefined" === typeof x3[f3].y)
                return -1;
              x3[f3].y = "number" === typeof x3[f3].y ? x3[f3].y : 0;
              l3 += Math.abs(x3[f3].y);
            }
            if (0 === l3)
              return -1;
            for (var d4 = h3[0] = 0, m2 = 0, n2, p2, b2 = b2 - a2, d4 = false, f3 = 0; f3 < x3.length; f3++)
              a2 = Math.abs(x3[f3].y) * g2 / l3, d4 ? n2 = 0 == Number(c3.toFixed(3)) ? 0 : a2 / c3 : (p2 = ga2 * ga2 * b2 * b2 - 4 * Math.abs(ga2) * a2, 0 > p2 ? (p2 = c3, d4 = (b2 + p2) * (e2 - m2) / 2, a2 -= d4, n2 = e2 - m2, m2 += e2 - m2, n2 += 0 == p2 ? 0 : a2 / p2, m2 += a2 / p2, d4 = true) : (n2 = (Math.abs(ga2) * b2 - Math.sqrt(p2)) / 2, p2 = b2 - 2 * n2 / Math.abs(ga2), m2 += n2, m2 > e2 && (m2 -= n2, p2 = c3, d4 = (b2 + p2) * (e2 - m2) / 2, a2 -= d4, n2 = e2 - m2, m2 += e2 - m2, n2 += a2 / p2, m2 += a2 / p2, d4 = true), b2 = p2)), h3.push(n2);
            return h3;
          }
          function b() {
            if (t && x3) {
              for (var a2, b2, c3, h3, e2, l3, d4, m2, n2, p2, q2, k4, C2, s2, u3, z2 = [], v3 = [], y3 = { percent: null, total: null }, w3 = null, A3 = 0; A3 < x3.length; A3++)
                u3 = U[A3], u3 = "undefined" !== typeof u3.x5 ? (u3.y2 + u3.y4) / 2 : (u3.y2 + u3.y3) / 2, u3 = g(u3).x2 + 1, z2[A3] = L3 - u3 - V2;
              u3 = 0.5 * V2;
              for (var A3 = 0, ha = x3.length - 1; A3 < x3.length || 0 <= ha; A3++, ha--) {
                b2 = t.reversed ? x3[ha] : x3[A3];
                a2 = b2.color ? b2.color : t.reversed ? t._colorSet[(x3.length - 1 - A3) % t._colorSet.length] : t._colorSet[A3 % t._colorSet.length];
                c3 = b2.indexLabelPlacement || t.indexLabelPlacement || "outside";
                s2 = b2.indexLabelTextAlign || t.indexLabelTextAlign || "left";
                h3 = b2.indexLabelBackgroundColor || t.indexLabelBackgroundColor || (r ? "transparent" : null);
                e2 = b2.indexLabelFontColor || t.indexLabelFontColor || "#979797";
                l3 = f2(b2.indexLabelFontSize) ? t.indexLabelFontSize : b2.indexLabelFontSize;
                d4 = b2.indexLabelFontStyle || t.indexLabelFontStyle || "normal";
                m2 = b2.indexLabelFontFamily || t.indexLabelFontFamily || "arial";
                n2 = b2.indexLabelFontWeight || t.indexLabelFontWeight || "normal";
                a2 = b2.indexLabelLineColor || t.options.indexLabelLineColor || a2;
                p2 = "number" === typeof b2.indexLabelLineThickness ? b2.indexLabelLineThickness : "number" === typeof t.indexLabelLineThickness ? t.indexLabelLineThickness : 2;
                q2 = b2.indexLabelLineDashType || t.indexLabelLineDashType || "solid";
                k4 = "undefined" !== typeof b2.indexLabelWrap ? b2.indexLabelWrap : "undefined" !== typeof t.indexLabelWrap ? t.indexLabelWrap : true;
                C2 = t.dataPointIds[A3];
                B._eventManager.objectMap[C2] = {
                  id: C2,
                  objectType: "dataPoint",
                  dataPointIndex: A3,
                  dataSeriesIndex: 0,
                  funnelSection: U[t.reversed ? x3.length - 1 - A3 : A3]
                };
                "inside" === t.indexLabelPlacement && (z2[A3] = A3 !== ia3 ? t.reversed ? U[A3].x2 - U[A3].x1 : U[A3].x3 - U[A3].x4 : U[A3].x3 - U[A3].x6, 20 > z2[A3] && (z2[A3] = A3 !== ia3 ? t.reversed ? U[A3].x3 - U[A3].x4 : U[A3].x2 - U[A3].x1 : U[A3].x2 - U[A3].x1, z2[A3] /= 2));
                C2 = b2.indexLabelMaxWidth ? b2.indexLabelMaxWidth : t.options.indexLabelMaxWidth ? t.indexLabelMaxWidth : z2[A3];
                if (C2 > z2[A3] || 0 > C2)
                  C2 = z2[A3];
                v3[A3] = "inside" === t.indexLabelPlacement ? k4 ? Math.max(U[A3].height, l3) : 1.5 * l3 : false;
                y3 = B.getPercentAndTotal(t, b2);
                if (t.indexLabelFormatter || b2.indexLabelFormatter)
                  w3 = { chart: B.options, dataSeries: t, dataPoint: b2, total: y3.total, percent: y3.percent };
                b2 = b2.indexLabelFormatter ? b2.indexLabelFormatter(w3) : b2.indexLabel ? B.replaceKeywordsWithValue(b2.indexLabel, b2, t, A3) : t.indexLabelFormatter ? t.indexLabelFormatter(w3) : t.indexLabel ? B.replaceKeywordsWithValue(t.indexLabel, b2, t, A3) : b2.label ? b2.label : "";
                0 >= p2 && (p2 = 0);
                1e3 > C2 && 1e3 - C2 < u3 && (C2 += 1e3 - C2);
                f2(t.options.indexLabelMaxWidth) && (t.indexLabelMaxWidth = f2(t.indexLabelMaxWidth) ? C2 : Math.max(C2, t.indexLabelMaxWidth));
                P2.roundRect || Da(P2);
                c3 = new ma(P2, { fontSize: l3, fontFamily: m2, fontColor: e2, fontStyle: d4, fontWeight: n2, horizontalAlign: c3, textAlign: s2, backgroundColor: h3, maxWidth: C2, maxHeight: false === v3[A3] ? k4 ? 4.28571429 * l3 : 1.5 * l3 : v3[A3], text: b2, padding: ja2, textBaseline: "middle" });
                c3.measureText();
                c3.height = c3.height === 2 * c3.padding ? 0 : c3.height;
                c3.width = c3.width === 2 * c3.padding ? 0 : c3.width;
                I.push({ textBlock: c3, id: t.reversed ? ha : A3, isDirty: false, lineColor: a2, lineThickness: p2, lineDashType: q2, height: c3.height < c3.maxHeight ? c3.height : c3.maxHeight, width: c3.width < c3.maxWidth ? c3.width : c3.maxWidth });
              }
            }
          }
          function e() {
            var a2, b2, c3, h3, e2, g2 = [];
            e2 = false;
            c3 = 0;
            for (var l3, f3 = L3 - $2 - V2 / 2, f3 = t.options.indexLabelMaxWidth ? t.indexLabelMaxWidth > f3 ? f3 : t.indexLabelMaxWidth : f3, d4 = I.length - 1; 0 <= d4; d4--) {
              l3 = x3[I[d4].id];
              c3 = I[d4];
              h3 = c3.textBlock;
              b2 = (a2 = q(d4) < U.length ? I[q(d4)] : null) ? a2.textBlock : null;
              c3 = c3.height;
              a2 && h3.y + c3 + ja2 > b2.y && (e2 = true);
              c3 = l3.indexLabelMaxWidth || f3;
              if (c3 > f3 || 0 > c3)
                c3 = f3;
              g2.push(c3);
            }
            if (e2)
              for (d4 = I.length - 1; 0 <= d4; d4--)
                a2 = U[d4], I[d4].textBlock.maxWidth = g2[g2.length - (d4 + 1)], I[d4].textBlock.measureText(), I[d4].textBlock.height = I[d4].textBlock.height === 2 * I[d4].textBlock.padding ? 0 : I[d4].textBlock.height, I[d4].textBlock.width = I[d4].textBlock.width === 2 * I[d4].textBlock.padding ? 0 : I[d4].textBlock.width, I[d4].textBlock.x = L3 - f3, c3 = I[d4].textBlock.height < I[d4].textBlock.maxHeight ? I[d4].textBlock.height : I[d4].textBlock.maxHeight, e2 = I[d4].textBlock.width < I[d4].textBlock.maxWidth ? I[d4].textBlock.width : I[d4].textBlock.maxWidth, I[d4].height = c3, I[d4].width = e2, c3 = "undefined" !== typeof a2.x5 ? (a2.y2 + a2.y4) / 2 : (a2.y2 + a2.y3) / 2, I[d4].textBlock.y = c3 - I[d4].height / 2, t.reversed ? (I[d4].textBlock.y + I[d4].height > T3 + A2 && (I[d4].textBlock.y = T3 + A2 - I[d4].height), I[d4].textBlock.y < ba2 - A2 && (I[d4].textBlock.y = ba2 - A2)) : (I[d4].textBlock.y < T3 - A2 && (I[d4].textBlock.y = T3 - A2), I[d4].textBlock.y + I[d4].height > ba2 + A2 && (I[d4].textBlock.y = ba2 + A2 - I[d4].height));
          }
          function l2() {
            var a2, b2, c3, h3;
            if ("inside" !== t.indexLabelPlacement)
              for (var e2 = 0; e2 < U.length; e2++)
                0 == I[e2].textBlock.text.length ? I[e2].isDirty = true : (a2 = U[e2], c3 = "undefined" !== typeof a2.x5 ? (a2.y2 + a2.y4) / 2 : (a2.y2 + a2.y3) / 2, b2 = t.reversed ? "undefined" !== typeof a2.x5 ? c3 > da2 ? g(c3).x2 + 1 : (a2.x2 + a2.x3) / 2 + 1 : (a2.x2 + a2.x3) / 2 + 1 : "undefined" !== typeof a2.x5 ? c3 < da2 ? g(c3).x2 + 1 : (a2.x4 + a2.x3) / 2 + 1 : (a2.x2 + a2.x3) / 2 + 1, I[e2].textBlock.x = b2 + V2, I[e2].textBlock.y = c3 - I[e2].height / 2, t.reversed ? (I[e2].textBlock.y + I[e2].height > T3 + A2 && (I[e2].textBlock.y = T3 + A2 - I[e2].height), I[e2].textBlock.y < ba2 - A2 && (I[e2].textBlock.y = ba2 - A2)) : (I[e2].textBlock.y < T3 - A2 && (I[e2].textBlock.y = T3 - A2), I[e2].textBlock.y + I[e2].height > ba2 + A2 && (I[e2].textBlock.y = ba2 + A2 - I[e2].height)));
            else
              for (e2 = 0; e2 < U.length; e2++)
                0 == I[e2].textBlock.text.length ? I[e2].isDirty = true : (a2 = U[e2], b2 = a2.height, c3 = I[e2].height, h3 = I[e2].width, b2 >= c3 ? (b2 = e2 != ia3 ? (a2.x4 + a2.x3) / 2 - h3 / 2 : (a2.x5 + a2.x4) / 2 - h3 / 2, c3 = e2 != ia3 ? (a2.y1 + a2.y3) / 2 - c3 / 2 : (a2.y1 + a2.y4) / 2 - c3 / 2, I[e2].textBlock.x = b2, I[e2].textBlock.y = c3) : I[e2].isDirty = true);
          }
          function d3() {
            function a2(b3, c4) {
              var h4;
              if (0 > b3 || b3 >= I.length)
                return 0;
              var e3, g3 = I[b3].textBlock;
              if (0 > c4) {
                c4 *= -1;
                e3 = p(b3);
                h4 = k3(e3, b3);
                if (h4 >= c4)
                  return g3.y -= c4, c4;
                if (0 == b3)
                  return 0 < h4 && (g3.y -= h4), h4;
                h4 += a2(e3, -(c4 - h4));
                0 < h4 && (g3.y -= h4);
                return h4;
              }
              e3 = q(b3);
              h4 = k3(b3, e3);
              if (h4 >= c4)
                return g3.y += c4, c4;
              if (b3 == U.length - 1)
                return 0 < h4 && (g3.y += h4), h4;
              h4 += a2(e3, c4 - h4);
              0 < h4 && (g3.y += h4);
              return h4;
            }
            function b2() {
              var a3, h4, e3, g3, l4 = 0, d4;
              g3 = (Q2 - O2 + 2 * A2) / n2;
              d4 = n2;
              for (var f4, m3 = 1; m3 < d4; m3++) {
                e3 = m3 * g3;
                for (var k4 = I.length - 1; 0 <= k4; k4--)
                  !I[k4].isDirty && (I[k4].textBlock.y < e3 && I[k4].textBlock.y + I[k4].height > e3) && (f4 = q(k4), !(f4 >= I.length - 1) && I[k4].textBlock.y + I[k4].height + ja2 > I[f4].textBlock.y && (I[k4].textBlock.y = I[k4].textBlock.y + I[k4].height - e3 > e3 - I[k4].textBlock.y ? e3 + 1 : e3 - I[k4].height - 1));
              }
              for (f4 = U.length - 1; 0 < f4; f4--)
                if (!I[f4].isDirty) {
                  e3 = p(f4);
                  if (0 > e3 && (e3 = 0, I[e3].isDirty))
                    break;
                  if (I[f4].textBlock.y < I[e3].textBlock.y + I[e3].height) {
                    h4 = h4 || f4;
                    g3 = f4;
                    for (d4 = 0; I[g3].textBlock.y < I[e3].textBlock.y + I[e3].height + ja2; ) {
                      a3 = a3 || I[g3].textBlock.y + I[g3].height;
                      d4 += I[g3].height;
                      d4 += ja2;
                      g3 = e3;
                      if (0 >= g3) {
                        g3 = 0;
                        d4 += I[g3].height;
                        break;
                      }
                      e3 = p(g3);
                      if (0 > e3) {
                        g3 = 0;
                        d4 += I[g3].height;
                        break;
                      }
                    }
                    if (g3 != f4) {
                      l4 = I[g3].textBlock.y;
                      a3 -= l4;
                      a3 = d4 - a3;
                      l4 = c3(a3, h4, g3);
                      break;
                    }
                  }
                }
              return l4;
            }
            function c3(a3, b3, h4) {
              var e3 = [], g3 = 0, l4 = 0;
              for (a3 = Math.abs(a3); h4 <= b3; h4++)
                e3.push(U[h4]);
              e3.sort(function(a4, b4) {
                return a4.height - b4.height;
              });
              for (h4 = 0; h4 < e3.length; h4++)
                if (b3 = e3[h4], g3 < a3)
                  l4++, g3 += I[b3.id].height + ja2, I[b3.id].textBlock.text = "", I[b3.id].indexLabelText = "", I[b3.id].isDirty = true, I[b3.id].textBlock.measureText();
                else
                  break;
              return l4;
            }
            for (var h3, e2, g2, l3, f3, m2, n2 = 1, C2 = 0; C2 < 2 * n2; C2++) {
              for (var s2 = I.length - 1; 0 <= s2 && !(0 <= p(s2) && p(s2), g2 = I[s2], l3 = g2.textBlock, m2 = (f3 = q(s2) < U.length ? I[q(s2)] : null) ? f3.textBlock : null, h3 = +g2.height.toFixed(6), e2 = +l3.y.toFixed(6), !g2.isDirty && (f3 && e2 + h3 + ja2 > +m2.y.toFixed(6)) && (h3 = l3.y + h3 + ja2 - m2.y, e2 = a2(s2, -h3), e2 < h3 && (0 < e2 && (h3 -= e2), e2 = a2(q(s2), h3), e2 != h3))); s2--)
                ;
              b2();
            }
          }
          function k3(a2, b2) {
            return (b2 < U.length ? I[b2].textBlock.y : t.reversed ? T3 + A2 : ba2 + A2) - (0 > a2 ? t.reversed ? ba2 - A2 : T3 - A2 : I[a2].textBlock.y + I[a2].height + ja2);
          }
          function v2(a2, b2, c3) {
            var h3, e2, g2, d4 = [], f3 = A2, p2 = [];
            -1 !== b2 && (0 <= ea2.indexOf(b2) ? (e2 = ea2.indexOf(b2), ea2.splice(
              e2,
              1
            )) : (ea2.push(b2), ea2 = ea2.sort(function(a3, b3) {
              return a3 - b3;
            })));
            if (0 === ea2.length)
              d4 = na2;
            else {
              e2 = A2 * (1 != ea2.length || 0 != ea2[0] && ea2[0] != U.length - 1 ? 2 : 1) / m();
              for (var k4 = 0; k4 < U.length; k4++) {
                if (1 == ea2.length && 0 == ea2[0]) {
                  if (0 === k4) {
                    d4.push(na2[k4]);
                    h3 = f3;
                    continue;
                  }
                } else
                  0 === k4 && (h3 = -1 * f3);
                d4.push(na2[k4] + h3);
                if (0 <= ea2.indexOf(k4) || k4 < U.length && 0 <= ea2.indexOf(k4 + 1))
                  h3 += e2;
              }
            }
            g2 = function() {
              for (var a3 = [], b3 = 0; b3 < U.length; b3++)
                a3.push(d4[b3] - U[b3].y1);
              return a3;
            }();
            var q2 = { startTime: new Date().getTime(), duration: c3 || 500, easingFunction: function(a3, b3, c4, h4) {
              return s.easing.easeOutQuart(
                a3,
                b3,
                c4,
                h4
              );
            }, changeSection: function(a3) {
              for (var b3, c4, h4 = 0; h4 < U.length; h4++)
                b3 = g2[h4], c4 = U[h4], b3 *= a3, "undefined" === typeof p2[h4] && (p2[h4] = 0), 0 > p2 && (p2 *= -1), c4.y1 += b3 - p2[h4], c4.y2 += b3 - p2[h4], c4.y3 += b3 - p2[h4], c4.y4 += b3 - p2[h4], c4.y5 && (c4.y5 += b3 - p2[h4], c4.y6 += b3 - p2[h4]), p2[h4] = b3;
            } };
            a2._animator.animate(0, c3, function(c4) {
              var h4 = a2.plotArea.ctx || a2.ctx;
              pa2 = true;
              h4.clearRect(y2.x1, y2.y1, y2.x2 - y2.x1, y2.y2 - y2.y1);
              h4.fillStyle = a2.backgroundColor;
              h4.fillRect(y2.x1, y2.y1, y2.width, y2.height);
              q2.changeSection(c4, b2);
              var e3 = {};
              e3.dataSeries = t;
              e3.dataPoint = t.reversed ? t.dataPoints[x3.length - 1 - b2] : t.dataPoints[b2];
              e3.index = t.reversed ? x3.length - 1 - b2 : b2;
              a2.toolTip.highlightObjects([e3]);
              for (e3 = 0; e3 < U.length; e3++)
                u2(h4, U[e3], t.fillOpacity);
              w2(h4);
              J && ("inside" !== t.indexLabelPlacement ? n(h4) : l2(), z(h4));
              1 <= c4 && (pa2 = false);
            }, null, s.easing.easeOutQuart);
          }
          function m() {
            for (var a2 = 0, b2 = 0; b2 < U.length - 1; b2++)
              (0 <= ea2.indexOf(b2) || 0 <= ea2.indexOf(b2 + 1)) && a2++;
            return a2;
          }
          function n(a2) {
            for (var b2, c3, h3, e2, l3 = 0; l3 < U.length; l3++)
              e2 = 1 === I[l3].lineThickness % 2 ? 0.5 : 0, c3 = ((U[l3].y2 + U[l3].y4) / 2 << 0) + e2, b2 = g(c3).x2 - 1, h3 = I[l3].textBlock.x, e2 = (I[l3].textBlock.y + I[l3].height / 2 << 0) + e2, I[l3].isDirty || 0 == I[l3].lineThickness || (a2.strokeStyle = I[l3].lineColor, a2.lineWidth = I[l3].lineThickness, a2.setLineDash && a2.setLineDash(R(I[l3].lineDashType, I[l3].lineThickness)), a2.beginPath(), a2.moveTo(b2, c3), a2.lineTo(h3, e2), a2.stroke());
          }
          function p(a2) {
            for (a2 -= 1; -1 <= a2 && -1 != a2 && I[a2].isDirty; a2--)
              ;
            return a2;
          }
          function q(a2) {
            for (a2 += 1; a2 <= U.length && a2 != U.length && I[a2].isDirty; a2++)
              ;
            return a2;
          }
          function g(a2) {
            for (var b2, c3 = 0; c3 < x3.length; c3++)
              if (U[c3].y1 < a2 && U[c3].y4 > a2) {
                b2 = U[c3];
                break;
              }
            return b2 ? (a2 = b2.y6 ? a2 > b2.y6 ? b2.x3 + (b2.x4 - b2.x3) / (b2.y4 - b2.y3) * (a2 - b2.y3) : b2.x2 + (b2.x3 - b2.x2) / (b2.y3 - b2.y2) * (a2 - b2.y2) : b2.x2 + (b2.x3 - b2.x2) / (b2.y3 - b2.y2) * (a2 - b2.y2), { x1: a2, x2: a2 }) : -1;
          }
          function z(a2) {
            for (var b2 = 0; b2 < U.length; b2++)
              I[b2].isDirty || (a2 && (I[b2].textBlock.ctx = a2), I[b2].textBlock.y += I[b2].textBlock._lineHeight / 2, I[b2].textBlock.render(true), I[b2].textBlock.y -= I[b2].textBlock._lineHeight / 2);
          }
          function w2(a2) {
            B.plotArea.layoutManager.reset();
            a2.roundRect || Da(a2);
            B.title && (B.title.dockInsidePlotArea || "center" === B.title.horizontalAlign && "center" === B.title.verticalAlign) && (B.title.ctx = a2, B.title.render());
            if (B.subtitles)
              for (var b2 = 0; b2 < B.subtitles.length; b2++) {
                var c3 = B.subtitles[b2];
                if (c3.dockInsidePlotArea || "center" === c3.horizontalAlign && "center" === c3.verticalAlign)
                  B.subtitles.ctx = a2, c3.render();
              }
            B.legend && (B.legend.dockInsidePlotArea || "center" === B.legend.horizontalAlign && "center" === B.legend.verticalAlign) && (B.legend.ctx = a2, B.legend.setLayout(), B.legend.render());
            Ba.fNg && Ba.fNg(B);
          }
          var B = this;
          if (!(0 >= a.dataSeriesIndexes.length)) {
            for (var t = this.data[a.dataSeriesIndexes[0]], x3 = t.dataPoints, y2 = this.plotArea, A2 = 0.025 * y2.width, D2 = 0.01 * y2.width, E = 0, K = y2.height - 2 * A2, F3 = Math.min(y2.width - 2 * D2, 2.8 * y2.height), J = false, W = 0; W < x3.length; W++)
              if (!J && ("undefined" !== typeof x3[W].indexLabel && null !== x3[W].indexLabel && 0 < x3[W].indexLabel.toString().length) && (J = true), !J && ("undefined" !== typeof x3[W].label && null !== x3[W].label && 0 < x3[W].label.toString().length) && (J = true), !J && "function" === typeof t.indexLabelFormatter || "function" === typeof x3[W].indexLabelFormatter)
                J = true;
            J = J || "undefined" !== typeof t.indexLabel && null !== t.indexLabel && 0 < t.indexLabel.toString().length;
            "inside" !== t.indexLabelPlacement && J || (D2 = (y2.width - 0.75 * F3) / 2);
            var W = y2.x1 + D2, L3 = y2.x2 - D2, O2 = y2.y1 + A2, Q2 = y2.y2 - A2, P2 = a.targetCanvasCtx || this.plotArea.ctx || this.ctx;
            if (0 != t.length && (t.dataPoints && t.visible) && 0 !== x3.length) {
              var M3, H;
              a = 75 * F3 / 100;
              var V2 = 30 * (L3 - a) / 100;
              "funnel" === t.type ? (M3 = f2(t.options.neckHeight) ? 0.35 * K : t.neckHeight, H = f2(t.options.neckWidth) ? 0.25 * a : t.neckWidth, "string" === typeof M3 && M3.match(/%$/) ? (M3 = parseInt(M3), M3 = M3 * K / 100) : M3 = parseInt(M3), "string" === typeof H && H.match(/%$/) ? (H = parseInt(H), H = H * a / 100) : H = parseInt(H), M3 > K ? M3 = K : 0 >= M3 && (M3 = 0), H > a ? H = a - 0.5 : 0 >= H && (H = 0)) : "pyramid" === t.type && (H = M3 = 0, t.reversed = t.reversed ? false : true);
              var D2 = W + a / 2, Z = W, $2 = W + a, T3 = t.reversed ? Q2 : O2, S2 = D2 - H / 2, aa2 = D2 + H / 2, da2 = t.reversed ? O2 + M3 : Q2 - M3, ba2 = t.reversed ? O2 : Q2;
              a = [];
              var D2 = [], U = [], F3 = [], X3 = O2, ia3, ga2 = (da2 - T3) / (S2 - Z), la3 = -ga2, W = "area" === (t.valueRepresents ? t.valueRepresents : "height") ? c2() : h2();
              if (-1 !== W) {
                if (t.reversed)
                  for (F3.push(X3), H = W.length - 1; 0 < H; H--)
                    X3 += W[H], F3.push(X3);
                else
                  for (H = 0; H < W.length; H++)
                    X3 += W[H], F3.push(X3);
                if (t.reversed)
                  for (H = 0; H < W.length; H++)
                    F3[H] < da2 ? (a.push(S2), D2.push(aa2), ia3 = H) : (a.push((F3[H] - T3 + ga2 * Z) / ga2), D2.push((F3[H] - T3 + la3 * $2) / la3));
                else
                  for (H = 0; H < W.length; H++)
                    F3[H] < da2 ? (a.push((F3[H] - T3 + ga2 * Z) / ga2), D2.push((F3[H] - T3 + la3 * $2) / la3), ia3 = H) : (a.push(S2), D2.push(aa2));
                for (H = 0; H < W.length - 1; H++)
                  X3 = t.reversed ? x3[x3.length - 1 - H].color ? x3[x3.length - 1 - H].color : t._colorSet[(x3.length - 1 - H) % t._colorSet.length] : x3[H].color ? x3[H].color : t._colorSet[H % t._colorSet.length], H === ia3 ? U.push({ x1: a[H], y1: F3[H], x2: D2[H], y2: F3[H], x3: aa2, y3: da2, x4: D2[H + 1], y4: F3[H + 1], x5: a[H + 1], y5: F3[H + 1], x6: S2, y6: da2, id: H, height: F3[H + 1] - F3[H], color: X3 }) : U.push({ x1: a[H], y1: F3[H], x2: D2[H], y2: F3[H], x3: D2[H + 1], y3: F3[H + 1], x4: a[H + 1], y4: F3[H + 1], id: H, height: F3[H + 1] - F3[H], color: X3 });
                var ja2 = 2, I = [], pa2 = false, ea2 = [], na2 = [], W = false;
                a = a = 0;
                Ea(ea2);
                for (H = 0; H < x3.length; H++)
                  x3[H].exploded && (W = true, t.reversed ? ea2.push(x3.length - 1 - H) : ea2.push(H));
                P2.clearRect(y2.x1, y2.y1, y2.width, y2.height);
                P2.fillStyle = B.backgroundColor;
                P2.fillRect(y2.x1, y2.y1, y2.width, y2.height);
                if (J && t.visible && (b(), l2(), "inside" !== t.indexLabelPlacement)) {
                  e();
                  d3();
                  for (H = 0; H < x3.length; H++)
                    I[H].isDirty || (a = I[H].textBlock.x + I[H].width, a = (L3 - a) / 2, 0 == H && (E = a), E > a && (E = a));
                  for (H = 0; H < U.length; H++)
                    U[H].x1 += E, U[H].x2 += E, U[H].x3 += E, U[H].x4 += E, U[H].x5 && (U[H].x5 += E, U[H].x6 += E), I[H].textBlock.x += E;
                }
                for (H = 0; H < U.length; H++)
                  E = U[H], u2(P2, E, t.fillOpacity), na2.push(E.y1);
                w2(P2);
                J && t.visible && ("inside" === t.indexLabelPlacement || B.animationEnabled || n(P2), B.animationEnabled || z());
                if (!J)
                  for (H = 0; H < x3.length; H++)
                    E = t.dataPointIds[H], a = { id: E, objectType: "dataPoint", dataPointIndex: H, dataSeriesIndex: 0, funnelSection: U[t.reversed ? x3.length - 1 - H : H] }, B._eventManager.objectMap[E] = a;
                !B.animationEnabled && W ? v2(B, -1, 0) : B.animationEnabled && !B.animatedRender && v2(B, -1, 0);
                this.funnelPyramidClickHandler = function(a2) {
                  var b2 = -1;
                  if (!pa2 && !B.isAnimating && (f2(a2.dataSeries.explodeOnClick) || a2.dataSeries.explodeOnClick) && (b2 = t.reversed ? x3.length - 1 - a2.dataPointIndex : a2.dataPointIndex, 0 <= b2)) {
                    a2 = b2;
                    if ("funnel" === t.type || "pyramid" === t.type)
                      t.reversed ? x3[x3.length - 1 - a2].exploded = x3[x3.length - 1 - a2].exploded ? false : true : x3[a2].exploded = x3[a2].exploded ? false : true;
                    v2(B, b2, 500);
                  }
                };
                return { source: P2, dest: this.plotArea.ctx, animationCallback: function(a2, b2) {
                  s.fadeInAnimation(a2, b2);
                  1 <= a2 && (v2(B, -1, 500), w2(B.plotArea.ctx || B.ctx));
                }, easingFunction: s.easing.easeInQuad, animationBase: 0 };
              }
            }
          }
        };
        w.prototype.requestAnimFrame = function() {
          return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(a) {
            window.setTimeout(a, 1e3 / 60);
          };
        }();
        w.prototype.cancelRequestAnimFrame = window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout;
        w.prototype.set = function(a, h2, c2) {
          c2 = "undefined" === typeof c2 ? true : c2;
          "options" === a ? (this.options = h2, c2 && this.render()) : w.base.set.call(this, a, h2, c2);
        };
        w.prototype.exportChart = function(a) {
          a = "undefined" === typeof a ? {} : a;
          var h2 = a.format ? a.format : "png", c2 = a.fileName ? a.fileName : this.exportFileName;
          if (a.toDataURL)
            return this.canvas.toDataURL("image/" + h2);
          db(this.canvas, h2, c2);
        };
        w.prototype.print = function() {
          var a = this.exportChart({ toDataURL: true }), h2 = document.createElement("iframe");
          h2.setAttribute("class", "canvasjs-chart-print-frame");
          O(h2, { position: "absolute", width: "100%", border: "0px", margin: "0px 0px 0px 0px", padding: "0px 0px 0px 0px" });
          h2.style.height = this.height + "px";
          this._canvasJSContainer.appendChild(h2);
          var c2 = this, b = h2.contentWindow || h2.contentDocument.document || h2.contentDocument;
          b.document.open();
          b.document.write('<!DOCTYPE HTML>\n<html><body><img src="' + a + '"/><body/></html>');
          b.document.body && b.document.body.style && (b.document.body.style.margin = "0px 0px 0px 0px", b.document.body.style.padding = "0px 0px 0px 0px");
          b.document.close();
          setTimeout(function() {
            b.focus();
            b.print();
            setTimeout(function() {
              c2._canvasJSContainer.removeChild(h2);
            }, 1e3);
          }, 500);
        };
        w.prototype.getPercentAndTotal = function(a, h2) {
          var c2 = null, b = null, e = c2 = null;
          if (0 <= a.type.indexOf("stacked"))
            b = 0, c2 = h2.x.getTime ? h2.x.getTime() : h2.x, c2 in a.plotUnit.yTotals && (b = a.plotUnit.yTotals[c2], c2 = a.plotUnit.yAbsTotals[c2], e = isNaN(h2.y) ? 0 : 0 === c2 ? 0 : 100 * (h2.y / c2));
          else if ("pie" === a.type || "doughnut" === a.type || "funnel" === a.type || "pyramid" === a.type) {
            for (c2 = b = 0; c2 < a.dataPoints.length; c2++)
              isNaN(a.dataPoints[c2].y) || (b += a.dataPoints[c2].y);
            e = isNaN(h2.y) ? 0 : 100 * (h2.y / b);
          }
          return { percent: e, total: b };
        };
        w.prototype.replaceKeywordsWithValue = function(a, h2, c2, b, e) {
          var l2 = this;
          e = "undefined" === typeof e ? 0 : e;
          if ((0 <= c2.type.indexOf("stacked") || "pie" === c2.type || "doughnut" === c2.type || "funnel" === c2.type || "pyramid" === c2.type) && (0 <= a.indexOf("#percent") || 0 <= a.indexOf("#total"))) {
            var d3 = "#percent", f3 = "#total", k3 = this.getPercentAndTotal(c2, h2), f3 = isNaN(k3.total) ? f3 : k3.total, d3 = isNaN(k3.percent) ? d3 : k3.percent;
            do {
              k3 = "";
              if (c2.percentFormatString)
                k3 = c2.percentFormatString;
              else {
                var k3 = "#,##0.", m = Math.max(Math.ceil(Math.log(1 / Math.abs(d3)) / Math.LN10), 2);
                if (isNaN(m) || !isFinite(m))
                  m = 2;
                for (var n = 0; n < m; n++)
                  k3 += "#";
                c2.percentFormatString = k3;
              }
              a = a.replace("#percent", da(d3, k3, l2._cultureInfo));
              a = a.replace("#total", da(f3, c2.yValueFormatString ? c2.yValueFormatString : "#,##0.########", l2._cultureInfo));
            } while (0 <= a.indexOf("#percent") || 0 <= a.indexOf("#total"));
          }
          return a.replace(
            /\{.*?\}|"[^"]*"|'[^']*'/g,
            function(a2) {
              if ('"' === a2[0] && '"' === a2[a2.length - 1] || "'" === a2[0] && "'" === a2[a2.length - 1])
                return a2.slice(1, a2.length - 1);
              a2 = Pa(a2.slice(1, a2.length - 1));
              a2 = a2.replace("#index", e);
              var d4 = null;
              try {
                var g = a2.match(/(.*?)\s*\[\s*(.*?)\s*\]/);
                g && 0 < g.length && (d4 = Pa(g[2]), a2 = Pa(g[1]));
              } catch (f4) {
              }
              g = null;
              if ("color" === a2)
                return "waterfall" === c2.type ? h2.color ? h2.color : 0 < h2.y ? c2.risingColor : c2.fallingColor : "error" === c2.type ? c2.color ? c2.color : c2._colorSet[d4 % c2._colorSet.length] : h2.color ? h2.color : c2.color ? c2.color : c2._colorSet[b % c2._colorSet.length];
              if (h2.hasOwnProperty(a2))
                g = h2;
              else if (c2.hasOwnProperty(a2))
                g = c2;
              else
                return "";
              g = g[a2];
              null !== d4 && (g = g[d4]);
              return "x" === a2 ? (c2.axisX && "dateTime" === c2.axisX.valueType || "dateTime" === c2.xValueType || h2.x && h2.x.getTime) && !c2.axisX.logarithmic ? ea(g, h2.xValueFormatString ? h2.xValueFormatString : c2.xValueFormatString ? c2.xValueFormatString : c2.xValueFormatString = l2.axisX && l2.axisX.autoValueFormatString ? l2.axisX.autoValueFormatString : "DD MMM YY", l2._cultureInfo) : da(g, h2.xValueFormatString ? h2.xValueFormatString : c2.xValueFormatString ? c2.xValueFormatString : c2.xValueFormatString = "#,##0.########", l2._cultureInfo) : "y" === a2 ? da(g, h2.yValueFormatString ? h2.yValueFormatString : c2.yValueFormatString ? c2.yValueFormatString : c2.yValueFormatString = "#,##0.########", l2._cultureInfo) : "z" === a2 ? da(g, h2.zValueFormatString ? h2.zValueFormatString : c2.zValueFormatString ? c2.zValueFormatString : c2.zValueFormatString = "#,##0.########", l2._cultureInfo) : g;
            }
          );
        };
        ga(L2, $);
        L2.prototype.setLayout = function() {
          var a = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, h2 = a.layoutManager.getFreeSpace(), c2 = null, b = 0, e = 0, l2 = 0, d3 = 0, k3 = this.markerMargin = this.chart.options.legend && !f2(this.chart.options.legend.markerMargin) ? this.chart.options.legend.markerMargin : 0.3 * this.fontSize;
          this.height = 0;
          var s2 = [], m = [];
          if ("top" === this.verticalAlign || "bottom" === this.verticalAlign)
            this.orientation = "horizontal", c2 = this.verticalAlign, l2 = this.maxWidth = null !== this.maxWidth ? this.maxWidth : h2.width, d3 = this.maxHeight = null !== this.maxHeight ? this.maxHeight : 0.5 * h2.height;
          else if ("center" === this.verticalAlign) {
            this.orientation = "vertical";
            if ("left" === this.horizontalAlign || "center" === this.horizontalAlign || "right" === this.horizontalAlign)
              c2 = this.horizontalAlign;
            l2 = this.maxWidth = null !== this.maxWidth ? this.maxWidth : 0.5 * h2.width;
            d3 = this.maxHeight = null !== this.maxHeight ? this.maxHeight : h2.height;
          }
          this.errorMarkerColor = [];
          for (var n = 0; n < this.dataSeries.length; n++) {
            var p = this.dataSeries[n];
            if (p.dataPoints && p.dataPoints.length)
              if ("pie" !== p.type && "doughnut" !== p.type && "funnel" !== p.type && "pyramid" !== p.type) {
                var q = p.legendMarkerType = p.legendMarkerType ? p.legendMarkerType : "line" !== p.type && "stepLine" !== p.type && "spline" !== p.type && "scatter" !== p.type && "bubble" !== p.type || !p.markerType ? "error" === p.type && p._linkedSeries ? p._linkedSeries.legendMarkerType ? p._linkedSeries.legendMarkerType : P.getDefaultLegendMarker(p._linkedSeries.type) : P.getDefaultLegendMarker(p.type) : p.markerType, g = p.legendText ? p.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options, dataSeries: p, dataPoint: null }) : p.name, u3 = p.legendMarkerColor = p.legendMarkerColor ? p.legendMarkerColor : p.markerColor ? p.markerColor : "error" === p.type ? f2(p.whiskerColor) ? p._colorSet[0] : p.whiskerColor : p._colorSet[0], r2 = p.markerSize || "line" !== p.type && "stepLine" !== p.type && "spline" !== p.type ? 0.75 * this.lineHeight : 0, v2 = p.legendMarkerBorderColor ? p.legendMarkerBorderColor : p.markerBorderColor, t = p.legendMarkerBorderThickness ? p.legendMarkerBorderThickness : p.markerBorderThickness ? Math.max(1, Math.round(0.2 * r2)) : 0;
                "error" === p.type && this.errorMarkerColor.push(u3);
                g = this.chart.replaceKeywordsWithValue(g, p.dataPoints[0], p, n);
                q = {
                  markerType: q,
                  markerColor: u3,
                  text: g,
                  textBlock: null,
                  chartType: p.type,
                  markerSize: r2,
                  lineColor: p._colorSet[0],
                  dataSeriesIndex: p.index,
                  dataPointIndex: null,
                  markerBorderColor: v2,
                  markerBorderThickness: t
                };
                s2.push(q);
              } else
                for (var w2 = 0; w2 < p.dataPoints.length; w2++) {
                  var y2 = p.dataPoints[w2], q = y2.legendMarkerType ? y2.legendMarkerType : p.legendMarkerType ? p.legendMarkerType : P.getDefaultLegendMarker(p.type), g = y2.legendText ? y2.legendText : p.legendText ? p.legendText : this.itemTextFormatter ? this.itemTextFormatter({
                    chart: this.chart,
                    legend: this.options,
                    dataSeries: p,
                    dataPoint: y2
                  }) : y2.name ? y2.name : "DataPoint: " + (w2 + 1), u3 = y2.legendMarkerColor ? y2.legendMarkerColor : p.legendMarkerColor ? p.legendMarkerColor : y2.color ? y2.color : p.color ? p.color : p._colorSet[w2 % p._colorSet.length], r2 = 0.75 * this.lineHeight, v2 = y2.legendMarkerBorderColor ? y2.legendMarkerBorderColor : p.legendMarkerBorderColor ? p.legendMarkerBorderColor : y2.markerBorderColor ? y2.markerBorderColor : p.markerBorderColor, t = y2.legendMarkerBorderThickness ? y2.legendMarkerBorderThickness : p.legendMarkerBorderThickness ? p.legendMarkerBorderThickness : y2.markerBorderThickness || p.markerBorderThickness ? Math.max(1, Math.round(0.2 * r2)) : 0, g = this.chart.replaceKeywordsWithValue(g, y2, p, w2), q = { markerType: q, markerColor: u3, text: g, textBlock: null, chartType: p.type, markerSize: r2, dataSeriesIndex: n, dataPointIndex: w2, markerBorderColor: v2, markerBorderThickness: t };
                  (y2.showInLegend || p.showInLegend && false !== y2.showInLegend) && s2.push(q);
                }
          }
          true === this.reversed && s2.reverse();
          if (0 < s2.length) {
            p = null;
            g = y2 = w2 = 0;
            y2 = null !== this.itemWidth ? null !== this.itemMaxWidth ? Math.min(
              this.itemWidth,
              this.itemMaxWidth,
              l2
            ) : this.itemMaxWidth = Math.min(this.itemWidth, l2) : null !== this.itemMaxWidth ? Math.min(this.itemMaxWidth, l2) : this.itemMaxWidth = l2;
            r2 = 0 === r2 ? 0.75 * this.lineHeight : r2;
            y2 = (this.itemMaxWidth ? this.itemMaxWidth : y2) - (r2 + k3);
            for (n = 0; n < s2.length; n++) {
              q = s2[n];
              u3 = y2;
              if ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType)
                u3 -= 2 * 0.1 * this.lineHeight;
              if (!(0 >= d3 || "undefined" === typeof d3 || 0 >= u3 || "undefined" === typeof u3))
                if ("horizontal" === this.orientation) {
                  q.textBlock = new ma(this.ctx, { x: 0, y: 0, maxWidth: u3, maxHeight: this.itemWrap ? d3 : this.lineHeight, angle: 0, text: q.text, horizontalAlign: "left", fontSize: this.fontSize, fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontColor: this.fontColor, fontStyle: this.fontStyle, textBaseline: "middle" });
                  q.textBlock.measureText();
                  null !== this.itemWidth && (q.textBlock.width = this.itemWidth - (r2 + k3 + ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType ? 2 * 0.1 * this.lineHeight : 0)));
                  if (!p || p.width + Math.round(q.textBlock.width + r2 + k3 + (0 === p.width ? 0 : this.horizontalSpacing) + ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType ? 2 * 0.1 * this.lineHeight : 0)) > l2)
                    p = { items: [], width: 0 }, m.push(p), this.height += g, g = 0;
                  g = Math.max(g, q.textBlock.height ? q.textBlock.height : this.lineHeight);
                  q.textBlock.x = p.width;
                  q.textBlock.y = 0;
                  p.width += Math.round(q.textBlock.width + r2 + k3 + (0 === p.width ? 0 : this.horizontalSpacing) + ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType ? 2 * 0.1 * this.lineHeight : 0));
                  p.items.push(q);
                  this.width = Math.max(p.width, this.width);
                } else
                  q.textBlock = new ma(
                    this.ctx,
                    { x: 0, y: 0, maxWidth: y2, maxHeight: true === this.itemWrap ? d3 : 1.5 * this.fontSize, angle: 0, text: q.text, horizontalAlign: "left", fontSize: this.fontSize, fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontColor: this.fontColor, fontStyle: this.fontStyle, textBaseline: "middle" }
                  ), q.textBlock.measureText(), null !== this.itemWidth && (q.textBlock.width = this.itemWidth - (r2 + k3 + ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType ? 2 * 0.1 * this.lineHeight : 0))), this.height < d3 - this.lineHeight ? (p = { items: [], width: 0 }, m.push(p)) : (p = m[w2], w2 = (w2 + 1) % m.length), p && (this.height += q.textBlock.height ? q.textBlock.height : this.lineHeight, q.textBlock.x = p.width, q.textBlock.y = 0, p.width += Math.round(q.textBlock.width + r2 + k3 + (0 === p.width ? 0 : this.horizontalSpacing) + ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType ? 2 * 0.1 * this.lineHeight : 0)), p.items.push(q), this.width = Math.max(p.width, this.width));
            }
            this.height = false === this.itemWrap ? m.length * this.lineHeight : this.height + g;
            this.height = Math.min(d3, this.height);
            this.width = Math.min(
              l2,
              this.width
            );
          }
          "top" === this.verticalAlign ? (e = "left" === this.horizontalAlign ? h2.x1 : "right" === this.horizontalAlign ? h2.x2 - this.width : h2.x1 + h2.width / 2 - this.width / 2, b = h2.y1) : "center" === this.verticalAlign ? (e = "left" === this.horizontalAlign ? h2.x1 : "right" === this.horizontalAlign ? h2.x2 - this.width : h2.x1 + h2.width / 2 - this.width / 2, b = h2.y1 + h2.height / 2 - this.height / 2) : "bottom" === this.verticalAlign && (e = "left" === this.horizontalAlign ? h2.x1 : "right" === this.horizontalAlign ? h2.x2 - this.width : h2.x1 + h2.width / 2 - this.width / 2, b = h2.y2 - this.height);
          this.items = s2;
          for (n = 0; n < this.items.length; n++)
            q = s2[n], q.id = ++this.chart._eventManager.lastObjectId, this.chart._eventManager.objectMap[q.id] = { id: q.id, objectType: "legendItem", legendItemIndex: n, dataSeriesIndex: q.dataSeriesIndex, dataPointIndex: q.dataPointIndex };
          this.markerSize = r2;
          this.rows = m;
          0 < s2.length && a.layoutManager.registerSpace(c2, { width: this.width + 2 + 2, height: this.height + 5 + 5 });
          this.bounds = { x1: e, y1: b, x2: e + this.width, y2: b + this.height };
        };
        L2.prototype.render = function() {
          var a = this.bounds.x1, h2 = this.bounds.y1, c2 = this.markerMargin, b = this.maxWidth, e = this.maxHeight, l2 = this.markerSize, d3 = this.rows;
          (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(a, h2, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);
          for (var f3 = 0, k3 = 0; k3 < d3.length; k3++) {
            for (var m = d3[k3], n = 0, p = 0; p < m.items.length; p++) {
              var q = m.items[p], g = q.textBlock.x + a + (0 === p ? 0.2 * l2 : this.horizontalSpacing), s2 = h2 + f3, u3 = g;
              this.chart.data[q.dataSeriesIndex].visible || (this.ctx.globalAlpha = 0.5);
              this.ctx.save();
              this.ctx.beginPath();
              this.ctx.rect(a, h2, b, Math.max(e - e % this.lineHeight, 0));
              this.ctx.clip();
              if ("line" === q.chartType || "stepLine" === q.chartType || "spline" === q.chartType)
                this.ctx.strokeStyle = q.lineColor, this.ctx.lineWidth = Math.ceil(this.lineHeight / 8), this.ctx.beginPath(), this.ctx.moveTo(g - 0.1 * this.lineHeight, s2 + this.lineHeight / 2), this.ctx.lineTo(g + 0.85 * this.lineHeight, s2 + this.lineHeight / 2), this.ctx.stroke(), u3 -= 0.1 * this.lineHeight;
              if ("error" === q.chartType) {
                this.ctx.strokeStyle = this.errorMarkerColor[0];
                this.ctx.lineWidth = l2 / 8;
                this.ctx.beginPath();
                var r2 = g - 0.08 * this.lineHeight + 0.1 * this.lineHeight, t = s2 + 0.15 * this.lineHeight, w2 = 0.7 * this.lineHeight, y2 = w2 + 0.02 * this.lineHeight;
                this.ctx.moveTo(r2, t);
                this.ctx.lineTo(r2 + w2, t);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(r2 + w2 / 2, t);
                this.ctx.lineTo(r2 + w2 / 2, t + y2);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(r2, t + y2);
                this.ctx.lineTo(r2 + w2, t + y2);
                this.ctx.stroke();
                this.errorMarkerColor.shift();
              }
              v.drawMarker(g + l2 / 2, s2 + this.lineHeight / 2, this.ctx, q.markerType, "error" === q.chartType || "line" === q.chartType || "spline" === q.chartType ? q.markerSize / 2 : q.markerSize, q.markerColor, q.markerBorderColor, q.markerBorderThickness);
              q.textBlock.x = g + c2 + l2;
              if ("line" === q.chartType || "stepLine" === q.chartType || "spline" === q.chartType)
                q.textBlock.x += 0.1 * this.lineHeight;
              q.textBlock.y = Math.round(s2 + this.lineHeight / 2);
              q.textBlock.render(true);
              this.ctx.restore();
              n = 0 < p ? Math.max(n, q.textBlock.height ? q.textBlock.height : this.lineHeight) : q.textBlock.height ? q.textBlock.height : this.lineHeight;
              this.chart.data[q.dataSeriesIndex].visible || (this.ctx.globalAlpha = 1);
              g = V(q.id);
              this.ghostCtx.fillStyle = g;
              this.ghostCtx.beginPath();
              this.ghostCtx.fillRect(u3, q.textBlock.y - this.lineHeight / 2, q.textBlock.x + q.textBlock.width - u3, q.textBlock.height ? q.textBlock.height : this.lineHeight);
              q.x1 = this.chart._eventManager.objectMap[q.id].x1 = u3;
              q.y1 = this.chart._eventManager.objectMap[q.id].y1 = q.textBlock.y - this.lineHeight / 2;
              q.x2 = this.chart._eventManager.objectMap[q.id].x2 = q.textBlock.x + q.textBlock.width;
              q.y2 = this.chart._eventManager.objectMap[q.id].y2 = q.textBlock.y + (q.textBlock.height ? q.textBlock.height : this.lineHeight) - this.lineHeight / 2;
            }
            f3 += n;
          }
        };
        ga(P, $);
        P.prototype.getDefaultAxisPlacement = function() {
          var a = this.type;
          if ("column" === a || "line" === a || "stepLine" === a || "spline" === a || "area" === a || "stepArea" === a || "splineArea" === a || "stackedColumn" === a || "stackedLine" === a || "bubble" === a || "scatter" === a || "stackedArea" === a || "stackedColumn100" === a || "stackedLine100" === a || "stackedArea100" === a || "candlestick" === a || "ohlc" === a || "rangeColumn" === a || "rangeArea" === a || "rangeSplineArea" === a || "boxAndWhisker" === a || "waterfall" === a)
            return "normal";
          if ("bar" === a || "stackedBar" === a || "stackedBar100" === a || "rangeBar" === a)
            return "xySwapped";
          if ("pie" === a || "doughnut" === a || "funnel" === a || "pyramid" === a)
            return "none";
          "error" !== a && window.console.log("Unknown Chart Type: " + a);
          return null;
        };
        P.getDefaultLegendMarker = function(a) {
          if ("column" === a || "stackedColumn" === a || "stackedLine" === a || "bar" === a || "stackedBar" === a || "stackedBar100" === a || "bubble" === a || "scatter" === a || "stackedColumn100" === a || "stackedLine100" === a || "stepArea" === a || "candlestick" === a || "ohlc" === a || "rangeColumn" === a || "rangeBar" === a || "rangeArea" === a || "rangeSplineArea" === a || "boxAndWhisker" === a || "waterfall" === a)
            return "square";
          if ("line" === a || "stepLine" === a || "spline" === a || "pie" === a || "doughnut" === a)
            return "circle";
          if ("area" === a || "splineArea" === a || "stackedArea" === a || "stackedArea100" === a || "funnel" === a || "pyramid" === a)
            return "triangle";
          if ("error" === a)
            return "none";
          window.console.log("Unknown Chart Type: " + a);
          return null;
        };
        P.prototype.getDataPointAtX = function(a, h2) {
          if (!this.dataPoints || 0 === this.dataPoints.length)
            return null;
          var c2 = { dataPoint: null, distance: Infinity, index: NaN }, b = null, e = 0, l2 = 0, d3 = 1, f3 = Infinity, k3 = 0, m = 0, n = 0;
          "none" !== this.chart.plotInfo.axisPlacement && (this.axisX.logarithmic ? (n = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), n = 1 < n ? Math.min(Math.max((this.dataPoints.length - 1) / n * Math.log(a / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0) : (n = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, n = 0 < n ? Math.min(Math.max((this.dataPoints.length - 1) / n * (a - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0));
          for (; ; ) {
            l2 = 0 < d3 ? n + e : n - e;
            if (0 <= l2 && l2 < this.dataPoints.length) {
              var b = this.dataPoints[l2], p = this.axisX.logarithmic ? b.x > a ? b.x / a : a / b.x : Math.abs(b.x - a);
              p < c2.distance && (c2.dataPoint = b, c2.distance = p, c2.index = l2);
              b = p;
              b <= f3 ? f3 = b : 0 < d3 ? k3++ : m++;
              if (1e3 < k3 && 1e3 < m)
                break;
            } else if (0 > n - e && n + e >= this.dataPoints.length)
              break;
            -1 === d3 ? (e++, d3 = 1) : d3 = -1;
          }
          return h2 || (c2.dataPoint.x.getTime ? c2.dataPoint.x.getTime() : c2.dataPoint.x) !== (a.getTime ? a.getTime() : a) ? h2 && null !== c2.dataPoint ? c2 : null : c2;
        };
        P.prototype.getDataPointAtXY = function(a, h2, c2) {
          if (!this.dataPoints || 0 === this.dataPoints.length || a < this.chart.plotArea.x1 || a > this.chart.plotArea.x2 || h2 < this.chart.plotArea.y1 || h2 > this.chart.plotArea.y2)
            return null;
          c2 = c2 || false;
          var b = [], e = 0, l2 = 0, d3 = 1, k3 = false, s2 = Infinity, m = 0, n = 0, p = 0;
          if ("none" !== this.chart.plotInfo.axisPlacement)
            if (p = (this.chart.axisX[0] ? this.chart.axisX[0] : this.chart.axisX2[0]).getXValueAt({ x: a, y: h2 }), this.axisX.logarithmic)
              var q = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), p = 1 < q ? Math.min(Math.max((this.dataPoints.length - 1) / q * Math.log(p / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;
            else
              q = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, p = 0 < q ? Math.min(Math.max((this.dataPoints.length - 1) / q * (p - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;
          for (; ; ) {
            l2 = 0 < d3 ? p + e : p - e;
            if (0 <= l2 && l2 < this.dataPoints.length) {
              var q = this.chart._eventManager.objectMap[this.dataPointIds[l2]], g = this.dataPoints[l2], u3 = null;
              if (q) {
                switch (this.type) {
                  case "column":
                  case "stackedColumn":
                  case "stackedColumn100":
                  case "bar":
                  case "stackedBar":
                  case "stackedBar100":
                  case "rangeColumn":
                  case "rangeBar":
                  case "waterfall":
                  case "error":
                    a >= q.x1 && (a <= q.x2 && h2 >= q.y1 && h2 <= q.y2) && (b.push({ dataPoint: g, dataPointIndex: l2, dataSeries: this, distance: Math.min(Math.abs(q.x1 - a), Math.abs(q.x2 - a), Math.abs(q.y1 - h2), Math.abs(q.y2 - h2)) }), k3 = true);
                    break;
                  case "line":
                  case "stepLine":
                  case "spline":
                  case "area":
                  case "stepArea":
                  case "stackedArea":
                  case "stackedArea100":
                  case "splineArea":
                  case "scatter":
                    var r2 = qa("markerSize", g, this) || 4, v2 = c2 ? 20 : r2, u3 = Math.sqrt(Math.pow(q.x1 - a, 2) + Math.pow(q.y1 - h2, 2));
                    u3 <= v2 && b.push({ dataPoint: g, dataPointIndex: l2, dataSeries: this, distance: u3 });
                    q = Math.abs(q.x1 - a);
                    q <= s2 ? s2 = q : 0 < d3 ? m++ : n++;
                    u3 <= r2 / 2 && (k3 = true);
                    break;
                  case "rangeArea":
                  case "rangeSplineArea":
                    r2 = qa("markerSize", g, this) || 4;
                    v2 = c2 ? 20 : r2;
                    u3 = Math.min(Math.sqrt(Math.pow(q.x1 - a, 2) + Math.pow(q.y1 - h2, 2)), Math.sqrt(Math.pow(q.x1 - a, 2) + Math.pow(q.y2 - h2, 2)));
                    u3 <= v2 && b.push({ dataPoint: g, dataPointIndex: l2, dataSeries: this, distance: u3 });
                    q = Math.abs(q.x1 - a);
                    q <= s2 ? s2 = q : 0 < d3 ? m++ : n++;
                    u3 <= r2 / 2 && (k3 = true);
                    break;
                  case "bubble":
                    r2 = q.size;
                    u3 = Math.sqrt(Math.pow(q.x1 - a, 2) + Math.pow(q.y1 - h2, 2));
                    u3 <= r2 / 2 && (b.push({
                      dataPoint: g,
                      dataPointIndex: l2,
                      dataSeries: this,
                      distance: u3
                    }), k3 = true);
                    break;
                  case "pie":
                  case "doughnut":
                    r2 = q.center;
                    v2 = "doughnut" === this.type ? q.percentInnerRadius * q.radius : 0;
                    u3 = Math.sqrt(Math.pow(r2.x - a, 2) + Math.pow(r2.y - h2, 2));
                    u3 < q.radius && u3 > v2 && (u3 = Math.atan2(h2 - r2.y, a - r2.x), 0 > u3 && (u3 += 2 * Math.PI), u3 = Number(((180 * (u3 / Math.PI) % 360 + 360) % 360).toFixed(12)), r2 = Number(((180 * (q.startAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), v2 = Number(((180 * (q.endAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), 0 === v2 && 1 < q.endAngle && (v2 = 360), r2 >= v2 && (0 !== g.y && !f2(g.y)) && (v2 += 360, u3 < r2 && (u3 += 360)), u3 > r2 && u3 < v2 && (b.push({ dataPoint: g, dataPointIndex: l2, dataSeries: this, distance: 0 }), k3 = true));
                    break;
                  case "funnel":
                  case "pyramid":
                    u3 = q.funnelSection;
                    h2 > u3.y1 && h2 < u3.y4 && (u3.y6 ? h2 > u3.y6 ? (l2 = u3.x6 + (u3.x5 - u3.x6) / (u3.y5 - u3.y6) * (h2 - u3.y6), u3 = u3.x3 + (u3.x4 - u3.x3) / (u3.y4 - u3.y3) * (h2 - u3.y3)) : (l2 = u3.x1 + (u3.x6 - u3.x1) / (u3.y6 - u3.y1) * (h2 - u3.y1), u3 = u3.x2 + (u3.x3 - u3.x2) / (u3.y3 - u3.y2) * (h2 - u3.y2)) : (l2 = u3.x1 + (u3.x4 - u3.x1) / (u3.y4 - u3.y1) * (h2 - u3.y1), u3 = u3.x2 + (u3.x3 - u3.x2) / (u3.y3 - u3.y2) * (h2 - u3.y2)), a > l2 && a < u3 && (b.push({ dataPoint: g, dataPointIndex: q.dataPointIndex, dataSeries: this, distance: 0 }), k3 = true));
                    break;
                  case "boxAndWhisker":
                    if (a >= q.x1 - q.borderThickness / 2 && a <= q.x2 + q.borderThickness / 2 && h2 >= q.y4 - q.borderThickness / 2 && h2 <= q.y1 + q.borderThickness / 2 || Math.abs(q.x2 - a + q.x1 - a) < q.borderThickness && h2 >= q.y1 && h2 <= q.y4)
                      b.push({ dataPoint: g, dataPointIndex: l2, dataSeries: this, distance: Math.min(Math.abs(q.x1 - a), Math.abs(q.x2 - a), Math.abs(q.y2 - h2), Math.abs(q.y3 - h2)) }), k3 = true;
                    break;
                  case "candlestick":
                    if (a >= q.x1 - q.borderThickness / 2 && a <= q.x2 + q.borderThickness / 2 && h2 >= q.y2 - q.borderThickness / 2 && h2 <= q.y3 + q.borderThickness / 2 || Math.abs(q.x2 - a + q.x1 - a) < q.borderThickness && h2 >= q.y1 && h2 <= q.y4)
                      b.push({ dataPoint: g, dataPointIndex: l2, dataSeries: this, distance: Math.min(Math.abs(q.x1 - a), Math.abs(q.x2 - a), Math.abs(q.y2 - h2), Math.abs(q.y3 - h2)) }), k3 = true;
                    break;
                  case "ohlc":
                    if (Math.abs(q.x2 - a + q.x1 - a) < q.borderThickness && h2 >= q.y2 && h2 <= q.y3 || a >= q.x1 && a <= (q.x2 + q.x1) / 2 && h2 >= q.y1 - q.borderThickness / 2 && h2 <= q.y1 + q.borderThickness / 2 || a >= (q.x1 + q.x2) / 2 && a <= q.x2 && h2 >= q.y4 - q.borderThickness / 2 && h2 <= q.y4 + q.borderThickness / 2)
                      b.push({ dataPoint: g, dataPointIndex: l2, dataSeries: this, distance: Math.min(Math.abs(q.x1 - a), Math.abs(q.x2 - a), Math.abs(q.y2 - h2), Math.abs(q.y3 - h2)) }), k3 = true;
                }
                if (k3 || 1e3 < m && 1e3 < n)
                  break;
              }
            } else if (0 > p - e && p + e >= this.dataPoints.length)
              break;
            -1 === d3 ? (e++, d3 = 1) : d3 = -1;
          }
          a = null;
          for (h2 = 0; h2 < b.length; h2++)
            a ? b[h2].distance <= a.distance && (a = b[h2]) : a = b[h2];
          return a;
        };
        P.prototype.getMarkerProperties = function(a, h2, c2, b) {
          var e = this.dataPoints, l2 = e[a].markerColor ? e[a].markerColor : this.markerColor ? this.markerColor : e[a].color ? e[a].color : this.color ? this.color : this._colorSet[a % this._colorSet.length], d3 = e[a].markerBorderColor ? e[a].markerBorderColor : this.markerBorderColor ? this.markerBorderColor : null, k3 = f2(e[a].markerBorderThickness) ? this.markerBorderThickness ? this.markerBorderThickness : null : e[a].markerBorderThickness, u3 = e[a].markerType ? e[a].markerType : this.markerType;
          a = f2(e[a].markerSize) ? this.markerSize : e[a].markerSize;
          return { x: h2, y: c2, ctx: b, type: u3, size: a, color: l2, borderColor: d3, borderThickness: k3 };
        };
        ga(A, $);
        A.prototype.createExtraLabelsForLog = function(a) {
          a = (a || 0) + 1;
          if (!(5 < a)) {
            var h2 = this.logLabelValues[0] || this.intervalStartPosition;
            if (Math.log(this.range) / Math.log(h2 / this.viewportMinimum) < this.noTicks - 1) {
              for (var c2 = A.getNiceNumber((h2 - this.viewportMinimum) / Math.min(Math.max(2, this.noTicks - this.logLabelValues.length), 3), true), b = Math.ceil(this.viewportMinimum / c2) * c2; b < h2; b += c2)
                b < this.viewportMinimum || this.logLabelValues.push(b);
              this.logLabelValues.sort(Ya);
              this.createExtraLabelsForLog(a);
            }
          }
        };
        A.prototype.createLabels = function() {
          var a, h2, c2 = 0, b = 0, e, l2 = 0, d3 = 0, b = 0, b = this.interval, k3 = 0, u3, m = 0.6 * this.chart.height, n;
          a = false;
          var p = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], q = p.length ? f2(this.scaleBreaks.firstBreakIndex) ? 0 : this.scaleBreaks.firstBreakIndex : 0;
          if ("axisX" !== this.type || "dateTime" !== this.valueType || this.logarithmic) {
            e = this.viewportMaximum;
            if (this.labels) {
              a = Math.ceil(b);
              for (var b = Math.ceil(this.intervalStartPosition), g = false, c2 = b; c2 < this.viewportMaximum; c2 += a)
                if (this.labels[c2])
                  g = true;
                else {
                  g = false;
                  break;
                }
              g && (this.interval = a, this.intervalStartPosition = b);
            }
            if (this.logarithmic && !this.equidistantInterval)
              for (this.logLabelValues || (this.logLabelValues = [], this.createExtraLabelsForLog()), b = 0, g = q; b < this.logLabelValues.length; b++)
                if (c2 = this.logLabelValues[b], c2 < this.viewportMinimum)
                  b++;
                else {
                  for (; g < p.length && c2 > p[g].endValue; g++)
                    ;
                  a = g < p.length && c2 >= p[g].startValue && c2 <= p[g].endValue;
                  n = c2;
                  a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: n, label: this.labels[n] ? this.labels[n] : null }) : "axisX" === this.type && this.labels[n] ? this.labels[n] : da(n, this.valueFormatString, this.chart._cultureInfo), a = new ma(this.ctx, {
                    x: 0,
                    y: 0,
                    maxWidth: l2,
                    maxHeight: d3,
                    angle: this.labelAngle,
                    text: this.prefix + a + this.suffix,
                    backgroundColor: this.labelBackgroundColor,
                    borderColor: this.labelBorderColor,
                    cornerRadius: this.labelCornerRadius,
                    textAlign: this.labelTextAlign,
                    fontSize: this.labelFontSize,
                    fontFamily: this.labelFontFamily,
                    fontWeight: this.labelFontWeight,
                    fontColor: this.labelFontColor,
                    fontStyle: this.labelFontStyle,
                    textBaseline: "middle",
                    borderThickness: 0
                  }), this._labels.push({ position: n, textBlock: a, effectiveHeight: null }));
                }
            g = q;
            for (c2 = this.intervalStartPosition; c2 <= e; c2 = parseFloat(1e-12 > this.interval ? this.logarithmic && this.equidistantInterval ? c2 * Math.pow(this.logarithmBase, this.interval) : c2 + this.interval : (this.logarithmic && this.equidistantInterval ? c2 * Math.pow(this.logarithmBase, this.interval) : c2 + this.interval).toFixed(12))) {
              for (; g < p.length && c2 > p[g].endValue; g++)
                ;
              a = g < p.length && c2 >= p[g].startValue && c2 <= p[g].endValue;
              n = c2;
              a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: n, label: this.labels[n] ? this.labels[n] : null }) : "axisX" === this.type && this.labels[n] ? this.labels[n] : da(n, this.valueFormatString, this.chart._cultureInfo), a = new ma(this.ctx, { x: 0, y: 0, maxWidth: l2, maxHeight: d3, angle: this.labelAngle, text: this.prefix + a + this.suffix, textAlign: this.labelTextAlign, backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: "middle" }), this._labels.push({ position: n, textBlock: a, effectiveHeight: null }));
            }
          } else
            for (this.intervalStartPosition = this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval), e = cb(new Date(this.viewportMaximum), this.interval, this.intervalType), g = q, c2 = this.intervalStartPosition; c2 < e; cb(c2, b, this.intervalType)) {
              for (a = c2.getTime(); g < p.length && a > p[g].endValue; g++)
                ;
              n = a;
              a = g < p.length && a >= p[g].startValue && a <= p[g].endValue;
              a || (a = this.labelFormatter ? this.labelFormatter({
                chart: this.chart,
                axis: this.options,
                value: new Date(n),
                label: this.labels[n] ? this.labels[n] : null
              }) : "axisX" === this.type && this.labels[n] ? this.labels[n] : ea(n, this.valueFormatString, this.chart._cultureInfo), a = new ma(this.ctx, {
                x: 0,
                y: 0,
                maxWidth: l2,
                backgroundColor: this.labelBackgroundColor,
                borderColor: this.labelBorderColor,
                borderThickness: this.labelBorderThickness,
                cornerRadius: this.labelCornerRadius,
                maxHeight: d3,
                angle: this.labelAngle,
                text: this.prefix + a + this.suffix,
                textAlign: this.labelTextAlign,
                fontSize: this.labelFontSize,
                fontFamily: this.labelFontFamily,
                fontWeight: this.labelFontWeight,
                fontColor: this.labelFontColor,
                fontStyle: this.labelFontStyle,
                textBaseline: "middle"
              }), this._labels.push({ position: n, textBlock: a, effectiveHeight: null, breaksLabelType: void 0 }));
            }
          if ("bottom" === this._position || "top" === this._position)
            k3 = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.width * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.width / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * aa[this.intervalType + "Duration"] * this.interval, l2 = "undefined" === typeof this.options.labelMaxWidth ? 0.5 * this.chart.width >> 0 : this.options.labelMaxWidth, this.chart.panEnabled || (d3 = "undefined" === typeof this.options.labelWrap || this.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize);
          else if ("left" === this._position || "right" === this._position)
            k3 = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.height * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.height / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * aa[this.intervalType + "Duration"] * this.interval, this.chart.panEnabled || (l2 = "undefined" === typeof this.options.labelMaxWidth ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth), d3 = "undefined" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize;
          for (b = 0; b < this._labels.length; b++) {
            a = this._labels[b].textBlock;
            a.maxWidth = l2;
            a.maxHeight = d3;
            var s2 = a.measureText();
            u3 = s2.height;
          }
          e = [];
          q = p = 0;
          if (this.labelAutoFit || this.options.labelAutoFit) {
            if (f2(this.labelAngle) || (this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360)), "bottom" === this._position || "top" === this._position)
              if (l2 = 0.9 * k3 >> 0, q = 0, !this.chart.panEnabled && 1 <= this._labels.length) {
                this.sessionVariables.labelFontSize = this.labelFontSize;
                this.sessionVariables.labelMaxWidth = l2;
                this.sessionVariables.labelMaxHeight = d3;
                this.sessionVariables.labelAngle = this.labelAngle;
                this.sessionVariables.labelWrap = this.labelWrap;
                for (c2 = 0; c2 < this._labels.length; c2++)
                  if (!this._labels[c2].breaksLabelType) {
                    a = this._labels[c2].textBlock;
                    for (var v2, g = a.text.split(" "), b = 0; b < g.length; b++)
                      n = g[b], this.ctx.font = a.fontStyle + " " + a.fontWeight + " " + a.fontSize + "px " + a.fontFamily, n = this.ctx.measureText(n), n.width > q && (v2 = c2, q = n.width);
                  }
                c2 = 0;
                for (c2 = this.intervalStartPosition < this.viewportMinimum ? 1 : 0; c2 < this._labels.length; c2++)
                  if (!this._labels[c2].breaksLabelType) {
                    a = this._labels[c2].textBlock;
                    s2 = a.measureText();
                    for (g = c2 + 1; g < this._labels.length; g++)
                      if (!this._labels[g].breaksLabelType) {
                        h2 = this._labels[g].textBlock;
                        h2 = h2.measureText();
                        break;
                      }
                    e.push(a.height);
                    this.sessionVariables.labelMaxHeight = Math.max.apply(Math, e);
                    Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                    Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
                    b = l2 * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (d3 - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                    if (f2(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle)
                      if (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? d3 : Math.min((b - l2 * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), b), n = (m - (u3 + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(-25))) / Math.sin(Math.PI / 180 * Math.abs(-25)), !f2(this.options.labelWrap))
                        this.labelWrap ? f2(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = Math.min(Math.max(l2, q), n), this.sessionVariables.labelWrap = this.labelWrap, h2 && s2.width + h2.width >> 0 > 2 * l2 && (this.sessionVariables.labelAngle = -25)) : (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > l2 ? -25 : this.sessionVariables.labelAngle) : f2(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = d3, this.sessionVariables.labelMaxWidth = l2, h2 && s2.width + h2.width >> 0 > 2 * l2 && (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = n)) : (this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > l2 ? -25 : this.sessionVariables.labelAngle, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = d3, this.sessionVariables.labelWrap = this.labelWrap);
                      else {
                        if (f2(this.options.labelWrap)) {
                          if (!f2(this.options.labelMaxWidth))
                            this.options.labelMaxWidth < l2 ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = b) : (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = d3);
                          else if (!f2(h2)) {
                            if (b = s2.width + h2.width >> 0, g = this.labelFontSize, q < l2)
                              b - 2 * l2 > p && (p = b - 2 * l2, b >= 2 * l2 && b < 2.2 * l2 ? (this.sessionVariables.labelMaxWidth = l2, f2(this.options.labelFontSize) && 12 < g && (g = Math.floor(12 / 13 * g), a.measureText()), this.sessionVariables.labelFontSize = f2(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : b >= 2.2 * l2 && b < 2.8 * l2 ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = n, this.sessionVariables.labelFontSize = g) : b >= 2.8 * l2 && b < 3.2 * l2 ? (this.sessionVariables.labelMaxWidth = Math.max(l2, q), this.sessionVariables.labelWrap = true, f2(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = f2(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : b >= 3.2 * l2 && b < 3.6 * l2 ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelWrap = true, this.sessionVariables.labelMaxWidth = n, this.sessionVariables.labelFontSize = this.labelFontSize) : b > 3.6 * l2 && b < 5 * l2 ? (f2(this.options.labelFontSize) && 12 < g && (g = Math.floor(12 / 13 * g), a.measureText()), this.sessionVariables.labelFontSize = f2(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelWrap = true, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = n) : b > 5 * l2 && (this.sessionVariables.labelWrap = true, this.sessionVariables.labelMaxWidth = l2, this.sessionVariables.labelFontSize = g, this.sessionVariables.labelMaxHeight = d3, this.sessionVariables.labelAngle = this.labelAngle));
                            else if (v2 === c2 && (0 === v2 && q + this._labels[v2 + 1].textBlock.measureText().width - 2 * l2 > p || v2 === this._labels.length - 1 && q + this._labels[v2 - 1].textBlock.measureText().width - 2 * l2 > p || 0 < v2 && v2 < this._labels.length - 1 && q + this._labels[v2 + 1].textBlock.measureText().width - 2 * l2 > p && q + this._labels[v2 - 1].textBlock.measureText().width - 2 * l2 > p))
                              p = 0 === v2 ? q + this._labels[v2 + 1].textBlock.measureText().width - 2 * l2 : q + this._labels[v2 - 1].textBlock.measureText().width - 2 * l2, this.sessionVariables.labelFontSize = f2(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelWrap = true, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = n;
                            else if (0 === p)
                              for (this.sessionVariables.labelFontSize = f2(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelWrap = true, b = 0; b < this._labels.length; b++)
                                a = this._labels[b].textBlock, a.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(l2, q), n), s2 = a.measureText(), b < this._labels.length - 1 && (g = b + 1, h2 = this._labels[g].textBlock, h2.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(l2, q), n), h2 = h2.measureText(), s2.width + h2.width >> 0 > 2 * l2 && (this.sessionVariables.labelAngle = -25));
                          }
                        }
                      }
                    else
                      (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? d3 : Math.min((b - l2 * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), b), n = 0 != this.labelAngle ? (m - (u3 + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) : l2, this.sessionVariables.labelMaxHeight = this.labelWrap ? (m - n * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) : 1.5 * this.labelFontSize, f2(this.options.labelWrap)) ? f2(this.options.labelWrap) && (this.labelWrap && !f2(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : n, this.sessionVariables.labelMaxHeight = d3) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = n, this.sessionVariables.labelMaxHeight = b < 0.9 * k3 ? 0.9 * k3 : b, this.sessionVariables.labelWrap = this.labelWrap)) : (this.options.labelWrap ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : n) : (f2(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : n, this.sessionVariables.labelWrap = this.labelWrap), this.sessionVariables.labelMaxHeight = d3);
                  }
                for (b = 0; b < this._labels.length; b++)
                  a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();
              } else
                for (c2 = 0; c2 < this._labels.length; c2++)
                  a = this._labels[c2].textBlock, a.maxWidth = this.labelMaxWidth = f2(this.options.labelMaxWidth) ? f2(this.sessionVariables.labelMaxWidth) ? this.sessionVariables.labelMaxWidth = l2 : this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, a.fontSize = this.labelFontSize = f2(this.options.labelFontSize) ? f2(this.sessionVariables.labelFontSize) ? this.sessionVariables.labelFontSize = this.labelFontSize : this.sessionVariables.labelFontSize : this.options.labelFontSize, a.angle = this.labelAngle = f2(this.options.labelAngle) ? f2(this.sessionVariables.labelAngle) ? this.sessionVariables.labelAngle = this.labelAngle : this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = f2(this.options.labelWrap) ? f2(this.sessionVariables.labelWrap) ? this.sessionVariables.labelWrap = this.labelWrap : this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = f2(this.sessionVariables.labelMaxHeight) ? this.sessionVariables.labelMaxHeight = d3 : this.sessionVariables.labelMaxHeight, a.measureText();
            else if ("left" === this._position || "right" === this._position)
              if (l2 = f2(this.options.labelMaxWidth) ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth, d3 = "undefined" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize, !this.chart.panEnabled && 1 <= this._labels.length) {
                this.sessionVariables.labelFontSize = this.labelFontSize;
                this.sessionVariables.labelMaxWidth = l2;
                this.sessionVariables.labelMaxHeight = d3;
                this.sessionVariables.labelAngle = f2(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;
                this.sessionVariables.labelWrap = this.labelWrap;
                for (c2 = 0; c2 < this._labels.length; c2++)
                  if (!this._labels[c2].breaksLabelType) {
                    a = this._labels[c2].textBlock;
                    s2 = a.measureText();
                    for (g = c2 + 1; g < this._labels.length; g++)
                      if (!this._labels[g].breaksLabelType) {
                        h2 = this._labels[g].textBlock;
                        h2 = h2.measureText();
                        break;
                      }
                    e.push(a.height);
                    this.sessionVariables.labelMaxHeight = Math.max.apply(Math, e);
                    b = l2 * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (d3 - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                    Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                    Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
                    f2(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle ? f2(this.options.labelWrap) ? f2(this.options.labelWrap) && (f2(this.options.labelMaxWidth) ? f2(h2) || (k3 = s2.height + h2.height >> 0, k3 - 2 * d3 > q && (q = k3 - 2 * d3, k3 >= 2 * d3 && k3 < 2.4 * d3 ? (f2(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelMaxHeight = d3, this.sessionVariables.labelFontSize = f2(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize) : k3 >= 2.4 * d3 && k3 < 2.8 * d3 ? (this.sessionVariables.labelMaxHeight = b, this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelWrap = true) : k3 >= 2.8 * d3 && k3 < 3.2 * d3 ? (this.sessionVariables.labelMaxHeight = d3, this.sessionVariables.labelWrap = true, f2(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = f2(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelAngle = f2(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : k3 >= 3.2 * d3 && k3 < 3.6 * d3 ? (this.sessionVariables.labelMaxHeight = b, this.sessionVariables.labelWrap = true, this.sessionVariables.labelFontSize = this.labelFontSize) : k3 > 3.6 * d3 && k3 < 10 * d3 ? (f2(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = f2(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxWidth = l2, this.sessionVariables.labelMaxHeight = d3, this.sessionVariables.labelAngle = f2(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : k3 > 10 * d3 && k3 < 50 * d3 && (f2(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = f2(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxHeight = d3, this.sessionVariables.labelMaxWidth = l2, this.sessionVariables.labelAngle = f2(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle))) : (this.sessionVariables.labelMaxHeight = d3, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth)) : (this.sessionVariables.labelMaxWidth = this.labelWrap ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : this.labelMaxWidth ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : l2, this.sessionVariables.labelMaxHeight = d3) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = 0 === this.labelAngle ? l2 : Math.min(
                      (b - d3 * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)),
                      d3
                    ), f2(this.options.labelWrap)) ? f2(this.options.labelWrap) && (this.labelWrap && !f2(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = b) : (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : l2, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? d3 : b, f2(this.options.labelMaxWidth) && (this.sessionVariables.labelAngle = this.labelAngle))) : this.options.labelWrap ? (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? d3 : b, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = l2) : (this.sessionVariables.labelMaxHeight = d3, f2(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap);
                  }
                for (b = 0; b < this._labels.length; b++)
                  a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();
              } else
                for (c2 = 0; c2 < this._labels.length; c2++)
                  a = this._labels[c2].textBlock, a.maxWidth = this.labelMaxWidth = f2(this.options.labelMaxWidth) ? f2(this.sessionVariables.labelMaxWidth) ? this.sessionVariables.labelMaxWidth = l2 : this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, a.fontSize = this.labelFontSize = f2(this.options.labelFontSize) ? f2(this.sessionVariables.labelFontSize) ? this.sessionVariables.labelFontSize = this.labelFontSize : this.sessionVariables.labelFontSize : this.options.labelFontSize, a.angle = this.labelAngle = f2(this.options.labelAngle) ? f2(this.sessionVariables.labelAngle) ? this.sessionVariables.labelAngle = this.labelAngle : this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = f2(this.options.labelWrap) ? f2(this.sessionVariables.labelWrap) ? this.sessionVariables.labelWrap = this.labelWrap : this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = f2(this.sessionVariables.labelMaxHeight) ? this.sessionVariables.labelMaxHeight = d3 : this.sessionVariables.labelMaxHeight, a.measureText();
          }
          for (c2 = 0; c2 < this.stripLines.length; c2++) {
            var l2 = this.stripLines[c2], w2;
            if ("outside" === l2.labelPlacement) {
              d3 = this.sessionVariables.labelMaxWidth;
              if ("bottom" === this._position || "top" === this._position)
                f2(l2.options.labelWrap) && !f2(this.sessionVariables.stripLineLabelMaxHeight) ? w2 = this.sessionVariables.stripLineLabelMaxHeight : this.sessionVariables.stripLineLabelMaxHeight = w2 = l2.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize;
              if ("left" === this._position || "right" === this._position)
                f2(l2.options.labelWrap) && !f2(this.sessionVariables.stripLineLabelMaxHeight) ? w2 = this.sessionVariables.stripLineLabelMaxHeight : this.sessionVariables.stripLineLabelMaxHeight = w2 = l2.labelWrap ? 0.8 * this.chart.width >> 0 : 1.5 * this.labelFontSize;
              f2(l2.labelBackgroundColor) && (l2.labelBackgroundColor = "#EEEEEE");
            } else
              d3 = "bottom" === this._position || "top" === this._position ? 0.9 * this.chart.width >> 0 : 0.9 * this.chart.height >> 0, w2 = f2(l2.options.labelWrap) || l2.labelWrap ? "bottom" === this._position || "top" === this._position ? 0.8 * this.chart.width >> 0 : 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize, f2(l2.labelBackgroundColor) && (f2(l2.startValue) && 0 !== l2.startValue ? l2.labelBackgroundColor = r ? "transparent" : null : l2.labelBackgroundColor = "#EEEEEE");
            a = new ma(this.ctx, {
              x: 0,
              y: 0,
              backgroundColor: l2.labelBackgroundColor,
              borderColor: l2.labelBorderColor,
              borderThickness: l2.labelBorderThickness,
              cornerRadius: l2.labelCornerRadius,
              maxWidth: l2.options.labelMaxWidth ? l2.options.labelMaxWidth : d3,
              maxHeight: w2,
              angle: this.labelAngle,
              text: l2.labelFormatter ? l2.labelFormatter({ chart: this.chart, axis: this, stripLine: l2 }) : l2.label,
              textAlign: this.labelTextAlign,
              fontSize: "outside" === l2.labelPlacement ? l2.options.labelFontSize ? l2.labelFontSize : this.labelFontSize : l2.labelFontSize,
              fontFamily: "outside" === l2.labelPlacement ? l2.options.labelFontFamily ? l2.labelFontFamily : this.labelFontFamily : l2.labelFontFamily,
              fontWeight: "outside" === l2.labelPlacement ? l2.options.labelFontWeight ? l2.labelFontWeight : this.labelFontWeight : l2.labelFontWeight,
              fontColor: l2.labelFontColor || l2.color,
              fontStyle: "outside" === l2.labelPlacement ? l2.options.labelFontStyle ? l2.labelFontStyle : this.fontWeight : l2.labelFontStyle,
              textBaseline: "middle"
            });
            this._stripLineLabels.push({ position: l2.value, textBlock: a, effectiveHeight: null, stripLine: l2 });
          }
        };
        A.prototype.createLabelsAndCalculateWidth = function() {
          var a = 0, h2 = 0;
          this._labels = [];
          this._stripLineLabels = [];
          var c2 = this.chart.isNavigator ? 0 : 5;
          if ("left" === this._position || "right" === this._position) {
            this.createLabels();
            if ("inside" != this.labelPlacement || "inside" === this.labelPlacement && 0 < this._index)
              for (h2 = 0; h2 < this._labels.length; h2++) {
                var b = this._labels[h2].textBlock, e = b.measureText(), l2 = 0, l2 = 0 === this.labelAngle ? e.width : e.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - b.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
                a < l2 && (this.labelEffectiveWidth = a = l2);
                this._labels[h2].effectiveWidth = l2;
              }
            for (h2 = 0; h2 < this._stripLineLabels.length; h2++)
              "outside" === this._stripLineLabels[h2].stripLine.labelPlacement && (this._stripLineLabels[h2].stripLine.value >= this.viewportMinimum && this._stripLineLabels[h2].stripLine.value <= this.viewportMaximum) && (b = this._stripLineLabels[h2].textBlock, e = b.measureText(), l2 = 0 === this.labelAngle ? e.width : e.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - b.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), "inside" === this.tickPlacement && (l2 += this.tickLength), "inside" === this.labelPlacement && (a += 0 < this._index ? l2 : 0), a < l2 && (a = l2), this.stripLineLabelEffectiveWidth = this._stripLineLabels[h2].effectiveWidth = l2);
          }
          return (this.title ? this._titleTextBlock.measureText().height + 2 : 0) + a + ("inside" === this.tickPlacement ? 0 < this._index ? this.tickLength : 0 : this.tickLength) + c2;
        };
        A.prototype.createLabelsAndCalculateHeight = function() {
          var a = 0;
          this._labels = [];
          this._stripLineLabels = [];
          var h2, c2 = 0, b = this.chart.isNavigator ? 0 : 5;
          if ("bottom" === this._position || "top" === this._position) {
            this.createLabels();
            if ("inside" != this.labelPlacement || "inside" === this.labelPlacement && 0 < this._index)
              for (c2 = 0; c2 < this._labels.length; c2++) {
                h2 = this._labels[c2].textBlock;
                var e = h2.measureText(), l2 = 0, l2 = 0 === this.labelAngle ? e.height : e.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - h2.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                a < l2 && (this.labelEffectiveHeight = a = l2);
                this._labels[c2].effectiveHeight = l2;
              }
            for (c2 = 0; c2 < this._stripLineLabels.length; c2++)
              "outside" === this._stripLineLabels[c2].stripLine.labelPlacement && (this._stripLineLabels[c2].stripLine.value >= this.viewportMinimum && this._stripLineLabels[c2].stripLine.value <= this.viewportMaximum) && (h2 = this._stripLineLabels[c2].textBlock, e = h2.measureText(), l2 = 0 === this.labelAngle ? e.height : e.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - h2.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), "inside" === this.tickPlacement && (l2 += this.tickLength), "inside" === this.labelPlacement && (a += 0 < this._index ? l2 : 0), a < l2 && (a = l2), this.stripLineLabelEffectiveHeight = this._stripLineLabels[c2].effectiveHeight = l2);
          }
          return (this.title ? this._titleTextBlock.measureText().height + 2 : 0) + a + ("inside" === this.tickPlacement ? 0 < this._index ? this.tickLength : 0 : this.tickLength) + b;
        };
        A.setLayout = function(a, h2, c2, b, e, l2) {
          var d3, k3, u3, m, n = a[0] ? a[0].chart : h2[0].chart, p = n.isNavigator ? 0 : 10, q = n._axes;
          if (a && 0 < a.length)
            for (var g = 0; g < a.length; g++)
              a[g] && a[g].calculateAxisParameters();
          if (h2 && 0 < h2.length)
            for (g = 0; g < h2.length; g++)
              h2[g].calculateAxisParameters();
          if (c2 && 0 < c2.length)
            for (g = 0; g < c2.length; g++)
              c2[g].calculateAxisParameters();
          if (b && 0 < b.length)
            for (g = 0; g < b.length; g++)
              b[g].calculateAxisParameters();
          for (g = 0; g < q.length; g++)
            if (q[g] && q[g].scaleBreaks && q[g].scaleBreaks._appliedBreaks.length)
              for (var s2 = q[g].scaleBreaks._appliedBreaks, r2 = 0; r2 < s2.length && !(s2[r2].startValue > q[g].viewportMaximum); r2++)
                s2[r2].endValue < q[g].viewportMinimum || (f2(q[g].scaleBreaks.firstBreakIndex) && (q[g].scaleBreaks.firstBreakIndex = r2), s2[r2].startValue >= q[g].viewPortMinimum && (q[g].scaleBreaks.lastBreakIndex = r2));
          for (var v2 = r2 = 0, t = 0, w2 = 0, y2 = 0, x3 = 0, A2 = 0, E, D2, F3 = k3 = 0, K, J, L3, s2 = K = J = L3 = false, g = 0; g < q.length; g++)
            q[g] && q[g].title && (q[g]._titleTextBlock = new ma(q[g].ctx, {
              text: q[g].title,
              horizontalAlign: "center",
              fontSize: q[g].titleFontSize,
              fontFamily: q[g].titleFontFamily,
              fontWeight: q[g].titleFontWeight,
              fontColor: q[g].titleFontColor,
              fontStyle: q[g].titleFontStyle,
              borderColor: q[g].titleBorderColor,
              borderThickness: q[g].titleBorderThickness,
              backgroundColor: q[g].titleBackgroundColor,
              cornerRadius: q[g].titleCornerRadius,
              textBaseline: "middle"
            }));
          for (g = 0; g < q.length; g++)
            if (q[g].title)
              switch (q[g]._position) {
                case "left":
                  q[g]._titleTextBlock.maxWidth = q[g].titleMaxWidth || l2.height;
                  q[g]._titleTextBlock.maxHeight = q[g].titleWrap ? 0.8 * l2.width : 1.5 * q[g].titleFontSize;
                  q[g]._titleTextBlock.angle = -90;
                  break;
                case "right":
                  q[g]._titleTextBlock.maxWidth = q[g].titleMaxWidth || l2.height;
                  q[g]._titleTextBlock.maxHeight = q[g].titleWrap ? 0.8 * l2.width : 1.5 * q[g].titleFontSize;
                  q[g]._titleTextBlock.angle = 90;
                  break;
                default:
                  q[g]._titleTextBlock.maxWidth = q[g].titleMaxWidth || l2.width, q[g]._titleTextBlock.maxHeight = q[g].titleWrap ? 0.8 * l2.height : 1.5 * q[g].titleFontSize, q[g]._titleTextBlock.angle = 0;
              }
          if ("normal" === e) {
            for (var w2 = [], y2 = [], x3 = [], A2 = [], O2 = [], P2 = [], Q2 = [], M3 = []; 4 > r2; ) {
              var H = 0, V2 = 0, R2 = 0, Z = 0, T3 = e = 0, S2 = 0, ba2 = 0, $2 = 0, X3 = 0, U = 0, aa2 = 0;
              if (c2 && 0 < c2.length)
                for (x3 = [], g = U = 0; g < c2.length; g++)
                  x3.push(Math.ceil(c2[g] ? c2[g].createLabelsAndCalculateWidth() : 0)), U += x3[g], S2 += c2[g] && !n.isNavigator ? c2[g].margin : 0;
              else
                x3.push(Math.ceil(c2[0] ? c2[0].createLabelsAndCalculateWidth() : 0));
              Q2.push(x3);
              if (b && 0 < b.length)
                for (A2 = [], g = aa2 = 0; g < b.length; g++)
                  A2.push(Math.ceil(b[g] ? b[g].createLabelsAndCalculateWidth() : 0)), aa2 += A2[g], ba2 += b[g] ? b[g].margin : 0;
              else
                A2.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateWidth() : 0));
              M3.push(A2);
              d3 = Math.round(l2.x1 + U + S2);
              u3 = Math.round(l2.x2 - aa2 - ba2 > n.width - p ? n.width - p : l2.x2 - aa2 - ba2);
              if (a && 0 < a.length)
                for (w2 = [], g = $2 = 0; g < a.length; g++)
                  a[g] && (a[g].lineCoordinates = {}), a[g].lineCoordinates.width = Math.abs(u3 - d3), a[g].title && (a[g]._titleTextBlock.maxWidth = 0 < a[g].titleMaxWidth && a[g].titleMaxWidth < a[g].lineCoordinates.width ? a[g].titleMaxWidth : a[g].lineCoordinates.width), w2.push(Math.ceil(a[g] ? a[g].createLabelsAndCalculateHeight() : 0)), $2 += w2[g], e += a[g] && !n.isNavigator ? a[g].margin : 0;
              else
                w2.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateHeight() : 0));
              O2.push(w2);
              if (h2 && 0 < h2.length)
                for (y2 = [], g = X3 = 0; g < h2.length; g++)
                  h2[g] && (h2[g].lineCoordinates = {}), h2[g].lineCoordinates.width = Math.abs(u3 - d3), h2[g].title && (h2[g]._titleTextBlock.maxWidth = 0 < h2[g].titleMaxWidth && h2[g].titleMaxWidth < h2[g].lineCoordinates.width ? h2[g].titleMaxWidth : h2[g].lineCoordinates.width), y2.push(Math.ceil(h2[g] ? h2[g].createLabelsAndCalculateHeight() : 0)), X3 += y2[g], T3 += h2[g] && !n.isNavigator ? h2[g].margin : 0;
              else
                y2.push(Math.ceil(h2[0] ? h2[0].createLabelsAndCalculateHeight() : 0));
              P2.push(y2);
              if (a && 0 < a.length)
                for (g = 0; g < a.length; g++)
                  a[g] && (a[g].lineCoordinates.x1 = d3, u3 = Math.round(l2.x2 - aa2 - ba2 > n.width - p ? n.width - p : l2.x2 - aa2 - ba2), a[g]._labels && 1 < a[g]._labels.length && (k3 = m = 0, m = a[g]._labels[1], k3 = "dateTime" === a[g].valueType ? a[g]._labels[a[g]._labels.length - 2] : a[g]._labels[a[g]._labels.length - 1], v2 = m.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(m.textBlock.angle)) + (m.textBlock.height - k3.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(m.textBlock.angle)), t = k3.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k3.textBlock.angle)) + (k3.textBlock.height - k3.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k3.textBlock.angle))), !a[g] || (!a[g].labelAutoFit || f2(E) || f2(D2) || n.isNavigator || n.stockChart) || (k3 = 0, 0 < a[g].labelAngle ? D2 + t > u3 && (k3 += 0 < a[g].labelAngle ? D2 + t - u3 - aa2 : 0) : 0 > a[g].labelAngle ? E - v2 < d3 && E - v2 < a[g].viewportMinimum && (F3 = d3 - (S2 + a[g].tickLength + x3 + E - v2 + a[g].labelFontSize / 2)) : 0 === a[g].labelAngle && (D2 + t > u3 && (k3 = D2 + t / 2 - u3 - aa2), E - v2 < d3 && E - v2 < a[g].viewportMinimum && (F3 = d3 - S2 - a[g].tickLength - x3 - E + v2 / 2)), a[g].viewportMaximum === a[g].maximum && a[g].viewportMinimum === a[g].minimum && 0 < a[g].labelAngle && 0 < k3 ? u3 -= k3 : a[g].viewportMaximum === a[g].maximum && a[g].viewportMinimum === a[g].minimum && 0 > a[g].labelAngle && 0 < F3 ? d3 += F3 : a[g].viewportMaximum === a[g].maximum && a[g].viewportMinimum === a[g].minimum && 0 === a[g].labelAngle && (0 < F3 && (d3 += F3), 0 < k3 && (u3 -= k3))), n.panEnabled ? $2 = f2(n.sessionVariables.axisX.height) || n.stockChart ? n.sessionVariables.axisX.height = $2 : n.sessionVariables.axisX.height : n.sessionVariables.axisX.height = $2, k3 = Math.round(l2.y2 - $2 - e + H), m = Math.round(l2.y2), a[g].lineCoordinates.x2 = u3, a[g].lineCoordinates.width = u3 - d3, a[g].lineCoordinates.y1 = k3, a[g].lineCoordinates.y2 = k3, "inside" === a[g].labelPlacement && 0 < g && (a[g].lineCoordinates.y1 = a[g - 1].lineCoordinates.y2 + H + (a[g].labelEffectiveHeight || 0), a[g].lineCoordinates.y2 = a[g].lineCoordinates.y1 + a[g].lineThickness / 2), "inside" === a[g].tickPlacement && 0 < g && (a[g].lineCoordinates.y1 += a[g].tickLength, a[g].lineCoordinates.y2 = a[g].lineCoordinates.y1 + a[g].lineThickness / 2), a[g].bounds = { x1: d3, y1: k3, x2: u3, y2: m - ($2 + e - w2[g] - H), width: u3 - d3 }, a[g].bounds.height = a[g].bounds.y2 - a[g].bounds.y1), H += w2[g] + a[g].margin;
              if (h2 && 0 < h2.length)
                for (g = 0; g < h2.length; g++)
                  h2[g].lineCoordinates.x1 = Math.round(l2.x1 + U + S2), h2[g].lineCoordinates.x2 = Math.round(l2.x2 - aa2 - ba2 > n.width - p ? n.width - p : l2.x2 - aa2 - ba2), h2[g].lineCoordinates.width = Math.abs(u3 - d3), h2[g]._labels && 1 < h2[g]._labels.length && (m = h2[g]._labels[1], k3 = "dateTime" === h2[g].valueType ? h2[g]._labels[h2[g]._labels.length - 2] : h2[g]._labels[h2[g]._labels.length - 1], v2 = m.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(m.textBlock.angle)) + (m.textBlock.height - k3.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(m.textBlock.angle)), t = k3.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k3.textBlock.angle)) + (k3.textBlock.height - k3.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k3.textBlock.angle))), n.panEnabled ? X3 = f2(n.sessionVariables.axisX2.height) || n.stockChart ? n.sessionVariables.axisX2.height = X3 : n.sessionVariables.axisX2.height : n.sessionVariables.axisX2.height = X3, k3 = Math.round(l2.y1), m = h2[g].lineCoordinates.y1 = k3 + X3 + T3 - V2, h2[g].lineCoordinates.y2 = k3, "inside" === h2[g].labelPlacement && 0 < g && (h2[g].lineCoordinates.y1 = h2[g - 1].lineCoordinates.y1 - V2 - (h2[g].labelEffectiveHeight || 0)), "inside" === h2[g].tickPlacement && 0 < g && (h2[g].lineCoordinates.y1 -= h2[g].tickLength), h2[g].bounds = { x1: d3, y1: k3 + (X3 + T3 - y2[g] - V2), x2: u3, y2: m, width: u3 - d3 }, h2[g].bounds.height = h2[g].bounds.y2 - h2[g].bounds.y1, V2 += y2[g] + h2[g].margin;
              if (c2 && 0 < c2.length)
                for (g = 0; g < c2.length; g++)
                  S2 = n.isNavigator ? 0 : 10, c2[g] && (d3 = Math.round(a[0] ? a[0].lineCoordinates.x1 : h2[0].lineCoordinates.x1), S2 = c2[g]._labels && 0 < c2[g]._labels.length ? c2[g]._labels[c2[g]._labels.length - 1].textBlock.height / 2 : p, k3 = Math.round(l2.y1 + X3 + T3 < Math.max(S2, p) ? Math.max(S2, p) : l2.y1 + X3 + T3), u3 = Math.round(a[0] ? a[0].lineCoordinates.x1 : h2[0].lineCoordinates.x1), S2 = 0 < a.length ? 0 : c2[g]._labels && 0 < c2[g]._labels.length ? c2[g]._labels[0].textBlock.height / 2 : p, m = Math.round(l2.y2 - $2 - e - S2), c2[g].lineCoordinates = { x1: d3 - R2, y1: k3, x2: u3 - R2, y2: m, height: Math.abs(m - k3) }, "inside" === c2[g].labelPlacement && 0 < g && (c2[g].lineCoordinates.x1 = c2[g - 1].lineCoordinates.x1 - R2 - (c2[g].labelEffectiveWidth || 0), c2[g].lineCoordinates.x2 = c2[g].lineCoordinates.x1 + c2[g].lineThickness / 2), "inside" === c2[g].tickPlacement && 0 < g && (c2[g].lineCoordinates.x1 -= c2[g].tickLength, c2[g].lineCoordinates.x2 = c2[g].lineCoordinates.x1 + c2[g].lineThickness / 2), c2[g].bounds = { x1: d3 - (x3[g] + R2), y1: k3, x2: u3 - R2, y2: m, height: m - k3 }, c2[g].bounds.width = c2[g].bounds.x2 - c2[g].bounds.x1, c2[g].title && (c2[g]._titleTextBlock.maxWidth = 0 < c2[g].titleMaxWidth && c2[g].titleMaxWidth < c2[g].lineCoordinates.height ? c2[g].titleMaxWidth : c2[g].lineCoordinates.height), R2 += x3[g] + c2[g].margin);
              if (b && 0 < b.length)
                for (g = 0; g < b.length; g++)
                  b[g] && (d3 = Math.round(a[0] ? a[0].lineCoordinates.x2 : h2[0].lineCoordinates.x2), u3 = Math.round(d3), S2 = b[g]._labels && 0 < b[g]._labels.length ? b[g]._labels[b[g]._labels.length - 1].textBlock.height / 2 : 0, k3 = Math.round(l2.y1 + X3 + T3 < Math.max(S2, p) ? Math.max(S2, p) : l2.y1 + X3 + T3), S2 = 0 < a.length ? 0 : b[g]._labels && 0 < b[g]._labels.length ? b[g]._labels[0].textBlock.height / 2 : 0, m = Math.round(l2.y2 - ($2 + e + S2)), b[g].lineCoordinates = { x1: d3 + Z, y1: k3, x2: d3 + Z, y2: m, height: Math.abs(m - k3) }, "inside" === b[g].labelPlacement && 0 < g && (b[g].lineCoordinates.x1 = b[g - 1].lineCoordinates.x2 + Z + (b[g].labelEffectiveWidth || 0), b[g].lineCoordinates.x2 = b[g].lineCoordinates.x1 + b[g].lineThickness / 2), "inside" === b[g].tickPlacement && 0 < g && (b[g].lineCoordinates.x1 += b[g].tickLength, b[g].lineCoordinates.x2 = b[g].lineCoordinates.x1 + b[g].lineThickness / 2), b[g].bounds = { x1: d3 + Z, y1: k3, x2: u3 + (A2[g] + Z), y2: m, height: m - k3 }, b[g].bounds.width = b[g].bounds.x2 - b[g].bounds.x1, b[g].title && (b[g]._titleTextBlock.maxWidth = 0 < b[g].titleMaxWidth && b[g].titleMaxWidth < b[g].lineCoordinates.height ? b[g].titleMaxWidth : b[g].lineCoordinates.height), Z += A2[g] + b[g].margin);
              if (a && 0 < a.length)
                for (g = 0; g < a.length; g++)
                  a[g] && (a[g].calculateValueToPixelConversionParameters(), a[g].calculateBreaksSizeInValues(), a[g]._labels && 1 < a[g]._labels.length && (E = (a[g].logarithmic ? Math.log(a[g]._labels[1].position / a[g].viewportMinimum) / a[g].conversionParameters.lnLogarithmBase : a[g]._labels[1].position - a[g].viewportMinimum) * Math.abs(a[g].conversionParameters.pixelPerUnit) + a[g].lineCoordinates.x1, d3 = a[g]._labels[a[g]._labels.length - ("dateTime" === a[g].valueType ? 2 : 1)].position, d3 = a[g].getApparentDifference(
                    a[g].viewportMinimum,
                    d3
                  ), D2 = a[g].logarithmic ? (1 < d3 ? Math.log(d3) / a[g].conversionParameters.lnLogarithmBase * Math.abs(a[g].conversionParameters.pixelPerUnit) : 0) + a[g].lineCoordinates.x1 : (0 < d3 ? d3 * Math.abs(a[g].conversionParameters.pixelPerUnit) : 0) + a[g].lineCoordinates.x1));
              if (h2 && 0 < h2.length)
                for (g = 0; g < h2.length; g++)
                  h2[g].calculateValueToPixelConversionParameters(), h2[g].calculateBreaksSizeInValues(), h2[g]._labels && 1 < h2[g]._labels.length && (E = (h2[g].logarithmic ? Math.log(h2[g]._labels[1].position / h2[g].viewportMinimum) / h2[g].conversionParameters.lnLogarithmBase : h2[g]._labels[1].position - h2[g].viewportMinimum) * Math.abs(h2[g].conversionParameters.pixelPerUnit) + h2[g].lineCoordinates.x1, d3 = h2[g]._labels[h2[g]._labels.length - ("dateTime" === h2[g].valueType ? 2 : 1)].position, d3 = h2[g].getApparentDifference(h2[g].viewportMinimum, d3), D2 = h2[g].logarithmic ? (1 < d3 ? Math.log(d3) / h2[g].conversionParameters.lnLogarithmBase * Math.abs(h2[g].conversionParameters.pixelPerUnit) : 0) + h2[g].lineCoordinates.x1 : (0 < d3 ? d3 * Math.abs(h2[g].conversionParameters.pixelPerUnit) : 0) + h2[g].lineCoordinates.x1);
              for (g = 0; g < q.length; g++)
                "axisY" === q[g].type && (q[g].calculateValueToPixelConversionParameters(), q[g].calculateBreaksSizeInValues());
              if (0 < r2) {
                if (a && 0 < a.length)
                  for (g = 0; g < a.length; g++)
                    s2 = O2[r2 - 1][g] === O2[r2][g] ? true : false;
                else
                  s2 = true;
                if (h2 && 0 < h2.length)
                  for (g = 0; g < h2.length; g++)
                    K = P2[r2 - 1][g] === P2[r2][g] ? true : false;
                else
                  K = true;
                if (c2 && 0 < c2.length)
                  for (g = 0; g < c2.length; g++)
                    J = Q2[r2 - 1][g] === Q2[r2][g] ? true : false;
                else
                  J = true;
                if (b && 0 < b.length)
                  for (g = 0; g < b.length; g++)
                    L3 = M3[r2 - 1][g] === M3[r2][g] ? true : false;
                else
                  L3 = true;
              }
              if (s2 && K && J && L3)
                break;
              r2++;
            }
            if (a && 0 < a.length)
              for (g = 0; g < a.length; g++)
                a[g].calculateStripLinesThicknessInValues(), a[g].calculateBreaksInPixels();
            if (h2 && 0 < h2.length)
              for (g = 0; g < h2.length; g++)
                h2[g].calculateStripLinesThicknessInValues(), h2[g].calculateBreaksInPixels();
            if (c2 && 0 < c2.length)
              for (g = 0; g < c2.length; g++)
                c2[g].calculateStripLinesThicknessInValues(), c2[g].calculateBreaksInPixels();
            if (b && 0 < b.length)
              for (g = 0; g < b.length; g++)
                b[g].calculateStripLinesThicknessInValues(), b[g].calculateBreaksInPixels();
          } else {
            p = [];
            E = [];
            F3 = [];
            v2 = [];
            D2 = [];
            t = [];
            O2 = [];
            for (P2 = []; 4 > r2; ) {
              $2 = Z = R2 = ba2 = S2 = T3 = e = M3 = Q2 = H = X3 = 0;
              if (a && 0 < a.length)
                for (F3 = [], g = Z = 0; g < a.length; g++)
                  F3.push(Math.ceil(a[g] ? a[g].createLabelsAndCalculateWidth() : 0)), Z += F3[g], e += a[g] && !n.isNavigator ? a[g].margin : 0;
              else
                F3.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateWidth() : 0));
              O2.push(F3);
              if (h2 && 0 < h2.length)
                for (v2 = [], g = $2 = 0; g < h2.length; g++)
                  v2.push(Math.ceil(h2[g] ? h2[g].createLabelsAndCalculateWidth() : 0)), $2 += v2[g], T3 += h2[g] ? h2[g].margin : 0;
              else
                v2.push(Math.ceil(h2[0] ? h2[0].createLabelsAndCalculateWidth() : 0));
              P2.push(v2);
              if (c2 && 0 < c2.length)
                for (g = 0; g < c2.length; g++)
                  c2[g].lineCoordinates = {}, d3 = Math.round(l2.x1 + Z + e), u3 = Math.round(l2.x2 - $2 - T3 > n.width - 10 ? n.width - 10 : l2.x2 - $2 - T3), c2[g].labelAutoFit && !f2(w2) && (0 < !a.length && (d3 = 0 > c2[g].labelAngle ? Math.max(d3, w2) : 0 === c2[g].labelAngle ? Math.max(d3, w2 / 2) : d3), 0 < !h2.length && (u3 = 0 < c2[g].labelAngle ? u3 - y2 / 2 : 0 === c2[g].labelAngle ? u3 - y2 / 2 : u3)), c2[g].lineCoordinates.x1 = d3, c2[g].lineCoordinates.x2 = u3, c2[g].lineCoordinates.width = Math.abs(u3 - d3), c2[g].title && (c2[g]._titleTextBlock.maxWidth = 0 < c2[g].titleMaxWidth && c2[g].titleMaxWidth < c2[g].lineCoordinates.width ? c2[g].titleMaxWidth : c2[g].lineCoordinates.width);
              if (b && 0 < b.length)
                for (g = 0; g < b.length; g++)
                  b[g].lineCoordinates = {}, d3 = Math.round(l2.x1 + Z + e), u3 = Math.round(l2.x2 - $2 - T3 > b[g].chart.width - 10 ? b[g].chart.width - 10 : l2.x2 - $2 - T3), b[g] && b[g].labelAutoFit && !f2(x3) && (0 < !a.length && (d3 = 0 < b[g].labelAngle ? Math.max(d3, x3) : 0 === b[g].labelAngle ? Math.max(d3, x3 / 2) : d3), 0 < !h2.length && (u3 -= A2 / 2)), b[g].lineCoordinates.x1 = d3, b[g].lineCoordinates.x2 = u3, b[g].lineCoordinates.width = Math.abs(u3 - d3), b[g].title && (b[g]._titleTextBlock.maxWidth = 0 < b[g].titleMaxWidth && b[g].titleMaxWidth < b[g].lineCoordinates.width ? b[g].titleMaxWidth : b[g].lineCoordinates.width);
              if (c2 && 0 < c2.length)
                for (p = [], g = R2 = 0; g < c2.length; g++)
                  p.push(Math.ceil(c2[g] ? c2[g].createLabelsAndCalculateHeight() : 0)), R2 += p[g] + c2[g].margin, S2 += c2[g].margin;
              else
                p.push(Math.ceil(c2[0] ? c2[0].createLabelsAndCalculateHeight() : 0));
              D2.push(p);
              if (b && 0 < b.length)
                for (E = [], g = 0; g < b.length; g++)
                  E.push(Math.ceil(b[g] ? b[g].createLabelsAndCalculateHeight() : 0)), ba2 += b[g].margin;
              else
                E.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateHeight() : 0));
              t.push(E);
              if (c2 && 0 < c2.length)
                for (g = 0; g < c2.length; g++)
                  0 < c2[g]._labels.length && (m = c2[g]._labels[0], k3 = c2[g]._labels[c2[g]._labels.length - 1], w2 = m.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(m.textBlock.angle)) + (m.textBlock.height - k3.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(m.textBlock.angle)), y2 = k3.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k3.textBlock.angle)) + (k3.textBlock.height - k3.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k3.textBlock.angle)));
              if (b && 0 < b.length)
                for (g = 0; g < b.length; g++)
                  b[g] && 0 < b[g]._labels.length && (m = b[g]._labels[0], k3 = b[g]._labels[b[g]._labels.length - 1], x3 = m.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(m.textBlock.angle)) + (m.textBlock.height - k3.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(m.textBlock.angle)), A2 = k3.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k3.textBlock.angle)) + (k3.textBlock.height - k3.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k3.textBlock.angle)));
              if (n.panEnabled)
                for (g = 0; g < c2.length; g++)
                  p[g] = f2(n.sessionVariables.axisY[g].height) ? n.sessionVariables.axisY[g].height = p[g] : n.sessionVariables.axisY[g].height;
              else
                for (g = 0; g < c2.length; g++)
                  n.sessionVariables.axisY[g].height = p[g];
              if (c2 && 0 < c2.length)
                for (g = c2.length - 1; 0 <= g; g--)
                  k3 = Math.round(l2.y2), m = Math.round(l2.y2 > c2[g].chart.height ? c2[g].chart.height : l2.y2), c2[g].lineCoordinates.y1 = k3 - (p[g] + c2[g].margin + X3), c2[g].lineCoordinates.y2 = k3 - (p[g] + c2[g].margin + X3), "inside" === c2[g].labelPlacement && 0 < g && (c2[g].lineCoordinates.y1 = c2[g].lineCoordinates.y1 + p[g] - (c2[g]._titleTextBlock ? c2[g]._titleTextBlock.height : 0) - c2[g].tickLength - (c2[g].stripLineLabelEffectiveHeight || 0) - 5, c2[g].lineCoordinates.y2 = c2[g].lineCoordinates.y1 + c2[g].lineThickness / 2), "inside" === c2[g].tickPlacement && 0 < g && (c2[g].lineCoordinates.y1 += c2[g].tickLength, c2[g].lineCoordinates.y2 = c2[g].lineCoordinates.y1 + c2[g].lineThickness / 2), c2[g].bounds = { x1: d3, y1: k3 - (p[g] + X3 + c2[g].margin), x2: u3, y2: m - (X3 + c2[g].margin), width: u3 - d3, height: p[g] }, c2[g].title && (c2[g]._titleTextBlock.maxWidth = 0 < c2[g].titleMaxWidth && c2[g].titleMaxWidth < c2[g].lineCoordinates.width ? c2[g].titleMaxWidth : c2[g].lineCoordinates.width), X3 += p[g] + c2[g].margin;
              if (b && 0 < b.length)
                for (g = b.length - 1; 0 <= g; g--)
                  b[g] && (k3 = Math.round(l2.y1), m = Math.round(l2.y1 + (E[g] + b[g].margin + H)), b[g].lineCoordinates.y1 = m, b[g].lineCoordinates.y2 = m, "inside" === b[g].labelPlacement && 0 < g && (b[g].lineCoordinates.y1 = m - E[g] + (b[g]._titleTextBlock ? b[g]._titleTextBlock.height : 0) + b[g].tickLength + (b[g].stripLineLabelEffectiveHeight || 0), b[g].lineCoordinates.y2 = b[g].lineCoordinates.y1 - b[g].lineThickness / 2), "inside" === b[g].tickPlacement && 0 < g && (b[g].lineCoordinates.y1 -= b[g].tickLength, b[g].lineCoordinates.y2 = b[g].lineCoordinates.y1 - b[g].lineThickness / 2), b[g].bounds = { x1: d3, y1: k3 + (b[g].margin + H), x2: u3, y2: m, width: u3 - d3 }, b[g].bounds.height = b[g].bounds.y2 - b[g].bounds.y1, b[g].title && (b[g]._titleTextBlock.maxWidth = 0 < b[g].titleMaxWidth && b[g].titleMaxWidth < b[g].lineCoordinates.width ? b[g].titleMaxWidth : b[g].lineCoordinates.width), H += E[g] + b[g].margin);
              if (a && 0 < a.length)
                for (g = 0; g < a.length; g++) {
                  S2 = a[g]._labels && 0 < a[g]._labels.length ? a[g]._labels[0].textBlock.fontSize / 2 : 0;
                  d3 = Math.round(l2.x1 + e);
                  k3 = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y2 : l2.y1 < Math.max(S2, 10) ? Math.max(S2, 10) : l2.y1) : l2.y1 < Math.max(S2, 10) ? Math.max(S2, 10) : l2.y1;
                  u3 = Math.round(l2.x1 + Z + e);
                  m = c2 && 0 < c2.length ? Math.round(c2[0] ? c2[0].lineCoordinates.y1 : l2.y2 - R2 > n.height - Math.max(S2, 10) ? n.height - Math.max(S2, 10) : l2.y2 - R2) : l2.y2 > n.height - Math.max(S2, 10) ? n.height - Math.max(S2, 10) : l2.y2;
                  if (c2 && 0 < c2.length)
                    for (S2 = 0; S2 < c2.length; S2++)
                      c2[S2] && c2[S2].labelAutoFit && (u3 = c2[S2].lineCoordinates.x1, d3 = 0 > c2[S2].labelAngle || 0 === c2[S2].labelAngle ? u3 - Z : d3);
                  if (b && 0 < b.length)
                    for (S2 = 0; S2 < b.length; S2++)
                      b[S2] && b[S2].labelAutoFit && (u3 = b[S2].lineCoordinates.x1, d3 = u3 - Z);
                  a[g].lineCoordinates = { x1: u3 - Q2, y1: k3, x2: u3 - Q2, y2: m, height: Math.abs(m - k3) };
                  "inside" === a[g].labelPlacement && 0 < g && (a[g].lineCoordinates.x1 = a[g].lineCoordinates.x1 - (F3[g] - (a[g]._titleTextBlock ? a[g]._titleTextBlock.height : 0)) + a[g].tickLength + (a[g].stripLineLabelEffectiveWidth || 0), a[g].lineCoordinates.x2 = a[g].lineCoordinates.x1 + a[g].lineThickness / 2);
                  "inside" === a[g].tickPlacement && 0 < g && (a[g].lineCoordinates.x1 -= a[g].tickLength, a[g].lineCoordinates.x2 = a[g].lineCoordinates.x1 + a[g].lineThickness / 2);
                  a[g].bounds = { x1: u3 - (F3[g] + Q2), y1: k3, x2: u3 - Q2, y2: m, height: m - k3 };
                  a[g].bounds.width = a[g].bounds.x2 - a[g].bounds.x1;
                  a[g].title && (a[g]._titleTextBlock.maxWidth = 0 < a[g].titleMaxWidth && a[g].titleMaxWidth < a[g].lineCoordinates.height ? a[g].titleMaxWidth : a[g].lineCoordinates.height);
                  a[g].calculateValueToPixelConversionParameters();
                  a[g].calculateBreaksSizeInValues();
                  Q2 += F3[g] + a[g].margin;
                }
              if (h2 && 0 < h2.length)
                for (g = 0; g < h2.length; g++) {
                  S2 = h2[g]._labels && 0 < h2[g]._labels.length ? h2[g]._labels[0].textBlock.fontSize / 2 : 0;
                  d3 = Math.round(l2.x1 - e);
                  k3 = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y2 : l2.y1 < Math.max(S2, 10) ? Math.max(S2, 10) : l2.y1) : l2.y1 < Math.max(
                    S2,
                    10
                  ) ? Math.max(S2, 10) : l2.y1;
                  u3 = Math.round(l2.x2 - $2 - T3);
                  m = c2 && 0 < c2.length ? Math.round(c2[0] ? c2[0].lineCoordinates.y1 : l2.y2 - R2 > n.height - Math.max(S2, 10) ? n.height - Math.max(S2, 10) : l2.y2 - R2) : l2.y2 > n.height - Math.max(S2, 10) ? n.height - Math.max(S2, 10) : l2.y2;
                  if (c2 && 0 < c2.length)
                    for (S2 = 0; S2 < c2.length; S2++)
                      c2[S2] && c2[S2].labelAutoFit && (u3 = 0 > c2[S2].labelAngle ? Math.max(u3, w2) : 0 === c2[S2].labelAngle ? Math.max(u3, w2 / 2) : u3, d3 = 0 > c2[S2].labelAngle || 0 === c2[S2].labelAngle ? u3 - $2 : d3);
                  if (b && 0 < b.length)
                    for (S2 = 0; S2 < b.length; S2++)
                      b[S2] && b[S2].labelAutoFit && (u3 = b[S2].lineCoordinates.x2, d3 = u3 - $2);
                  h2[g].lineCoordinates = { x1: u3 + M3, y1: k3, x2: u3 + M3, y2: m, height: Math.abs(m - k3) };
                  "inside" === h2[g].labelPlacement && 0 < g && (h2[g].lineCoordinates.x1 = h2[g].lineCoordinates.x1 + (v2[g] - (h2[g]._titleTextBlock ? h2[g]._titleTextBlock.height : 0) - 2) - h2[g].tickLength - (h2[g].stripLineLabelEffectiveWidth || 0), h2[g].lineCoordinates.x2 = h2[g].lineCoordinates.x1 + h2[g].lineThickness / 2);
                  "inside" === h2[g].tickPlacement && 0 < g && (h2[g].lineCoordinates.x1 += h2[g].tickLength, h2[g].lineCoordinates.x2 = h2[g].lineCoordinates.x1 + h2[g].lineThickness / 2);
                  h2[g].bounds = { x1: h2[g].lineCoordinates.x1, y1: k3, x2: u3 + v2[g] + M3, y2: m, width: u3 - d3, height: m - k3 };
                  h2[g].bounds.width = h2[g].bounds.x2 - h2[g].bounds.x1;
                  h2[g].title && (h2[g]._titleTextBlock.maxWidth = 0 < h2[g].titleMaxWidth && h2[g].titleMaxWidth < h2[g].lineCoordinates.height ? h2[g].titleMaxWidth : h2[g].lineCoordinates.height);
                  h2[g].calculateValueToPixelConversionParameters();
                  h2[g].calculateBreaksSizeInValues();
                  M3 += v2[g] + h2[g].margin;
                }
              for (g = 0; g < q.length; g++)
                "axisY" === q[g].type && (q[g].calculateValueToPixelConversionParameters(), q[g].calculateBreaksSizeInValues());
              if (0 < r2) {
                if (a && 0 < a.length)
                  for (g = 0; g < a.length; g++)
                    s2 = O2[r2 - 1][g] === O2[r2][g] ? true : false;
                else
                  s2 = true;
                if (h2 && 0 < h2.length)
                  for (g = 0; g < h2.length; g++)
                    K = P2[r2 - 1][g] === P2[r2][g] ? true : false;
                else
                  K = true;
                if (c2 && 0 < c2.length)
                  for (g = 0; g < c2.length; g++)
                    J = D2[r2 - 1][g] === D2[r2][g] ? true : false;
                else
                  J = true;
                if (b && 0 < b.length)
                  for (g = 0; g < b.length; g++)
                    L3 = t[r2 - 1][g] === t[r2][g] ? true : false;
                else
                  L3 = true;
              }
              if (s2 && K && J && L3)
                break;
              r2++;
            }
            if (c2 && 0 < c2.length)
              for (g = 0; g < c2.length; g++)
                c2[g].calculateStripLinesThicknessInValues(), c2[g].calculateBreaksInPixels();
            if (b && 0 < b.length)
              for (g = 0; g < b.length; g++)
                b[g].calculateStripLinesThicknessInValues(), b[g].calculateBreaksInPixels();
            if (a && 0 < a.length)
              for (g = 0; g < a.length; g++)
                a[g].calculateStripLinesThicknessInValues(), a[g].calculateBreaksInPixels();
            if (h2 && 0 < h2.length)
              for (g = 0; g < h2.length; g++)
                h2[g].calculateStripLinesThicknessInValues(), h2[g].calculateBreaksInPixels();
          }
        };
        A.render = function(a, h2, c2, b, e) {
          var l2 = a[0] ? a[0].chart : h2[0].chart;
          e = l2.ctx;
          l2.alignVerticalAxes && l2.alignVerticalAxes();
          e.save();
          e.beginPath();
          a && a.length && e.rect(5, a[0].bounds.y1, a[0].chart.width - 10, a[a.length - 1].bounds.y2);
          h2 && h2.length && e.rect(
            5,
            h2[h2.length - 1].bounds.y1,
            h2[0].chart.width - 10,
            h2[0].bounds.y2
          );
          e.clip();
          if (a && 0 < a.length)
            for (var d3 = 0; d3 < a.length; d3++)
              a[d3].renderLabelsTicksAndTitle();
          if (h2 && 0 < h2.length)
            for (d3 = 0; d3 < h2.length; d3++)
              h2[d3].renderLabelsTicksAndTitle();
          e.restore();
          if (c2 && 0 < c2.length)
            for (d3 = 0; d3 < c2.length; d3++)
              c2[d3].renderLabelsTicksAndTitle();
          if (b && 0 < b.length)
            for (d3 = 0; d3 < b.length; d3++)
              b[d3].renderLabelsTicksAndTitle();
          l2.preparePlotArea();
          l2 = l2.plotArea;
          e.save();
          e.beginPath();
          e.rect(l2.x1, l2.y1, Math.abs(l2.x2 - l2.x1), Math.abs(l2.y2 - l2.y1));
          e.clip();
          if (a && 0 < a.length)
            for (d3 = 0; d3 < a.length; d3++)
              a[d3].renderStripLinesOfThicknessType("value");
          if (h2 && 0 < h2.length)
            for (d3 = 0; d3 < h2.length; d3++)
              h2[d3].renderStripLinesOfThicknessType("value");
          if (c2 && 0 < c2.length)
            for (d3 = 0; d3 < c2.length; d3++)
              c2[d3].renderStripLinesOfThicknessType("value");
          if (b && 0 < b.length)
            for (d3 = 0; d3 < b.length; d3++)
              b[d3].renderStripLinesOfThicknessType("value");
          if (a && 0 < a.length)
            for (d3 = 0; d3 < a.length; d3++)
              a[d3].renderInterlacedColors();
          if (h2 && 0 < h2.length)
            for (d3 = 0; d3 < h2.length; d3++)
              h2[d3].renderInterlacedColors();
          if (c2 && 0 < c2.length)
            for (d3 = 0; d3 < c2.length; d3++)
              c2[d3].renderInterlacedColors();
          if (b && 0 < b.length)
            for (d3 = 0; d3 < b.length; d3++)
              b[d3].renderInterlacedColors();
          e.restore();
          if (a && 0 < a.length)
            for (d3 = 0; d3 < a.length; d3++)
              a[d3].renderGrid(), r && (a[d3].createMask(), a[d3].renderBreaksBackground());
          if (h2 && 0 < h2.length)
            for (d3 = 0; d3 < h2.length; d3++)
              h2[d3].renderGrid(), r && (h2[d3].createMask(), h2[d3].renderBreaksBackground());
          if (c2 && 0 < c2.length)
            for (d3 = 0; d3 < c2.length; d3++)
              c2[d3].renderGrid(), r && (c2[d3].createMask(), c2[d3].renderBreaksBackground());
          if (b && 0 < b.length)
            for (d3 = 0; d3 < b.length; d3++)
              b[d3].renderGrid(), r && (b[d3].createMask(), b[d3].renderBreaksBackground());
          if (a && 0 < a.length)
            for (d3 = 0; d3 < a.length; d3++)
              a[d3].renderAxisLine();
          if (h2 && 0 < h2.length)
            for (d3 = 0; d3 < h2.length; d3++)
              h2[d3].renderAxisLine();
          if (c2 && 0 < c2.length)
            for (d3 = 0; d3 < c2.length; d3++)
              c2[d3].renderAxisLine();
          if (b && 0 < b.length)
            for (d3 = 0; d3 < b.length; d3++)
              b[d3].renderAxisLine();
          if (a && 0 < a.length)
            for (d3 = 0; d3 < a.length; d3++)
              a[d3].renderStripLinesOfThicknessType("pixel");
          if (h2 && 0 < h2.length)
            for (d3 = 0; d3 < h2.length; d3++)
              h2[d3].renderStripLinesOfThicknessType("pixel");
          if (c2 && 0 < c2.length)
            for (d3 = 0; d3 < c2.length; d3++)
              c2[d3].renderStripLinesOfThicknessType("pixel");
          if (b && 0 < b.length)
            for (d3 = 0; d3 < b.length; d3++)
              b[d3].renderStripLinesOfThicknessType("pixel");
        };
        A.prototype.calculateStripLinesThicknessInValues = function() {
          for (var a = 0; a < this.stripLines.length; a++)
            if (null !== this.stripLines[a].startValue && null !== this.stripLines[a].endValue) {
              var h2 = Math.min(this.stripLines[a].startValue, this.stripLines[a].endValue), c2 = Math.max(this.stripLines[a].startValue, this.stripLines[a].endValue), b = this.getApparentDifference(h2, c2);
              this.stripLines[a].value = this.convertPixelToValue(Math.abs(this.convertValueToPixel(h2) + this.convertValueToPixel(c2)) / 2);
              this.stripLines[a].thickness = b;
              this.stripLines[a]._thicknessType = "value";
            }
        };
        A.prototype.calculateBreaksSizeInValues = function() {
          for (var a = "left" === this._position || "right" === this._position ? this.lineCoordinates.height || this.chart.height : this.lineCoordinates.width || this.chart.width, h2 = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], c2 = this.conversionParameters.pixelPerUnit || a / (this.logarithmic ? this.conversionParameters.maximum / this.conversionParameters.minimum : this.conversionParameters.maximum - this.conversionParameters.minimum), b = this.scaleBreaks && !f2(this.scaleBreaks.options.spacing), e, d3 = 0; d3 < h2.length; d3++)
            e = b || !f2(h2[d3].options.spacing), h2[d3].spacing = Wa(h2[d3].spacing, a, 8, e ? 0.1 * a : 8, e ? 0 : 3) << 0, h2[d3].size = 0 > h2[d3].spacing ? 0 : Math.abs(h2[d3].spacing / c2), this.logarithmic && (h2[d3].size = Math.pow(this.logarithmBase, h2[d3].size));
        };
        A.prototype.calculateBreaksInPixels = function() {
          if (!(this.scaleBreaks && 0 >= this.scaleBreaks._appliedBreaks.length)) {
            var a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
            a.length && (this.scaleBreaks.firstBreakIndex = this.scaleBreaks.lastBreakIndex = null);
            for (var h2 = 0; h2 < a.length && !(a[h2].startValue > this.conversionParameters.maximum); h2++)
              a[h2].endValue < this.conversionParameters.minimum || (f2(this.scaleBreaks.firstBreakIndex) && (this.scaleBreaks.firstBreakIndex = h2), a[h2].startValue >= this.conversionParameters.minimum && (a[h2].startPixel = this.convertValueToPixel(a[h2].startValue), this.scaleBreaks.lastBreakIndex = h2), a[h2].endValue <= this.conversionParameters.maximum && (a[h2].endPixel = this.convertValueToPixel(a[h2].endValue)));
          }
        };
        A.prototype.renderLabelsTicksAndTitle = function() {
          var a = this, h2 = false, c2 = 0, b = 0, e = 1, d3 = 0;
          0 !== this.labelAngle && 360 !== this.labelAngle && (e = 1.2);
          if ("undefined" === typeof this.options.interval) {
            if ("bottom" === this._position || "top" === this._position)
              if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
                for (var c2 = [], e = 0 !== this.labelAngle && 360 !== this.labelAngle ? 1 : 1.2, f3, k3 = this.viewportMaximum, u3 = this.lineCoordinates.width / Math.log(this.range), m = this._labels.length - 1; 0 <= m; m--) {
                  p = this._labels[m];
                  if (p.position < this.viewportMinimum)
                    break;
                  p.position > this.viewportMaximum || !(m === this._labels.length - 1 || f3 < Math.log(k3 / p.position) * u3 / e) || (c2.push(p), k3 = p.position, f3 = p.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));
                }
                this._labels = c2;
              } else {
                for (m = 0; m < this._labels.length; m++)
                  p = this._labels[m], p.position < this.viewportMinimum || (f3 = p.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), c2 += f3);
                c2 > this.lineCoordinates.width * e && this.labelAutoFit && (h2 = true);
              }
            if ("left" === this._position || "right" === this._position)
              if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
                for (var c2 = [], n, k3 = this.viewportMaximum, u3 = this.lineCoordinates.height / Math.log(this.range), m = this._labels.length - 1; 0 <= m; m--) {
                  p = this._labels[m];
                  if (p.position < this.viewportMinimum)
                    break;
                  p.position > this.viewportMaximum || !(m === this._labels.length - 1 || n < Math.log(k3 / p.position) * u3) || (c2.push(p), k3 = p.position, n = p.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));
                }
                this._labels = c2;
              } else {
                for (m = 0; m < this._labels.length; m++)
                  p = this._labels[m], p.position < this.viewportMinimum || (n = p.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), b += n);
                b > this.lineCoordinates.height * e && this.labelAutoFit && (h2 = true);
              }
          }
          this.logarithmic && (!this.equidistantInterval && this.labelAutoFit) && this._labels.sort(function(a2, b2) {
            return a2.position - b2.position;
          });
          var m = 0, p, q;
          if ("bottom" === this._position) {
            for (m = 0; m < this._labels.length; m++)
              p = this._labels[m], p.position < this.viewportMinimum || p.position > this.viewportMaximum || (q = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (q.x << 0) + 0.5 : q.x << 0, this.ctx.beginPath(), this.ctx.moveTo(b, q.y << 0), this.ctx.lineTo(b, q.y + this.tickLength << 0), this.ctx.stroke()), h2 && 0 !== d3++ % 2 && this.labelAutoFit || (0 === p.textBlock.angle ? (q.x -= p.textBlock.width / 2, q.y = "inside" === this.labelPlacement ? q.y - (("inside" === this.tickPlacement ? this.tickLength : 0) + p.textBlock.height - p.textBlock.fontSize / 2) : q.y + ("inside" === this.tickPlacement ? 0 : this.tickLength) + p.textBlock.fontSize / 2 + 5) : (q.x = "inside" === this.labelPlacement ? 0 > this.labelAngle ? q.x : q.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : q.x - (0 > this.labelAngle ? p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), q.y = "inside" === this.labelPlacement ? 0 > this.labelAngle ? q.y - ("inside" === this.tickPlacement ? this.tickLength : 0) - 5 : q.y - ("inside" === this.tickPlacement ? this.tickLength : 0) - Math.abs(p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + 5) : q.y + ("inside" === this.tickPlacement ? 0 : this.tickLength) + Math.abs(0 > this.labelAngle ? p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5)), p.textBlock.x = q.x, p.textBlock.y = q.y));
            "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
              for (m = 0; m < a._labels.length; m++)
                if (p = a._labels[m], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum) && (q = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {
                  a.ctx.lineWidth = a.tickThickness;
                  a.ctx.strokeStyle = a.tickColor;
                  var b2 = 1 === a.ctx.lineWidth % 2 ? (q.x << 0) + 0.5 : q.x << 0;
                  a.ctx.save();
                  a.ctx.beginPath();
                  a.ctx.moveTo(b2, q.y << 0);
                  a.ctx.lineTo(b2, q.y - a.tickLength << 0);
                  a.ctx.stroke();
                  a.ctx.restore();
                }
            }, this);
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y2 - this._titleTextBlock.height + this._titleTextBlock.fontSize / 2 - 1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(true));
          } else if ("top" === this._position) {
            for (m = 0; m < this._labels.length; m++)
              p = this._labels[m], p.position < this.viewportMinimum || p.position > this.viewportMaximum || (q = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (q.x << 0) + 0.5 : q.x << 0, this.ctx.beginPath(), this.ctx.moveTo(b, q.y << 0), this.ctx.lineTo(b, q.y - this.tickLength << 0), this.ctx.stroke()), h2 && 0 !== d3++ % 2 && this.labelAutoFit || (0 === p.textBlock.angle ? (q.x -= p.textBlock.width / 2, q.y = "inside" === this.labelPlacement ? q.y + this.labelFontSize / 2 + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : q.y - (("inside" === this.tickPlacement ? 0 : this.tickLength) + p.textBlock.height - p.textBlock.fontSize / 2)) : (q.x = "inside" === this.labelPlacement ? 0 < this.labelAngle ? q.x : q.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : q.x + (p.textBlock.height - this.labelFontSize) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), q.y = "inside" === this.labelPlacement ? 0 < this.labelAngle ? q.y + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : q.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : q.y - (("inside" === this.tickPlacement ? 0 : this.tickLength) + ((p.textBlock.height - p.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))), p.textBlock.x = q.x, p.textBlock.y = q.y));
            "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
              for (m = 0; m < a._labels.length; m++)
                if (p = a._labels[m], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum) && (q = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {
                  a.ctx.lineWidth = a.tickThickness;
                  a.ctx.strokeStyle = a.tickColor;
                  var b2 = 1 === a.ctx.lineWidth % 2 ? (q.x << 0) + 0.5 : q.x << 0;
                  a.ctx.save();
                  a.ctx.beginPath();
                  a.ctx.moveTo(b2, q.y << 0);
                  a.ctx.lineTo(b2, q.y + a.tickLength << 0);
                  a.ctx.stroke();
                  a.ctx.restore();
                }
            }, this);
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y1 + this._titleTextBlock.fontSize / 2 + 1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(true));
          } else if ("left" === this._position) {
            for (m = 0; m < this._labels.length; m++)
              p = this._labels[m], p.position < this.viewportMinimum || p.position > this.viewportMaximum || (q = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (q.y << 0) + 0.5 : q.y << 0, this.ctx.beginPath(), this.ctx.moveTo(q.x << 0, b), this.ctx.lineTo(q.x - this.tickLength << 0, b), this.ctx.stroke()), h2 && 0 !== d3++ % 2 && this.labelAutoFit || (0 === this.labelAngle ? (p.textBlock.y = q.y, p.textBlock.x = "inside" === this.labelPlacement ? q.x + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : q.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? 0 : this.tickLength) - 5) : (p.textBlock.y = "inside" === this.labelPlacement ? q.y : q.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), p.textBlock.x = "inside" === this.labelPlacement ? q.x + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : 0 < this.labelAngle ? q.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? 0 : this.tickLength) - 5 : q.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (p.textBlock.height - p.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? 0 : this.tickLength))));
            "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
              for (m = 0; m < a._labels.length; m++)
                if (p = a._labels[m], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum) && (q = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {
                  a.ctx.lineWidth = a.tickThickness;
                  a.ctx.strokeStyle = a.tickColor;
                  var b2 = 1 === a.ctx.lineWidth % 2 ? (q.y << 0) + 0.5 : q.y << 0;
                  a.ctx.save();
                  a.ctx.beginPath();
                  a.ctx.moveTo(q.x << 0, b2);
                  a.ctx.lineTo(q.x + a.tickLength << 0, b2);
                  a.ctx.stroke();
                  a.ctx.restore();
                }
            }, this);
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x1 + this._titleTextBlock.fontSize / 2 + 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(true));
          } else if ("right" === this._position) {
            for (m = 0; m < this._labels.length; m++)
              p = this._labels[m], p.position < this.viewportMinimum || p.position > this.viewportMaximum || (q = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (q.y << 0) + 0.5 : q.y << 0, this.ctx.beginPath(), this.ctx.moveTo(q.x << 0, b), this.ctx.lineTo(q.x + this.tickLength << 0, b), this.ctx.stroke()), h2 && 0 !== d3++ % 2 && this.labelAutoFit || (0 === this.labelAngle ? (p.textBlock.y = q.y, p.textBlock.x = "inside" === this.labelPlacement ? q.x - p.textBlock.width - ("inside" === this.tickPlacement ? this.tickLength : 0) - 5 : q.x + ("inside" === this.tickPlacement ? 0 : this.tickLength) + 5) : (p.textBlock.y = "inside" === this.labelPlacement ? q.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0 > this.labelAngle ? q.y : q.y - (p.textBlock.height - p.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), p.textBlock.x = "inside" === this.labelPlacement ? q.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? this.tickLength : 0) - 5 : 0 < this.labelAngle ? q.x + (p.textBlock.height - p.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + ("inside" === this.tickPlacement ? 0 : this.tickLength) : q.x + ("inside" === this.tickPlacement ? 0 : this.tickLength) + 5)));
            "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
              for (m = 0; m < a._labels.length; m++)
                if (p = a._labels[m], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum) && (q = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {
                  a.ctx.lineWidth = a.tickThickness;
                  a.ctx.strokeStyle = a.tickColor;
                  var b2 = 1 === a.ctx.lineWidth % 2 ? (q.y << 0) + 0.5 : q.y << 0;
                  a.ctx.save();
                  a.ctx.beginPath();
                  a.ctx.moveTo(q.x << 0, b2);
                  a.ctx.lineTo(q.x - a.tickLength << 0, b2);
                  a.ctx.stroke();
                  a.ctx.restore();
                }
            }, this);
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x2 - this._titleTextBlock.fontSize / 2 - 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(true));
          }
          d3 = 0;
          if ("inside" === this.labelPlacement)
            this.chart.addEventListener("dataAnimationIterationEnd", function() {
              for (m = 0; m < a._labels.length; m++)
                p = a._labels[m], p.position < a.viewportMinimum || (p.position > a.viewportMaximum || h2 && 0 !== d3++ % 2 && a.labelAutoFit) || (a.ctx.save(), a.ctx.beginPath(), p.textBlock.render(true), a.ctx.restore());
            }, this);
          else
            for (m = 0; m < this._labels.length; m++)
              p = this._labels[m], p.position < this.viewportMinimum || (p.position > this.viewportMaximum || h2 && 0 !== d3++ % 2 && this.labelAutoFit) || p.textBlock.render(true);
        };
        A.prototype.renderInterlacedColors = function() {
          var a = this.chart.plotArea.ctx, h2, c2, b = this.chart.plotArea, e = 0;
          h2 = true;
          if (("bottom" === this._position || "top" === this._position) && this.interlacedColor)
            for (a.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++)
              h2 ? (h2 = this.getPixelCoordinatesOnAxis(this._labels[e].position), c2 = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a.fillRect(Math.min(c2.x, h2.x), b.y1, Math.abs(c2.x - h2.x), Math.abs(b.y1 - b.y2)), h2 = false) : h2 = true;
          else if (("left" === this._position || "right" === this._position) && this.interlacedColor)
            for (a.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++)
              h2 ? (c2 = this.getPixelCoordinatesOnAxis(this._labels[e].position), h2 = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a.fillRect(b.x1, Math.min(c2.y, h2.y), Math.abs(b.x1 - b.x2), Math.abs(h2.y - c2.y)), h2 = false) : h2 = true;
          a.beginPath();
        };
        A.prototype.renderStripLinesOfThicknessType = function(a) {
          if (this.stripLines && 0 < this.stripLines.length && a) {
            var h2 = this, c2, b, e = 0, d3 = 0, k3 = false;
            b = false;
            for (var u3 = [], s2 = [], m = false, e = 0; e < this.stripLines.length; e++) {
              var n = this.stripLines[e];
              n._thicknessType === a && ("pixel" === a && (n.value < this.viewportMinimum || n.value > this.viewportMaximum || f2(n.value) || isNaN(this.range)) || "value" === a && (n.startValue <= this.viewportMinimum && n.endValue <= this.viewportMinimum || n.startValue >= this.viewportMaximum && n.endValue >= this.viewportMaximum || f2(n.startValue) || f2(n.endValue) || isNaN(this.range)) || u3.push(n));
            }
            for (e = 0; e < this._stripLineLabels.length; e++)
              if (n = this.stripLines[e], c2 = this._stripLineLabels[e], !(c2.position < this.viewportMinimum || c2.position > this.viewportMaximum || isNaN(this.range)))
                if (b = this.getPixelCoordinatesOnAxis(c2.position), "outside" === c2.stripLine.labelPlacement) {
                  n && (this.ctx.strokeStyle = n.color, this.ctx.lineWidth = "pixel" === n._thicknessType ? n.thickness : this.tickThickness);
                  if ("bottom" === this._position) {
                    var p = 1 === this.ctx.lineWidth % 2 ? (b.x << 0) + 0.5 : b.x << 0;
                    this.ctx.beginPath();
                    this.ctx.moveTo(p, b.y << 0);
                    this.ctx.lineTo(p, b.y + this.tickLength << 0);
                    this.ctx.stroke();
                    0 === this.labelAngle ? (b.x -= c2.textBlock.width / 2, b.y += this.tickLength + c2.textBlock.fontSize / 2 + 5) : (b.x -= 0 > this.labelAngle ? c2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, b.y += this.tickLength + Math.abs(0 > this.labelAngle ? c2.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5));
                  } else
                    "top" === this._position ? (p = 1 === this.ctx.lineWidth % 2 ? (b.x << 0) + 0.5 : b.x << 0, this.ctx.beginPath(), this.ctx.moveTo(p, b.y << 0), this.ctx.lineTo(p, b.y - this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (b.x -= c2.textBlock.width / 2, b.y -= this.tickLength + c2.textBlock.height - c2.textBlock.fontSize / 2) : (b.x += (c2.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? c2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), b.y -= this.tickLength + (c2.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? c2.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))) : "left" === this._position ? (p = 1 === this.ctx.lineWidth % 2 ? (b.y << 0) + 0.5 : b.y << 0, this.ctx.beginPath(), this.ctx.moveTo(b.x << 0, p), this.ctx.lineTo(b.x - this.tickLength << 0, p), this.ctx.stroke(), 0 === this.labelAngle ? b.x = b.x - c2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : (b.y -= c2.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), b.x = 0 < this.labelAngle ? b.x - c2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : b.x - c2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (c2.textBlock.height - c2.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength)) : "right" === this._position && (p = 1 === this.ctx.lineWidth % 2 ? (b.y << 0) + 0.5 : b.y << 0, this.ctx.beginPath(), this.ctx.moveTo(b.x << 0, p), this.ctx.lineTo(b.x + this.tickLength << 0, p), this.ctx.stroke(), 0 === this.labelAngle ? b.x = b.x + this.tickLength + 5 : (b.y = 0 > this.labelAngle ? b.y : b.y - (c2.textBlock.height - c2.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), b.x = 0 < this.labelAngle ? b.x + (c2.textBlock.height - c2.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : b.x + this.tickLength + 5));
                  c2.textBlock.x = b.x;
                  c2.textBlock.y = b.y;
                  s2.push(c2);
                } else
                  n._thicknessType === a && (c2.textBlock.angle = -90, "bottom" === this._position ? (c2.textBlock.maxWidth = this.options.stripLines[e].labelMaxWidth ? this.options.stripLines[e].labelMaxWidth : this.chart.plotArea.height - 3, c2.textBlock.measureText(), b.x - c2.textBlock.height - n.thickness / 2 > this.chart.plotArea.x1 ? f2(n.startValue) ? b.x -= c2.textBlock.height - c2.textBlock.fontSize / 2 + n.thickness / 2 : b.x -= c2.textBlock.height / 2 - c2.textBlock.fontSize / 2 : (c2.textBlock.angle = 90, f2(n.startValue) ? b.x += c2.textBlock.height - c2.textBlock.fontSize / 2 + n.thickness / 2 : b.x += c2.textBlock.height / 2 - c2.textBlock.fontSize / 2), b.y = -90 === c2.textBlock.angle ? "near" === c2.stripLine.labelAlign ? this.chart.plotArea.y2 - 3 : "center" === c2.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + c2.textBlock.width) / 2 : this.chart.plotArea.y1 + c2.textBlock.width + 3 : "near" === c2.stripLine.labelAlign ? this.chart.plotArea.y2 - c2.textBlock.width - 3 : "center" === c2.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - c2.textBlock.width) / 2 : this.chart.plotArea.y1 + 3) : "top" === this._position ? (c2.textBlock.maxWidth = this.options.stripLines[e].labelMaxWidth ? this.options.stripLines[e].labelMaxWidth : this.chart.plotArea.height - 3, c2.textBlock.measureText(), b.x - c2.textBlock.height - n.thickness / 2 > this.chart.plotArea.x1 ? f2(n.startValue) ? b.x -= c2.textBlock.height - c2.textBlock.fontSize / 2 + n.thickness / 2 : b.x -= c2.textBlock.height / 2 - c2.textBlock.fontSize / 2 : (c2.textBlock.angle = 90, f2(n.startValue) ? b.x += c2.textBlock.height - c2.textBlock.fontSize / 2 + n.thickness / 2 : b.x += c2.textBlock.height / 2 - c2.textBlock.fontSize / 2), b.y = -90 === c2.textBlock.angle ? "near" === c2.stripLine.labelAlign ? this.chart.plotArea.y1 + c2.textBlock.width + 3 : "center" === c2.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + c2.textBlock.width) / 2 : this.chart.plotArea.y2 - 3 : "near" === c2.stripLine.labelAlign ? this.chart.plotArea.y1 + 3 : "center" === c2.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - c2.textBlock.width) / 2 : this.chart.plotArea.y2 - c2.textBlock.width - 3) : "left" === this._position ? (c2.textBlock.maxWidth = this.options.stripLines[e].labelMaxWidth ? this.options.stripLines[e].labelMaxWidth : this.chart.plotArea.width - 3, c2.textBlock.angle = 0, c2.textBlock.measureText(), b.y - c2.textBlock.height - n.thickness / 2 > this.chart.plotArea.y1 ? f2(n.startValue) ? b.y -= c2.textBlock.height - c2.textBlock.fontSize / 2 + n.thickness / 2 : b.y -= c2.textBlock.height / 2 - c2.textBlock.fontSize / 2 : f2(n.startValue) ? b.y += c2.textBlock.height - c2.textBlock.fontSize / 2 + n.thickness / 2 : b.y += c2.textBlock.height / 2 - c2.textBlock.fontSize + 3, b.x = "near" === c2.stripLine.labelAlign ? this.chart.plotArea.x1 + 3 : "center" === c2.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - c2.textBlock.width / 2 : this.chart.plotArea.x2 - c2.textBlock.width - 3) : "right" === this._position && (c2.textBlock.maxWidth = this.options.stripLines[e].labelMaxWidth ? this.options.stripLines[e].labelMaxWidth : this.chart.plotArea.width - 3, c2.textBlock.angle = 0, c2.textBlock.measureText(), b.y - c2.textBlock.height - n.thickness / 2 > this.chart.plotArea.y1 ? f2(n.startValue) ? b.y -= c2.textBlock.height - c2.textBlock.fontSize / 2 + n.thickness / 2 : b.y -= c2.textBlock.height / 2 - c2.textBlock.fontSize / 2 : f2(n.startValue) ? b.y += c2.textBlock.height - c2.textBlock.fontSize / 2 + n.thickness / 2 : b.y -= c2.textBlock.height / 2 - c2.textBlock.fontSize / 2 + 3, b.x = "near" === c2.stripLine.labelAlign ? this.chart.plotArea.x2 - c2.textBlock.width - 3 : "center" === c2.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - c2.textBlock.width / 2 : this.chart.plotArea.x1 + 3), c2.textBlock.x = b.x, c2.textBlock.y = b.y, s2.push(c2));
            if (!m) {
              b = false;
              this.ctx.save();
              this.ctx.beginPath();
              this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
              this.ctx.clip();
              for (e = 0; e < u3.length; e++)
                n = u3[e], n.showOnTop ? k3 || (k3 = true, this.chart.addEventListener("dataAnimationIterationEnd", function() {
                  this.ctx.save();
                  this.ctx.beginPath();
                  this.ctx.rect(
                    this.chart.plotArea.x1,
                    this.chart.plotArea.y1,
                    this.chart.plotArea.width,
                    this.chart.plotArea.height
                  );
                  this.ctx.clip();
                  for (d3 = 0; d3 < u3.length; d3++)
                    n = u3[d3], n.showOnTop && n.render();
                  this.ctx.restore();
                }, n)) : n.render();
              for (e = 0; e < s2.length; e++)
                c2 = s2[e], c2.stripLine.showOnTop ? b || (b = true, this.chart.addEventListener("dataAnimationIterationEnd", function() {
                  for (d3 = 0; d3 < s2.length; d3++)
                    c2 = s2[d3], "inside" === c2.stripLine.labelPlacement && c2.stripLine.showOnTop && (h2.ctx.save(), h2.ctx.beginPath(), h2.ctx.rect(h2.chart.plotArea.x1, h2.chart.plotArea.y1, h2.chart.plotArea.width, h2.chart.plotArea.height), h2.ctx.clip(), c2.textBlock.render(true), h2.ctx.restore());
                }, c2.textBlock)) : "inside" === c2.stripLine.labelPlacement && c2.textBlock.render(true);
              this.ctx.restore();
              m = true;
            }
            if (m)
              for (b = false, e = 0; e < s2.length; e++)
                c2 = s2[e], "outside" === c2.stripLine.labelPlacement && c2.textBlock.render(true);
          }
        };
        A.prototype.renderBreaksBackground = function() {
          this.chart._breaksCanvas && (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length && this.maskCanvas) && (this.chart._breaksCanvasCtx.save(), this.chart._breaksCanvasCtx.beginPath(), this.chart._breaksCanvasCtx.rect(
            this.chart.plotArea.x1,
            this.chart.plotArea.y1,
            this.chart.plotArea.width,
            this.chart.plotArea.height
          ), this.chart._breaksCanvasCtx.clip(), this.chart._breaksCanvasCtx.drawImage(this.maskCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx.restore());
        };
        A.prototype.createMask = function() {
          if (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length) {
            var a = this.scaleBreaks._appliedBreaks;
            r ? (this.maskCanvas = ra(this.chart.width, this.chart.height), this.maskCtx = this.maskCanvas.getContext("2d")) : (this.maskCanvas = this.chart.plotArea.canvas, this.maskCtx = this.chart.plotArea.ctx);
            this.maskCtx.save();
            this.maskCtx.beginPath();
            this.maskCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
            this.maskCtx.clip();
            for (var h2 = 0; h2 < a.length; h2++)
              a[h2].endValue < this.viewportMinimum || (a[h2].startValue > this.viewportMaximum || isNaN(this.range)) || a[h2].render(this.maskCtx);
            this.maskCtx.restore();
          }
        };
        A.prototype.renderCrosshair = function(a, h2) {
          isFinite(this.minimum) && isFinite(this.maximum) && this.crosshair.render(a, h2);
        };
        A.prototype.showCrosshair = function(a) {
          f2(a) || (a < this.viewportMinimum || a > this.viewportMaximum) || ("top" === this._position || "bottom" === this._position ? this.crosshair.render(this.convertValueToPixel(a), null, a) : this.crosshair.render(null, this.convertValueToPixel(a), a));
        };
        A.prototype.renderGrid = function() {
          if (this.gridThickness && 0 < this.gridThickness) {
            var a = this.chart.ctx;
            a.save();
            var h2, c2 = this.chart.plotArea;
            a.lineWidth = this.gridThickness;
            a.strokeStyle = this.gridColor;
            a.setLineDash && a.setLineDash(R(this.gridDashType, this.gridThickness));
            if ("bottom" === this._position || "top" === this._position)
              for (b = 0; b < this._labels.length; b++)
                this._labels[b].position < this.viewportMinimum || (this._labels[b].position > this.viewportMaximum || this._labels[b].breaksLabelType) || (a.beginPath(), h2 = this.getPixelCoordinatesOnAxis(this._labels[b].position), h2 = 1 === a.lineWidth % 2 ? (h2.x << 0) + 0.5 : h2.x << 0, a.moveTo(h2, c2.y1 << 0), a.lineTo(h2, c2.y2 << 0), a.stroke());
            else if ("left" === this._position || "right" === this._position)
              for (var b = 0; b < this._labels.length; b++)
                this._labels[b].position < this.viewportMinimum || (this._labels[b].position > this.viewportMaximum || this._labels[b].breaksLabelType) || (a.beginPath(), h2 = this.getPixelCoordinatesOnAxis(this._labels[b].position), h2 = 1 === a.lineWidth % 2 ? (h2.y << 0) + 0.5 : h2.y << 0, a.moveTo(c2.x1 << 0, h2), a.lineTo(c2.x2 << 0, h2), a.stroke());
            a.restore();
          }
        };
        A.prototype.renderAxisLine = function() {
          var a = this.chart.ctx, h2 = r ? this.chart._preRenderCtx : a, c2 = Math.ceil(this.tickThickness / (this.reversed ? -2 : 2)), b = Math.ceil(this.tickThickness / (this.reversed ? 2 : -2)), e, d3;
          h2.save();
          if ("bottom" === this._position || "top" === this._position) {
            if (this.lineThickness) {
              this.reversed ? (e = this.lineCoordinates.x2, d3 = this.lineCoordinates.x1) : (e = this.lineCoordinates.x1, d3 = this.lineCoordinates.x2);
              h2.lineWidth = this.lineThickness;
              h2.strokeStyle = this.lineColor ? this.lineColor : "black";
              h2.setLineDash && h2.setLineDash(R(this.lineDashType, this.lineThickness));
              var k3 = 1 === this.lineThickness % 2 ? (this.lineCoordinates.y1 << 0) + 0.5 : this.lineCoordinates.y1 << 0;
              h2.beginPath();
              if (this.scaleBreaks && !f2(this.scaleBreaks.firstBreakIndex))
                if (f2(this.scaleBreaks.lastBreakIndex))
                  e = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + b;
                else
                  for (var u3 = this.scaleBreaks.firstBreakIndex; u3 <= this.scaleBreaks.lastBreakIndex; u3++)
                    h2.moveTo(e, k3), h2.lineTo(this.scaleBreaks._appliedBreaks[u3].startPixel + c2, k3), e = this.scaleBreaks._appliedBreaks[u3].endPixel + b;
              e && (h2.moveTo(e, k3), h2.lineTo(d3, k3));
              h2.stroke();
            }
          } else if (("left" === this._position || "right" === this._position) && this.lineThickness) {
            this.reversed ? (e = this.lineCoordinates.y1, d3 = this.lineCoordinates.y2) : (e = this.lineCoordinates.y2, d3 = this.lineCoordinates.y1);
            h2.lineWidth = this.lineThickness;
            h2.strokeStyle = this.lineColor;
            h2.setLineDash && h2.setLineDash(R(this.lineDashType, this.lineThickness));
            k3 = 1 === this.lineThickness % 2 ? (this.lineCoordinates.x1 << 0) + 0.5 : this.lineCoordinates.x1 << 0;
            h2.beginPath();
            if (this.scaleBreaks && !f2(this.scaleBreaks.firstBreakIndex))
              if (f2(this.scaleBreaks.lastBreakIndex))
                e = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + c2;
              else
                for (u3 = this.scaleBreaks.firstBreakIndex; u3 <= this.scaleBreaks.lastBreakIndex; u3++)
                  h2.moveTo(k3, e), h2.lineTo(k3, this.scaleBreaks._appliedBreaks[u3].startPixel + b), e = this.scaleBreaks._appliedBreaks[u3].endPixel + c2;
            e && (h2.moveTo(k3, e), h2.lineTo(k3, d3));
            h2.stroke();
          }
          r && (a.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx && this.chart._breaksCanvasCtx.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), h2.clearRect(
            0,
            0,
            this.chart.width,
            this.chart.height
          ));
          h2.restore();
        };
        A.prototype.getPixelCoordinatesOnAxis = function(a) {
          var h2 = {};
          if ("bottom" === this._position || "top" === this._position)
            h2.x = this.convertValueToPixel(a), h2.y = this.lineCoordinates.y1;
          if ("left" === this._position || "right" === this._position)
            h2.y = this.convertValueToPixel(a), h2.x = this.lineCoordinates.x2;
          return h2;
        };
        A.prototype.convertPixelToValue = function(a) {
          if ("undefined" === typeof a)
            return null;
          var h2 = 0, c2 = 0, b, h2 = true, e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], c2 = "number" === typeof a ? a : "left" === this._position || "right" === this._position ? a.y : a.x;
          if (this.logarithmic) {
            a = b = Math.pow(this.logarithmBase, (c2 - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit);
            if (c2 <= this.conversionParameters.reference === ("left" === this._position || "right" === this._position) !== this.reversed)
              for (c2 = 0; c2 < e.length; c2++) {
                if (!(e[c2].endValue < this.conversionParameters.minimum))
                  if (h2)
                    if (e[c2].startValue < this.conversionParameters.minimum) {
                      if (1 < e[c2].size && this.conversionParameters.minimum * Math.pow(e[c2].endValue / e[c2].startValue, Math.log(b) / Math.log(e[c2].size)) < e[c2].endValue) {
                        a = Math.pow(e[c2].endValue / e[c2].startValue, Math.log(b) / Math.log(e[c2].size));
                        break;
                      } else
                        a *= e[c2].endValue / this.conversionParameters.minimum / Math.pow(e[c2].size, Math.log(e[c2].endValue / this.conversionParameters.minimum) / Math.log(e[c2].endValue / e[c2].startValue)), b /= Math.pow(e[c2].size, Math.log(e[c2].endValue / this.conversionParameters.minimum) / Math.log(e[c2].endValue / e[c2].startValue));
                      h2 = false;
                    } else if (b > e[c2].startValue / this.conversionParameters.minimum) {
                      b /= e[c2].startValue / this.conversionParameters.minimum;
                      if (b < e[c2].size) {
                        a *= Math.pow(e[c2].endValue / e[c2].startValue, 1 === e[c2].size ? 1 : Math.log(b) / Math.log(e[c2].size)) / b;
                        break;
                      } else
                        a *= e[c2].endValue / e[c2].startValue / e[c2].size;
                      b /= e[c2].size;
                      h2 = false;
                    } else
                      break;
                  else if (b > e[c2].startValue / e[c2 - 1].endValue) {
                    b /= e[c2].startValue / e[c2 - 1].endValue;
                    if (b < e[c2].size) {
                      a *= Math.pow(e[c2].endValue / e[c2].startValue, 1 === e[c2].size ? 1 : Math.log(b) / Math.log(e[c2].size)) / b;
                      break;
                    } else
                      a *= e[c2].endValue / e[c2].startValue / e[c2].size;
                    b /= e[c2].size;
                  } else
                    break;
              }
            else
              for (c2 = e.length - 1; 0 <= c2; c2--)
                if (!(e[c2].startValue > this.conversionParameters.minimum))
                  if (h2)
                    if (e[c2].endValue > this.conversionParameters.minimum) {
                      if (1 < e[c2].size && this.conversionParameters.minimum * Math.pow(e[c2].endValue / e[c2].startValue, Math.log(b) / Math.log(e[c2].size)) > e[c2].startValue) {
                        a = Math.pow(e[c2].endValue / e[c2].startValue, Math.log(b) / Math.log(e[c2].size));
                        break;
                      } else
                        a *= e[c2].startValue / this.conversionParameters.minimum * Math.pow(e[c2].size, Math.log(e[c2].startValue / this.conversionParameters.minimum) / Math.log(e[c2].endValue / e[c2].startValue)) * b, b *= Math.pow(e[c2].size, Math.log(this.conversionParameters.minimum / e[c2].startValue) / Math.log(e[c2].endValue / e[c2].startValue));
                      h2 = false;
                    } else if (b < e[c2].endValue / this.conversionParameters.minimum) {
                      b /= e[c2].endValue / this.conversionParameters.minimum;
                      if (b > 1 / e[c2].size) {
                        a *= Math.pow(e[c2].endValue / e[c2].startValue, 1 >= e[c2].size ? 1 : Math.log(b) / Math.log(e[c2].size)) * b;
                        break;
                      } else
                        a /= e[c2].endValue / e[c2].startValue / e[c2].size;
                      b *= e[c2].size;
                      h2 = false;
                    } else
                      break;
                  else if (b < e[c2].endValue / e[c2 + 1].startValue) {
                    b /= e[c2].endValue / e[c2 + 1].startValue;
                    if (b > 1 / e[c2].size) {
                      a *= Math.pow(e[c2].endValue / e[c2].startValue, 1 >= e[c2].size ? 1 : Math.log(b) / Math.log(e[c2].size)) * b;
                      break;
                    } else
                      a /= e[c2].endValue / e[c2].startValue / e[c2].size;
                    b *= e[c2].size;
                  } else
                    break;
            h2 = a * this.viewportMinimum;
          } else {
            a = b = (c2 - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit;
            if (c2 <= this.conversionParameters.reference === ("left" === this._position || "right" === this._position) !== this.reversed)
              for (c2 = 0; c2 < e.length; c2++) {
                if (!(e[c2].endValue < this.conversionParameters.minimum))
                  if (h2)
                    if (e[c2].startValue < this.conversionParameters.minimum) {
                      if (e[c2].size && this.conversionParameters.minimum + b * (e[c2].endValue - e[c2].startValue) / e[c2].size < e[c2].endValue) {
                        a = 0 >= e[c2].size ? 0 : b * (e[c2].endValue - e[c2].startValue) / e[c2].size;
                        break;
                      } else
                        a += e[c2].endValue - this.conversionParameters.minimum - e[c2].size * (e[c2].endValue - this.conversionParameters.minimum) / (e[c2].endValue - e[c2].startValue), b -= e[c2].size * (e[c2].endValue - this.conversionParameters.minimum) / (e[c2].endValue - e[c2].startValue);
                      h2 = false;
                    } else if (b > e[c2].startValue - this.conversionParameters.minimum) {
                      b -= e[c2].startValue - this.conversionParameters.minimum;
                      if (b < e[c2].size) {
                        a += (e[c2].endValue - e[c2].startValue) * (0 === e[c2].size ? 1 : b / e[c2].size) - b;
                        break;
                      } else
                        a += e[c2].endValue - e[c2].startValue - e[c2].size;
                      b -= e[c2].size;
                      h2 = false;
                    } else
                      break;
                  else if (b > e[c2].startValue - e[c2 - 1].endValue) {
                    b -= e[c2].startValue - e[c2 - 1].endValue;
                    if (b < e[c2].size) {
                      a += (e[c2].endValue - e[c2].startValue) * (0 === e[c2].size ? 1 : b / e[c2].size) - b;
                      break;
                    } else
                      a += e[c2].endValue - e[c2].startValue - e[c2].size;
                    b -= e[c2].size;
                  } else
                    break;
              }
            else
              for (c2 = e.length - 1; 0 <= c2; c2--)
                if (!(e[c2].startValue > this.conversionParameters.minimum))
                  if (h2)
                    if (e[c2].endValue > this.conversionParameters.minimum)
                      if (e[c2].size && this.conversionParameters.minimum + b * (e[c2].endValue - e[c2].startValue) / e[c2].size > e[c2].startValue) {
                        a = 0 >= e[c2].size ? 0 : b * (e[c2].endValue - e[c2].startValue) / e[c2].size;
                        break;
                      } else
                        a += e[c2].startValue - this.conversionParameters.minimum + e[c2].size * (this.conversionParameters.minimum - e[c2].startValue) / (e[c2].endValue - e[c2].startValue), b += e[c2].size * (this.conversionParameters.minimum - e[c2].startValue) / (e[c2].endValue - e[c2].startValue), h2 = false;
                    else if (b < e[c2].endValue - this.conversionParameters.minimum) {
                      b -= e[c2].endValue - this.conversionParameters.minimum;
                      if (b > -1 * e[c2].size) {
                        a += (e[c2].endValue - e[c2].startValue) * (0 === e[c2].size ? 1 : b / e[c2].size) + b;
                        break;
                      } else
                        a -= e[c2].endValue - e[c2].startValue - e[c2].size;
                      b += e[c2].size;
                      h2 = false;
                    } else
                      break;
                  else if (b < e[c2].endValue - e[c2 + 1].startValue) {
                    b -= e[c2].endValue - e[c2 + 1].startValue;
                    if (b > -1 * e[c2].size) {
                      a += (e[c2].endValue - e[c2].startValue) * (0 === e[c2].size ? 1 : b / e[c2].size) + b;
                      break;
                    } else
                      a -= e[c2].endValue - e[c2].startValue - e[c2].size;
                    b += e[c2].size;
                  } else
                    break;
            h2 = this.conversionParameters.minimum + a;
          }
          return h2;
        };
        A.prototype.convertValueToPixel = function(a) {
          a = this.getApparentDifference(this.conversionParameters.minimum, a, a);
          return this.logarithmic ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * Math.log(a / this.conversionParameters.minimum) / this.conversionParameters.lnLogarithmBase + 0.5 << 0 : "axisX" === this.type ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + 0.5 << 0 : this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + 0.5;
        };
        A.prototype.getApparentDifference = function(a, h2, c2, b) {
          var e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
          if (this.logarithmic) {
            c2 = f2(c2) ? h2 / a : c2;
            for (var d3 = 0; d3 < e.length && !(h2 < e[d3].startValue); d3++)
              a > e[d3].endValue || (a <= e[d3].startValue && h2 >= e[d3].endValue ? c2 = c2 / e[d3].endValue * e[d3].startValue * e[d3].size : a >= e[d3].startValue && h2 >= e[d3].endValue ? c2 = c2 / e[d3].endValue * a * Math.pow(e[d3].size, Math.log(e[d3].endValue / a) / Math.log(e[d3].endValue / e[d3].startValue)) : a <= e[d3].startValue && h2 <= e[d3].endValue ? c2 = c2 / h2 * e[d3].startValue * Math.pow(e[d3].size, Math.log(h2 / e[d3].startValue) / Math.log(e[d3].endValue / e[d3].startValue)) : !b && (a > e[d3].startValue && h2 < e[d3].endValue) && (c2 = a * Math.pow(e[d3].size, Math.log(h2 / a) / Math.log(e[d3].endValue / e[d3].startValue))));
          } else
            for (c2 = f2(c2) ? Math.abs(h2 - a) : c2, d3 = 0; d3 < e.length && !(h2 < e[d3].startValue); d3++)
              a > e[d3].endValue || (a <= e[d3].startValue && h2 >= e[d3].endValue ? c2 = c2 - e[d3].endValue + e[d3].startValue + e[d3].size : a > e[d3].startValue && h2 >= e[d3].endValue ? c2 = c2 - e[d3].endValue + a + e[d3].size * (e[d3].endValue - a) / (e[d3].endValue - e[d3].startValue) : a <= e[d3].startValue && h2 < e[d3].endValue ? c2 = c2 - h2 + e[d3].startValue + e[d3].size * (h2 - e[d3].startValue) / (e[d3].endValue - e[d3].startValue) : !b && (a > e[d3].startValue && h2 < e[d3].endValue) && (c2 = a + e[d3].size * (h2 - a) / (e[d3].endValue - e[d3].startValue)));
          return c2;
        };
        A.prototype.setViewPortRange = function(a, h2) {
          this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(a, h2);
          this.sessionVariables.newViewportMaximum = this.viewportMaximum = Math.max(a, h2);
        };
        A.prototype.getXValueAt = function(a) {
          if (!a)
            return null;
          var h2 = null;
          "left" === this._position ? h2 = this.convertPixelToValue(a.y) : "bottom" === this._position && (h2 = this.convertPixelToValue(a.x));
          return h2;
        };
        A.prototype.calculateValueToPixelConversionParameters = function(a) {
          a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
          var h2 = { pixelPerUnit: null, minimum: null, reference: null }, c2 = this.lineCoordinates.width, b = this.lineCoordinates.height, c2 = "bottom" === this._position || "top" === this._position ? c2 : b, b = Math.abs(this.range);
          if (this.logarithmic)
            for (var e = 0; e < a.length && !(this.viewportMaximum < a[e].startValue); e++)
              this.viewportMinimum > a[e].endValue || (this.viewportMinimum >= a[e].startValue && this.viewportMaximum <= a[e].endValue ? c2 = 0 : this.viewportMinimum <= a[e].startValue && this.viewportMaximum >= a[e].endValue ? (b = b / a[e].endValue * a[e].startValue, c2 = 0 < a[e].spacing.toString().indexOf("%") ? c2 * (1 - parseFloat(a[e].spacing) / 100) : c2 - Math.min(a[e].spacing, 0.1 * c2)) : this.viewportMinimum > a[e].startValue && this.viewportMaximum >= a[e].endValue ? (b = b / a[e].endValue * this.viewportMinimum, c2 = 0 < a[e].spacing.toString().indexOf("%") ? c2 * (1 - parseFloat(a[e].spacing) / 100 * Math.log(a[e].endValue / this.viewportMinimum) / Math.log(a[e].endValue / a[e].startValue)) : c2 - Math.min(a[e].spacing, 0.1 * c2) * Math.log(a[e].endValue / this.viewportMinimum) / Math.log(a[e].endValue / a[e].startValue)) : this.viewportMinimum <= a[e].startValue && this.viewportMaximum < a[e].endValue && (b = b / this.viewportMaximum * a[e].startValue, c2 = 0 < a[e].spacing.toString().indexOf("%") ? c2 * (1 - parseFloat(a[e].spacing) / 100 * Math.log(this.viewportMaximum / a[e].startValue) / Math.log(a[e].endValue / a[e].startValue)) : c2 - Math.min(a[e].spacing, 0.1 * c2) * Math.log(this.viewportMaximum / a[e].startValue) / Math.log(a[e].endValue / a[e].startValue)));
          else
            for (e = 0; e < a.length && !(this.viewportMaximum < a[e].startValue); e++)
              this.viewportMinimum > a[e].endValue || (this.viewportMinimum >= a[e].startValue && this.viewportMaximum <= a[e].endValue ? c2 = 0 : this.viewportMinimum <= a[e].startValue && this.viewportMaximum >= a[e].endValue ? (b = b - a[e].endValue + a[e].startValue, c2 = 0 < a[e].spacing.toString().indexOf("%") ? c2 * (1 - parseFloat(a[e].spacing) / 100) : c2 - Math.min(a[e].spacing, 0.1 * c2)) : this.viewportMinimum > a[e].startValue && this.viewportMaximum >= a[e].endValue ? (b = b - a[e].endValue + this.viewportMinimum, c2 = 0 < a[e].spacing.toString().indexOf("%") ? c2 * (1 - parseFloat(a[e].spacing) / 100 * (a[e].endValue - this.viewportMinimum) / (a[e].endValue - a[e].startValue)) : c2 - Math.min(a[e].spacing, 0.1 * c2) * (a[e].endValue - this.viewportMinimum) / (a[e].endValue - a[e].startValue)) : this.viewportMinimum <= a[e].startValue && this.viewportMaximum < a[e].endValue && (b = b - this.viewportMaximum + a[e].startValue, c2 = 0 < a[e].spacing.toString().indexOf("%") ? c2 * (1 - parseFloat(a[e].spacing) / 100 * (this.viewportMaximum - a[e].startValue) / (a[e].endValue - a[e].startValue)) : c2 - Math.min(a[e].spacing, 0.1 * c2) * (this.viewportMaximum - a[e].startValue) / (a[e].endValue - a[e].startValue)));
          h2.minimum = this.viewportMinimum;
          h2.maximum = this.viewportMaximum;
          h2.range = b;
          if ("bottom" === this._position || "top" === this._position)
            this.logarithmic ? (h2.lnLogarithmBase = Math.log(this.logarithmBase), h2.pixelPerUnit = (this.reversed ? -1 : 1) * c2 * h2.lnLogarithmBase / Math.log(Math.abs(b))) : h2.pixelPerUnit = (this.reversed ? -1 : 1) * c2 / Math.abs(b), h2.reference = this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1;
          if ("left" === this._position || "right" === this._position)
            this.logarithmic ? (h2.lnLogarithmBase = Math.log(this.logarithmBase), h2.pixelPerUnit = (this.reversed ? 1 : -1) * c2 * h2.lnLogarithmBase / Math.log(Math.abs(b))) : h2.pixelPerUnit = (this.reversed ? 1 : -1) * c2 / Math.abs(b), h2.reference = this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2;
          this.conversionParameters = h2;
        };
        A.prototype.calculateAxisParameters = function() {
          if (this.logarithmic)
            this.calculateLogarithmicAxisParameters();
          else {
            var a = this.chart.layoutManager.getFreeSpace(), h2 = false, c2 = false;
            "bottom" === this._position || "top" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);
            var a = "axisX" === this.type ? "xySwapped" === this.chart.plotInfo.axisPlacement ? 62 : 70 : "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 : 40, b = 4;
            "axisX" === this.type && (b = 600 > this.maxWidth ? 8 : 6);
            var a = Math.max(b, Math.floor(this.maxWidth / a)), e, d3, k3, b = 0;
            !f2(this.options.viewportMinimum) && (!f2(this.options.viewportMaximum) && this.options.viewportMinimum >= this.options.viewportMaximum) && (this.viewportMinimum = this.viewportMaximum = null);
            if (f2(this.options.viewportMinimum) && !f2(this.sessionVariables.newViewportMinimum) && !isNaN(this.sessionVariables.newViewportMinimum))
              this.viewportMinimum = this.sessionVariables.newViewportMinimum;
            else if (null === this.viewportMinimum || isNaN(this.viewportMinimum))
              this.viewportMinimum = this.minimum;
            if (f2(this.options.viewportMaximum) && !f2(this.sessionVariables.newViewportMaximum) && !isNaN(this.sessionVariables.newViewportMaximum))
              this.viewportMaximum = this.sessionVariables.newViewportMaximum;
            else if (null === this.viewportMaximum || isNaN(this.viewportMaximum))
              this.viewportMaximum = this.maximum;
            if (this.scaleBreaks) {
              for (b = 0; b < this.scaleBreaks._appliedBreaks.length; b++)
                if ((!f2(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[b].startValue || !f2(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[b].startValue || !f2(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[b].startValue) && (!f2(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[b].endValue || !f2(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[b].endValue || !f2(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[b].endValue)) {
                  this.scaleBreaks._appliedBreaks.splice(
                    b,
                    1
                  );
                  break;
                }
            }
            if ("axisX" === this.type) {
              if (this.dataSeries && 0 < this.dataSeries.length)
                for (e = 0; e < this.dataSeries.length; e++)
                  "dateTime" === this.dataSeries[e].xValueType && (c2 = true);
              e = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin;
              d3 = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax;
              0 === d3 - e && (b = "undefined" === typeof this.options.interval ? 0.4 : this.options.interval, d3 += b, e -= b);
              Infinity !== this.dataInfo.minDiff ? k3 = this.dataInfo.minDiff : 1 < d3 - e ? k3 = 0.5 * Math.abs(d3 - e) : (k3 = 1, c2 && (h2 = true));
            } else
              "axisY" === this.type && (e = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, d3 = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, isFinite(e) || isFinite(d3) ? isFinite(e) ? isFinite(d3) || (d3 = e) : e = d3 : (d3 = "undefined" === typeof this.options.interval ? -Infinity : this.options.interval, e = "undefined" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), 0 === e && 0 === d3 ? (d3 += 9, e = 0) : 0 === d3 - e ? (b = Math.min(Math.abs(0.01 * Math.abs(d3)), 5), d3 += b, e -= b) : e > d3 ? (b = Math.min(0.01 * Math.abs(this.getApparentDifference(d3, e, null, true)), 5), 0 <= d3 ? e = d3 - b : d3 = isFinite(e) ? e + b : 0) : (b = Math.min(0.01 * Math.abs(this.getApparentDifference(e, d3, null, true)), 0.05), 0 !== d3 && (d3 += b), 0 !== e && (e -= b)), k3 = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < d3 - e ? 0.5 * Math.abs(d3 - e) : 1, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 0 < e && (e = 0), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 0 > d3 && (d3 = 0));
            b = this.getApparentDifference(isNaN(this.viewportMinimum) || null === this.viewportMinimum ? e : this.viewportMinimum, isNaN(this.viewportMaximum) || null === this.viewportMaximum ? d3 : this.viewportMaximum, null, true);
            if ("axisX" === this.type && c2) {
              this.valueType = "dateTime";
              this.intervalType || (b / 1 <= a ? (this.interval = 1, this.intervalType = "millisecond") : b / 2 <= a ? (this.interval = 2, this.intervalType = "millisecond") : b / 5 <= a ? (this.interval = 5, this.intervalType = "millisecond") : b / 10 <= a ? (this.interval = 10, this.intervalType = "millisecond") : b / 20 <= a ? (this.interval = 20, this.intervalType = "millisecond") : b / 50 <= a ? (this.interval = 50, this.intervalType = "millisecond") : b / 100 <= a ? (this.interval = 100, this.intervalType = "millisecond") : b / 200 <= a ? (this.interval = 200, this.intervalType = "millisecond") : b / 250 <= a ? (this.interval = 250, this.intervalType = "millisecond") : b / 300 <= a ? (this.interval = 300, this.intervalType = "millisecond") : b / 400 <= a ? (this.interval = 400, this.intervalType = "millisecond") : b / 500 <= a ? (this.interval = 500, this.intervalType = "millisecond") : b / (1 * aa.secondDuration) <= a ? (this.interval = 1, this.intervalType = "second") : b / (2 * aa.secondDuration) <= a ? (this.interval = 2, this.intervalType = "second") : b / (5 * aa.secondDuration) <= a ? (this.interval = 5, this.intervalType = "second") : b / (10 * aa.secondDuration) <= a ? (this.interval = 10, this.intervalType = "second") : b / (15 * aa.secondDuration) <= a ? (this.interval = 15, this.intervalType = "second") : b / (20 * aa.secondDuration) <= a ? (this.interval = 20, this.intervalType = "second") : b / (30 * aa.secondDuration) <= a ? (this.interval = 30, this.intervalType = "second") : b / (1 * aa.minuteDuration) <= a ? (this.interval = 1, this.intervalType = "minute") : b / (2 * aa.minuteDuration) <= a ? (this.interval = 2, this.intervalType = "minute") : b / (5 * aa.minuteDuration) <= a ? (this.interval = 5, this.intervalType = "minute") : b / (10 * aa.minuteDuration) <= a ? (this.interval = 10, this.intervalType = "minute") : b / (15 * aa.minuteDuration) <= a ? (this.interval = 15, this.intervalType = "minute") : b / (20 * aa.minuteDuration) <= a ? (this.interval = 20, this.intervalType = "minute") : b / (30 * aa.minuteDuration) <= a ? (this.interval = 30, this.intervalType = "minute") : b / (1 * aa.hourDuration) <= a ? (this.interval = 1, this.intervalType = "hour") : b / (2 * aa.hourDuration) <= a ? (this.interval = 2, this.intervalType = "hour") : b / (3 * aa.hourDuration) <= a ? (this.interval = 3, this.intervalType = "hour") : b / (6 * aa.hourDuration) <= a ? (this.interval = 6, this.intervalType = "hour") : b / (1 * aa.dayDuration) <= a ? (this.interval = 1, this.intervalType = "day") : b / (2 * aa.dayDuration) <= a ? (this.interval = 2, this.intervalType = "day") : b / (4 * aa.dayDuration) <= a ? (this.interval = 4, this.intervalType = "day") : b / (1 * aa.weekDuration) <= a ? (this.interval = 1, this.intervalType = "week") : b / (2 * aa.weekDuration) <= a ? (this.interval = 2, this.intervalType = "week") : b / (3 * aa.weekDuration) <= a ? (this.interval = 3, this.intervalType = "week") : b / (1 * aa.monthDuration) <= a ? (this.interval = 1, this.intervalType = "month") : b / (2 * aa.monthDuration) <= a ? (this.interval = 2, this.intervalType = "month") : b / (3 * aa.monthDuration) <= a ? (this.interval = 3, this.intervalType = "month") : b / (6 * aa.monthDuration) <= a ? (this.interval = 6, this.intervalType = "month") : (this.interval = b / (1 * aa.yearDuration) <= a ? 1 : b / (2 * aa.yearDuration) <= a ? 2 : b / (4 * aa.yearDuration) <= a ? 4 : Math.floor(A.getNiceNumber(b / (a - 1), true) / aa.yearDuration), this.intervalType = "year"));
              if (null === this.viewportMinimum || isNaN(this.viewportMinimum))
                this.viewportMinimum = e - k3 / 2;
              if (null === this.viewportMaximum || isNaN(this.viewportMaximum))
                this.viewportMaximum = d3 + k3 / 2;
              h2 ? this.autoValueFormatString = "MMM DD YYYY HH:mm" : "year" === this.intervalType ? this.autoValueFormatString = "YYYY" : "month" === this.intervalType ? this.autoValueFormatString = "MMM YYYY" : "week" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "day" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "hour" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "minute" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "second" === this.intervalType ? this.autoValueFormatString = "hh:mm:ss TT" : "millisecond" === this.intervalType && (this.autoValueFormatString = "fff'ms'");
              this.valueFormatString || (this.valueFormatString = this.autoValueFormatString);
            } else {
              this.intervalType = "number";
              b = A.getNiceNumber(b, false);
              this.interval = this.options && 0 < this.options.interval ? this.options.interval : A.getNiceNumber(b / (a - 1), true);
              if (null === this.viewportMinimum || isNaN(this.viewportMinimum))
                this.viewportMinimum = "axisX" === this.type ? e - k3 / 2 : Math.floor(e / this.interval) * this.interval;
              if (null === this.viewportMaximum || isNaN(this.viewportMaximum))
                this.viewportMaximum = "axisX" === this.type ? d3 + k3 / 2 : Math.ceil(d3 / this.interval) * this.interval;
              0 === this.viewportMaximum && 0 === this.viewportMinimum && (0 === this.options.viewportMinimum ? this.viewportMaximum += 10 : 0 === this.options.viewportMaximum && (this.viewportMinimum -= 10), this.options && "undefined" === typeof this.options.interval && (this.interval = A.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), true)));
            }
            if (null === this.minimum || null === this.maximum)
              if ("axisX" === this.type ? (e = null !== this.minimum ? this.minimum : this.dataInfo.min, d3 = null !== this.maximum ? this.maximum : this.dataInfo.max, 0 === d3 - e && (b = "undefined" === typeof this.options.interval ? 0.4 : this.options.interval, d3 += b, e -= b), k3 = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < d3 - e ? 0.5 * Math.abs(d3 - e) : 1) : "axisY" === this.type && (e = null !== this.minimum ? this.minimum : this.dataInfo.min, d3 = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(e) || isFinite(d3) ? 0 === e && 0 === d3 ? (d3 += 9, e = 0) : 0 === d3 - e ? (b = Math.min(Math.abs(0.01 * Math.abs(d3)), 5), d3 += b, e -= b) : e > d3 ? (b = Math.min(0.01 * Math.abs(this.getApparentDifference(d3, e, null, true)), 5), 0 <= d3 ? e = d3 - b : d3 = isFinite(e) ? e + b : 0) : (b = Math.min(0.01 * Math.abs(this.getApparentDifference(e, d3, null, true)), 0.05), 0 !== d3 && (d3 += b), 0 !== e && (e -= b)) : (d3 = "undefined" === typeof this.options.interval ? -Infinity : this.options.interval, e = "undefined" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), k3 = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < d3 - e ? 0.5 * Math.abs(d3 - e) : 1, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 0 < e && (e = 0), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 0 > d3 && (d3 = 0)), Math.abs(this.getApparentDifference(e, d3, null, true)), "axisX" === this.type && c2) {
                this.valueType = "dateTime";
                if (null === this.minimum || isNaN(this.minimum))
                  this.minimum = e - k3 / 2, this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? Infinity : this.sessionVariables.viewportMinimum);
                if (null === this.maximum || isNaN(this.maximum))
                  this.maximum = d3 + k3 / 2, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -Infinity : this.sessionVariables.viewportMaximum);
              } else
                this.intervalType = this.valueType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? e - k3 / 2 : Math.floor(e / this.interval) * this.interval, this.minimum = Math.min(
                  this.minimum,
                  null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? Infinity : this.sessionVariables.viewportMinimum
                )), null === this.maximum && (this.maximum = "axisX" === this.type ? d3 + k3 / 2 : Math.ceil(d3 / this.interval) * this.interval, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -Infinity : this.sessionVariables.viewportMaximum)), 0 === this.maximum && 0 === this.minimum && (0 === this.options.minimum ? this.maximum += 10 : 0 === this.options.maximum && (this.minimum -= 10));
            f2(this.sessionVariables.newViewportMinimum) && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));
            f2(this.sessionVariables.newViewportMaximum) && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));
            this.range = this.viewportMaximum - this.viewportMinimum;
            this.intervalStartPosition = "axisX" === this.type && c2 ? this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval) : Math.floor((this.viewportMinimum + 0.2 * this.interval) / this.interval) * this.interval;
            this.valueFormatString || (this.valueFormatString = A.generateValueFormatString(this.range, 2));
          }
        };
        A.prototype.calculateLogarithmicAxisParameters = function() {
          var a = this.chart.layoutManager.getFreeSpace(), h2 = Math.log(this.logarithmBase), c2;
          "bottom" === this._position || "top" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);
          var a = "axisX" === this.type ? 500 > this.maxWidth ? 7 : Math.max(7, Math.floor(this.maxWidth / 100)) : Math.max(Math.floor(this.maxWidth / 50), 3), b, d3, l2, k3;
          k3 = 1;
          if (null === this.viewportMinimum || isNaN(this.viewportMinimum))
            this.viewportMinimum = this.minimum;
          if (null === this.viewportMaximum || isNaN(this.viewportMaximum))
            this.viewportMaximum = this.maximum;
          if (this.scaleBreaks) {
            for (k3 = 0; k3 < this.scaleBreaks._appliedBreaks.length; k3++)
              if ((!f2(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[k3].startValue || !f2(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[k3].startValue || !f2(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[k3].startValue) && (!f2(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[k3].endValue || !f2(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[k3].endValue || !f2(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[k3].endValue)) {
                this.scaleBreaks._appliedBreaks.splice(k3, 1);
                break;
              }
          }
          "axisX" === this.type ? (b = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, d3 = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 1 === d3 / b && (k3 = Math.pow(this.logarithmBase, "undefined" === typeof this.options.interval ? 0.4 : this.options.interval), d3 *= k3, b /= k3), l2 = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : d3 / b > this.logarithmBase ? d3 / b * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : "axisY" === this.type && (b = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, d3 = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 0 >= b && !isFinite(d3) ? (d3 = "undefined" === typeof this.options.interval ? 0 : this.options.interval, b = 1) : 0 >= b ? b = d3 : isFinite(d3) || (d3 = b), 1 === b && 1 === d3 ? (d3 *= this.logarithmBase - 1 / this.logarithmBase, b = 1) : 1 === d3 / b ? (k3 = Math.min(d3 * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), d3 *= k3, b /= k3) : b > d3 ? (k3 = Math.min(b / d3 * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), 1 <= d3 ? b = d3 / k3 : d3 = b * k3) : (k3 = Math.min(d3 / b * Math.pow(
            this.logarithmBase,
            0.01
          ), Math.pow(this.logarithmBase, 0.04)), 1 !== d3 && (d3 *= k3), 1 !== b && (b /= k3)), l2 = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : d3 / b > this.logarithmBase ? d3 / b * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 1 < b && (b = 1), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 1 > d3 && (d3 = 1));
          k3 = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? d3 : this.viewportMaximum) / (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? b : this.viewportMinimum);
          var u3 = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? d3 : this.viewportMaximum) - (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? b : this.viewportMinimum);
          this.intervalType = "number";
          k3 = Math.pow(this.logarithmBase, A.getNiceNumber(Math.abs(Math.log(k3) / h2), false));
          this.options && 0 < this.options.interval ? this.interval = this.options.interval : (this.interval = A.getNiceExponent(Math.log(k3) / h2 / (a - 1), true), c2 = A.getNiceNumber(u3 / (a - 1), true));
          if (null === this.viewportMinimum || isNaN(this.viewportMinimum))
            this.viewportMinimum = "axisX" === this.type ? b / Math.sqrt(l2) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(b) / h2 / this.interval));
          if (null === this.viewportMaximum || isNaN(this.viewportMaximum))
            this.viewportMaximum = "axisX" === this.type ? d3 * Math.sqrt(l2) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(d3) / h2 / this.interval));
          1 === this.viewportMaximum && 1 === this.viewportMinimum && (1 === this.options.viewportMinimum ? this.viewportMaximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.viewportMaximum && (this.viewportMinimum /= this.logarithmBase - 1 / this.logarithmBase), this.options && "undefined" === typeof this.options.interval && (this.interval = A.getNiceExponent(Math.ceil(Math.log(k3) / h2) / (a - 1)), c2 = A.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), true)));
          if (null === this.minimum || null === this.maximum)
            "axisX" === this.type ? (b = null !== this.minimum ? this.minimum : this.dataInfo.min, d3 = null !== this.maximum ? this.maximum : this.dataInfo.max, 1 === d3 / b && (k3 = Math.pow(
              this.logarithmBase,
              "undefined" === typeof this.options.interval ? 0.4 : this.options.interval
            ), d3 *= k3, b /= k3), l2 = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : d3 / b > this.logarithmBase ? d3 / b * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : "axisY" === this.type && (b = null !== this.minimum ? this.minimum : this.dataInfo.min, d3 = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(b) || isFinite(d3) ? 1 === b && 1 === d3 ? (d3 *= this.logarithmBase, b /= this.logarithmBase) : 1 === d3 / b ? (k3 = Math.pow(this.logarithmBase, this.interval), d3 *= k3, b /= k3) : b > d3 ? (k3 = Math.min(0.01 * (b / d3), 5), 1 <= d3 ? b = d3 / k3 : d3 = b * k3) : (k3 = Math.min(d3 / b * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== d3 && (d3 *= k3), 1 !== b && (b /= k3)) : (d3 = "undefined" === typeof this.options.interval ? 0 : this.options.interval, b = 1), l2 = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : d3 / b > this.logarithmBase ? d3 / b * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 1 < b && (b = 1), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 1 > d3 && (d3 = 1)), this.intervalType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? b / Math.sqrt(l2) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(b) / h2 / this.interval)), f2(null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? "undefined" === typeof this.sessionVariables.newViewportMinimum ? Infinity : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum) || (this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? "undefined" === typeof this.sessionVariables.newViewportMinimum ? Infinity : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum))), null === this.maximum && (this.maximum = "axisX" === this.type ? d3 * Math.sqrt(l2) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(d3) / h2 / this.interval)), f2(null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? "undefined" === typeof this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum) || (this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? "undefined" === typeof this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum))), 1 === this.maximum && 1 === this.minimum && (1 === this.options.minimum ? this.maximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.maximum && (this.minimum /= this.logarithmBase - 1 / this.logarithmBase));
          this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum);
          this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum);
          this.viewportMinimum > this.viewportMaximum && (!this.options.viewportMinimum && !this.options.minimum || this.options.viewportMaximum || this.options.maximum ? this.options.viewportMinimum || this.options.minimum || !this.options.viewportMaximum && !this.options.maximum || (this.viewportMinimum = this.minimum = (this.options.viewportMaximum || this.options.maximum) / Math.pow(this.logarithmBase, 2 * Math.ceil(this.interval))) : this.viewportMaximum = this.maximum = this.options.viewportMinimum || this.options.minimum);
          b = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (h2 * this.interval) + 0.2) * this.interval);
          this.range = this.viewportMaximum / this.viewportMinimum;
          this.noTicks = a;
          if (!this.options.interval && this.range < Math.pow(this.logarithmBase, 8 > this.viewportMaximum || 3 > a ? 2 : 3)) {
            for (h2 = Math.floor(this.viewportMinimum / c2 + 0.5) * c2; h2 < this.viewportMinimum; )
              h2 += c2;
            this.equidistantInterval = false;
            this.intervalStartPosition = h2;
            this.interval = c2;
          } else
            this.options.interval || (c2 = Math.ceil(this.interval), this.range > this.interval && (this.interval = c2, b = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (h2 * this.interval) + 0.2) * this.interval))), this.equidistantInterval = true, this.intervalStartPosition = b;
          if (!this.valueFormatString && (this.valueFormatString = "#,##0.##", 1 > this.viewportMinimum)) {
            h2 = Math.floor(Math.abs(Math.log(this.viewportMinimum) / Math.LN10)) + 2;
            if (isNaN(h2) || !isFinite(h2))
              h2 = 2;
            if (2 < h2)
              for (k3 = 0; k3 < h2 - 2; k3++)
                this.valueFormatString += "#";
          }
        };
        A.generateValueFormatString = function(a, d3) {
          var c2 = "#,##0.", b = d3;
          1 > a && (b += Math.floor(Math.abs(Math.log(a) / Math.LN10)), isNaN(b) || !isFinite(b)) && (b = d3);
          for (var e = 0; e < b; e++)
            c2 += "#";
          return c2;
        };
        A.getNiceExponent = function(a, d3) {
          var c2 = Math.floor(Math.log(a) / Math.LN10), b = a / Math.pow(10, c2), b = 0 > c2 ? 1 >= b ? 1 : 5 >= b ? 5 : 10 : Math.max(Math.floor(b), 1);
          return -20 > c2 ? Number(b * Math.pow(10, c2)) : Number((b * Math.pow(10, c2)).toFixed(20));
        };
        A.getNiceNumber = function(a, d3) {
          var c2 = Math.floor(Math.log(a) / Math.LN10), b = a / Math.pow(10, c2), b = d3 ? 1.5 > b ? 1 : 3 > b ? 2 : 7 > b ? 5 : 10 : 1 >= b ? 1 : 2 >= b ? 2 : 5 >= b ? 5 : 10;
          return -20 > c2 ? Number(b * Math.pow(10, c2)) : Number((b * Math.pow(10, c2)).toFixed(20));
        };
        A.prototype.getLabelStartPoint = function() {
          var a = aa[this.intervalType + "Duration"] * this.interval, a = new Date(Math.floor(this.viewportMinimum / a) * a);
          if ("millisecond" !== this.intervalType)
            if ("second" === this.intervalType)
              0 < a.getMilliseconds() && (a.setSeconds(a.getSeconds() + 1), a.setMilliseconds(0));
            else if ("minute" === this.intervalType) {
              if (0 < a.getSeconds() || 0 < a.getMilliseconds())
                a.setMinutes(a.getMinutes() + 1), a.setSeconds(0), a.setMilliseconds(0);
            } else if ("hour" === this.intervalType) {
              if (0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds())
                a.setHours(a.getHours() + 1), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);
            } else if ("day" === this.intervalType) {
              if (0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds())
                a.setDate(a.getDate() + 1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);
            } else if ("week" === this.intervalType) {
              if (0 < a.getDay() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds())
                a.setDate(a.getDate() + (7 - a.getDay())), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);
            } else if ("month" === this.intervalType) {
              if (1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds())
                a.setMonth(a.getMonth() + 1), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);
            } else
              "year" === this.intervalType && (0 < a.getMonth() || 1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setFullYear(a.getFullYear() + 1), a.setMonth(0), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0));
          return a;
        };
        ga(M2, $);
        ga(T2, $);
        T2.prototype.createUserOptions = function(a) {
          if ("undefined" !== typeof a || this.options._isPlaceholder) {
            var d3 = 0;
            this.parent.options._isPlaceholder && this.parent.createUserOptions();
            this.options._isPlaceholder || (Ea(this.parent[this.optionsName]), d3 = this.parent.options[this.optionsName].indexOf(this.options));
            this.options = "undefined" === typeof a ? {} : a;
            this.parent.options[this.optionsName][d3] = this.options;
          }
        };
        T2.prototype.render = function(a) {
          if (0 !== this.spacing || 0 !== this.options.lineThickness && ("undefined" !== typeof this.options.lineThickness || 0 !== this.parent.lineThickness)) {
            var d3 = this.ctx, c2 = this.ctx.globalAlpha;
            this.ctx = a || this.ctx;
            this.ctx.save();
            this.ctx.beginPath();
            this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
            this.ctx.clip();
            var b = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.startValue), e = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.endValue);
            this.ctx.strokeStyle = this.lineColor;
            this.ctx.fillStyle = this.color;
            this.ctx.beginPath();
            this.ctx.globalAlpha = 1;
            V(this.id);
            var f3, k3, u3, s2, m, n;
            a = Math.max(this.spacing, 3);
            var p = Math.max(0, this.lineThickness);
            this.ctx.lineWidth = p;
            this.ctx.setLineDash && this.ctx.setLineDash(R(this.lineDashType, p));
            if ("bottom" === this.scaleBreaks.parent._position || "top" === this.scaleBreaks.parent._position)
              if (b = 1 === p % 2 ? (b.x << 0) + 0.5 : b.x << 0, k3 = 1 === p % 2 ? (e.x << 0) + 0.5 : e.x << 0, "top" === this.scaleBreaks.parent._position ? (e = this.chart.plotArea.y1, u3 = this.chart.plotArea.y2 + p / 2 + 0.5 << 0) : (e = this.chart.plotArea.y2, u3 = this.chart.plotArea.y1 - p / 2 + 0.5 << 0, a *= -1), this.bounds = { x1: b - p / 2, y1: e, x2: k3 + p / 2, y2: u3 }, this.ctx.moveTo(b, e), "straight" === this.type || "top" === this.scaleBreaks.parent._position && 0 >= a || "bottom" === this.scaleBreaks.parent._position && 0 <= a)
                this.ctx.lineTo(b, u3), this.ctx.lineTo(k3, u3), this.ctx.lineTo(k3, e);
              else if ("wavy" === this.type) {
                s2 = b;
                m = e;
                f3 = 0.5;
                n = (u3 - m) / a / 3;
                for (var q = 0; q < n; q++)
                  this.ctx.bezierCurveTo(s2 + f3 * a, m + a, s2 + f3 * a, m + 2 * a, s2, m + 3 * a), m += 3 * a, f3 *= -1;
                this.ctx.bezierCurveTo(s2 + f3 * a, m + a, s2 + f3 * a, m + 2 * a, s2, m + 3 * a);
                s2 = k3;
                f3 *= -1;
                this.ctx.lineTo(s2, m);
                for (q = 0; q < n; q++)
                  this.ctx.bezierCurveTo(s2 + f3 * a, m - a, s2 + f3 * a, m - 2 * a, s2, m - 3 * a), m -= 3 * a, f3 *= -1;
              } else {
                if ("zigzag" === this.type) {
                  f3 = -1;
                  m = e + a;
                  s2 = b + a;
                  n = (u3 - m) / a / 2;
                  for (q = 0; q < n; q++)
                    this.ctx.lineTo(s2, m), s2 += 2 * f3 * a, m += 2 * a, f3 *= -1;
                  this.ctx.lineTo(s2, m);
                  s2 += k3 - b;
                  for (q = 0; q < n + 1; q++)
                    this.ctx.lineTo(s2, m), s2 += 2 * f3 * a, m -= 2 * a, f3 *= -1;
                  this.ctx.lineTo(s2 + f3 * a, m + a);
                }
              }
            else if ("left" === this.scaleBreaks.parent._position || "right" === this.scaleBreaks.parent._position) {
              if (e = 1 === p % 2 ? (e.y << 0) + 0.5 : e.y << 0, u3 = 1 === p % 2 ? (b.y << 0) + 0.5 : b.y << 0, "left" === this.scaleBreaks.parent._position ? (b = this.chart.plotArea.x1, k3 = this.chart.plotArea.x2 + p / 2 + 0.5 << 0) : (b = this.chart.plotArea.x2, k3 = this.chart.plotArea.x1 - p / 2 + 0.5 << 0, a *= -1), this.bounds = { x1: b, y1: e - p / 2, x2: k3, y2: u3 + p / 2 }, this.ctx.moveTo(b, e), "straight" === this.type || "left" === this.scaleBreaks.parent._position && 0 >= a || "right" === this.scaleBreaks.parent._position && 0 <= a)
                this.ctx.lineTo(k3, e), this.ctx.lineTo(k3, u3), this.ctx.lineTo(b, u3);
              else if ("wavy" === this.type) {
                s2 = b;
                m = e;
                f3 = 0.5;
                n = (k3 - s2) / a / 3;
                for (q = 0; q < n; q++)
                  this.ctx.bezierCurveTo(s2 + a, m + f3 * a, s2 + 2 * a, m + f3 * a, s2 + 3 * a, m), s2 += 3 * a, f3 *= -1;
                this.ctx.bezierCurveTo(s2 + a, m + f3 * a, s2 + 2 * a, m + f3 * a, s2 + 3 * a, m);
                m = u3;
                f3 *= -1;
                this.ctx.lineTo(s2, m);
                for (q = 0; q < n; q++)
                  this.ctx.bezierCurveTo(s2 - a, m + f3 * a, s2 - 2 * a, m + f3 * a, s2 - 3 * a, m), s2 -= 3 * a, f3 *= -1;
              } else if ("zigzag" === this.type) {
                f3 = 1;
                m = e - a;
                s2 = b + a;
                n = (k3 - s2) / a / 2;
                for (q = 0; q < n; q++)
                  this.ctx.lineTo(s2, m), m += 2 * f3 * a, s2 += 2 * a, f3 *= -1;
                this.ctx.lineTo(s2, m);
                m += u3 - e;
                for (q = 0; q < n + 1; q++)
                  this.ctx.lineTo(
                    s2,
                    m
                  ), m += 2 * f3 * a, s2 -= 2 * a, f3 *= -1;
                this.ctx.lineTo(s2 + a, m + f3 * a);
              }
            }
            0 < p && this.ctx.stroke();
            this.ctx.closePath();
            this.ctx.globalAlpha = this.fillOpacity;
            this.ctx.globalCompositeOperation = "destination-over";
            this.ctx.fill();
            this.ctx.restore();
            this.ctx.globalAlpha = c2;
            this.ctx = d3;
          }
        };
        ga(Q, $);
        Q.prototype.createUserOptions = function(a) {
          if ("undefined" !== typeof a || this.options._isPlaceholder) {
            var d3 = 0;
            this.parent.options._isPlaceholder && this.parent.createUserOptions();
            this.options._isPlaceholder || (Ea(this.parent.stripLines), d3 = this.parent.options.stripLines.indexOf(this.options));
            this.options = "undefined" === typeof a ? {} : a;
            this.parent.options.stripLines[d3] = this.options;
          }
        };
        Q.prototype.render = function() {
          this.ctx.save();
          var a = this.parent.getPixelCoordinatesOnAxis(this.value), d3 = Math.abs("pixel" === this._thicknessType ? this.thickness : Math.abs(this.parent.convertValueToPixel(this.endValue) - this.parent.convertValueToPixel(this.startValue)));
          if (0 < d3) {
            var c2 = null === this.opacity ? 1 : this.opacity;
            this.ctx.strokeStyle = this.color;
            this.ctx.beginPath();
            var b = this.ctx.globalAlpha;
            this.ctx.globalAlpha = c2;
            V(this.id);
            var e, f3, k3, u3;
            this.ctx.lineWidth = d3;
            this.ctx.setLineDash && this.ctx.setLineDash(R(this.lineDashType, d3));
            if ("bottom" === this.parent._position || "top" === this.parent._position)
              e = f3 = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0, k3 = this.chart.plotArea.y1, u3 = this.chart.plotArea.y2, this.bounds = { x1: e - d3 / 2, y1: k3, x2: f3 + d3 / 2, y2: u3 };
            else if ("left" === this.parent._position || "right" === this.parent._position)
              k3 = u3 = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, e = this.chart.plotArea.x1, f3 = this.chart.plotArea.x2, this.bounds = { x1: e, y1: k3 - d3 / 2, x2: f3, y2: u3 + d3 / 2 };
            this.ctx.moveTo(e, k3);
            this.ctx.lineTo(f3, u3);
            this.ctx.stroke();
            this.ctx.globalAlpha = b;
          }
          this.ctx.restore();
        };
        ga(X2, $);
        X2.prototype.showAt = function(a) {
          if (!this.enabled)
            return false;
          var d3 = this.chart, c2 = false;
          d3.resetOverlayedCanvas();
          d3.clearedOverlayedCanvas = this.parent.type;
          this.chart.renderCrosshairs(this.parent);
          if ("xySwapped" === d3.plotInfo.axisPlacement)
            if ("bottom" === this.parent._position)
              for (var b = 0; b < d3.axisY.length; b++)
                this.parent === d3.axisY[b] && (d3.axisY[b]._crosshairValue = a >= d3.axisY[b].viewportMinimum && a <= d3.axisY[b].viewportMaximum ? a : null);
            else if ("top" === this.parent._position)
              for (b = 0; b < d3.axisY2.length; b++)
                this.parent === d3.axisY2[b] && (d3.axisY2[b]._crosshairValue = a >= d3.axisY2[b].viewportMinimum && a <= d3.axisY2[b].viewportMaximum ? a : null);
            else if ("left" === this.parent._position)
              for (b = 0; b < d3.axisX.length; b++)
                this.parent === d3.axisX[b] && (d3.axisX[b]._crosshairValue = a >= d3.axisX[b].viewportMinimum && a <= d3.axisX[b].viewportMaximum ? a : null);
            else {
              if ("right" === this.parent._position)
                for (b = 0; b < d3.axisX2.length; b++)
                  this.parent === d3.axisX2[b] && (d3.axisX2[b]._crosshairValue = a >= d3.axisX2[b].viewportMinimum && a <= d3.axisX2[b].viewportMaximum ? a : null);
            }
          else if ("bottom" === this.parent._position)
            for (b = 0; b < d3.axisX.length; b++)
              this.parent === d3.axisX[b] && (d3.axisX[b]._crosshairValue = a >= d3.axisX[b].viewportMinimum && a <= d3.axisX[b].viewportMaximum ? a : null);
          else if ("top" === this.parent._position)
            for (b = 0; b < d3.axisX2.length; b++)
              this.parent === d3.axisX2[b] && (d3.axisX2[b]._crosshairValue = a >= d3.axisX2[b].viewportMinimum && a <= d3.axisX2[b].viewportMaximum ? a : null);
          else if ("left" === this.parent._position)
            for (b = 0; b < d3.axisY.length; b++)
              this.parent === d3.axisY[b] && (d3.axisY[b]._crosshairValue = a >= d3.axisY[b].viewportMinimum && a <= d3.axisY[b].viewportMaximum ? a : null);
          else if ("right" === this.parent._position)
            for (b = 0; b < d3.axisY2.length; b++)
              this.parent === d3.axisY2[b] && (d3.axisY2[b]._crosshairValue = a >= d3.axisY2[b].viewportMinimum && a <= d3.axisY2[b].viewportMaximum ? a : null);
          for (b = 0; b < d3.axisX.length; b++)
            a = d3.axisX[b]._crosshairValue, d3.axisX[b].crosshair && (d3.axisX[b].crosshair.enabled && !f2(a) && a >= d3.axisX[b].viewportMinimum && a <= d3.axisX[b].viewportMaximum) && (d3.axisX[b].showCrosshair(a), d3.axisX[b].crosshair._updatedValue = a, this === d3.axisX[b].crosshair && (c2 = true));
          for (b = 0; b < d3.axisX2.length; b++)
            a = d3.axisX2[b]._crosshairValue, d3.axisX2[b].crosshair && (d3.axisX2[b].crosshair.enabled && !f2(a) && a >= d3.axisX2[b].viewportMinimum && a <= d3.axisX2[b].viewportMaximum) && (d3.axisX2[b].showCrosshair(a), d3.axisX2[b].crosshair._updatedValue = a, this === d3.axisX2[b].crosshair && (c2 = true));
          for (b = 0; b < d3.axisY.length; b++)
            a = d3.axisY[b]._crosshairValue, d3.axisY[b].crosshair && (d3.axisY[b].crosshair.enabled && !f2(a) && a >= d3.axisY[b].viewportMinimum && a <= d3.axisY[b].viewportMaximum) && (d3.axisY[b].showCrosshair(a), d3.axisY[b].crosshair._updatedValue = a, this === d3.axisY[b].crosshair && (c2 = true));
          for (b = 0; b < d3.axisY2.length; b++)
            a = d3.axisY2[b]._crosshairValue, d3.axisY2[b].crosshair && (d3.axisY2[b].crosshair.enabled && !f2(a) && a >= d3.axisY2[b].viewportMinimum && a <= d3.axisY2[b].viewportMaximum) && (d3.axisY2[b].showCrosshair(a), d3.axisY2[b].crosshair._updatedValue = a, this === d3.axisY2[b].crosshair && (c2 = true));
          this.chart.toolTip && this.chart.toolTip._entries && this.chart.toolTip.highlightObjects(this.chart.toolTip._entries);
          return c2;
        };
        X2.prototype.hide = function() {
          this.chart.resetOverlayedCanvas();
          this.chart.renderCrosshairs(this.parent);
          this._hidden = true;
        };
        X2.prototype.render = function(a, d3, c2) {
          var b, e, l2, k3, u3 = null, s2 = null, m = null, n = "";
          this.valueFormatString || ("dateTime" === this.parent.valueType ? this.valueFormatString = this.parent.valueFormatString : (m = 0, m = "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 < this.parent.range ? 0 : 500 < this.chart.width && 25 > this.parent.range ? 2 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0) : 50 < this.parent.range ? 0 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0), this.valueFormatString = A.generateValueFormatString(this.parent.range, m)));
          var p = null === this.opacity ? 1 : this.opacity, q = Math.abs("pixel" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness), g = this.chart.overlaidCanvasCtx, r2 = g.globalAlpha;
          g.beginPath();
          g.strokeStyle = this.color;
          g.lineWidth = q;
          g.save();
          this.labelFontSize = Math.abs(f2(this.options.labelFontSize) ? this.parent.labelFontSize : this.labelFontSize);
          this.labelMaxWidth = f2(this.options.labelMaxWidth) ? 0.3 * this.chart.width : this.labelMaxWidth;
          this.labelMaxHeight = f2(this.options.labelWrap) || this.labelWrap ? 0.3 * this.chart.height : 2 * this.labelFontSize;
          0 < q && g.setLineDash && g.setLineDash(R(this.lineDashType, q));
          m = new ma(g, {
            x: 0,
            y: 0,
            padding: { top: 2, right: 3, bottom: 2, left: 4 },
            backgroundColor: this.labelBackgroundColor,
            borderColor: this.labelBorderColor,
            borderThickness: this.labelBorderThickness,
            cornerRadius: this.labelCornerRadius,
            maxWidth: this.labelMaxWidth,
            maxHeight: this.labelMaxHeight,
            angle: this.labelAngle,
            text: n,
            horizontalAlign: "left",
            fontSize: this.labelFontSize,
            fontFamily: this.labelFontFamily,
            fontWeight: this.labelFontWeight,
            fontColor: this.labelFontColor,
            fontStyle: this.labelFontStyle,
            textBaseline: "middle"
          });
          if (this.snapToDataPoint) {
            var v2 = 0, n = [];
            if ("xySwapped" === this.chart.plotInfo.axisPlacement) {
              var w2 = null;
              if ("bottom" === this.parent._position || "top" === this.parent._position)
                v2 = this.parent.dataSeries[0].axisX.convertPixelToValue({ y: d3 });
              else if ("left" === this.parent._position || "right" === this.parent._position)
                v2 = this.parent.convertPixelToValue({ y: d3 });
              for (var t = 0; t < this.parent.dataSeries.length; t++)
                (w2 = this.parent.dataSeries[t].getDataPointAtX(v2, true)) && 0 <= w2.index && (w2.dataSeries = this.parent.dataSeries[t], null !== w2.dataPoint.y && w2.dataSeries.visible && n.push(w2));
              w2 = null;
              if (0 === n.length)
                return;
              n.sort(function(a2, b2) {
                return a2.distance - b2.distance;
              });
              var x3 = w2 = 0;
              yPercent = cumulativeY = 0;
              for (var v2 = Infinity, y2, t = 0; t < n.length; t++) {
                if ("rangeBar" === n[t].dataSeries.type || "error" === n[t].dataSeries.type) {
                  if (n[t].dataPoint.y)
                    for (var D2 = 0; D2 < n[t].dataPoint.y.length; D2++)
                      x3 = Math.abs(a - this.parent.convertValueToPixel(n[t].dataPoint.y[D2])), x3 <= v2 && (v2 = x3, w2 = t);
                } else
                  "stackedBar" === n[t].dataSeries.type ? (cumulativeY = n[t].dataSeries.dataPointEOs[n[t].index].cumulativeY, x3 = Math.abs(a - this.parent.convertValueToPixel(cumulativeY)), x3 <= v2 && (v2 = x3, w2 = t)) : "stackedBar100" === n[t].dataSeries.type ? (x3 = n[0].dataPoint.x.getTime ? n[0].dataPoint.x.getTime() : n[0].dataPoint.x, f2(y2) && (y2 = Math.abs(a - this.parent.convertValueToPixel(100 * (n[0].dataSeries.dataPointEOs[n[0].index].cumulativeY / n[0].dataSeries.plotUnit.dataPointYSums[x3])))), cumulativeY = n[t].dataSeries.dataPointEOs[n[t].index].cumulativeY, x3 = n[t].dataPoint.x.getTime ? n[t].dataPoint.x.getTime() : n[t].dataPoint.x, yPercent = 100 * (cumulativeY / n[t].dataSeries.plotUnit.dataPointYSums[x3]), x3 = Math.abs(a - this.parent.convertValueToPixel(yPercent)), x3 <= y2 && (y2 = x3, w2 = t)) : (x3 = Math.abs(a - this.parent.convertValueToPixel(n[t].dataPoint.y)), x3 <= v2 && (v2 = x3, w2 = t));
                f2(y2) || (v2 = Math.min(v2, y2));
              }
              y2 = n[w2];
              t = 0;
              if ("bottom" === this.parent._position || "top" === this.parent._position) {
                if ("rangeBar" === y2.dataSeries.type || "error" === y2.dataSeries.type) {
                  v2 = Math.abs(a - this.parent.convertValueToPixel(y2.dataPoint.y[0]));
                  for (n = 0; n < y2.dataPoint.y.length; n++)
                    x3 = Math.abs(a - this.parent.convertValueToPixel(y2.dataPoint.y[n])), x3 < v2 && (v2 = x3, t = n);
                  u3 = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(y2.dataPoint.y[t]) << 0) + 0.5 : this.parent.convertValueToPixel(y2.dataPoint.y[t]) << 0;
                  this.value = y2.dataPoint.y[t];
                  m.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y2.dataPoint.y[t] }) : f2(this.options.label) ? da(f2(c2) ? y2.dataPoint.y[t] : c2, this.valueFormatString, this.chart._cultureInfo) : this.label;
                } else
                  "stackedBar" === y2.dataSeries.type ? (v2 = Math.abs(a - this.parent.convertValueToPixel(n[0].dataPoint.y)), cumulativeY = y2.dataSeries.dataPointEOs[y2.index].cumulativeY, u3 = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(cumulativeY) << 0) + 0.5 : this.parent.convertValueToPixel(cumulativeY) << 0, this.value = cumulativeY, m.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: cumulativeY }) : f2(this.options.label) ? da(f2(c2) ? cumulativeY : c2, this.valueFormatString, this.chart._cultureInfo) : this.label) : "stackedBar100" === y2.dataSeries.type ? (v2 = Math.abs(a - this.parent.convertValueToPixel(n[0].dataPoint.y)), cumulativeY = y2.dataSeries.dataPointEOs[y2.index].cumulativeY, x3 = y2.dataPoint.x.getTime ? y2.dataPoint.x.getTime() : y2.dataPoint.x, yPercent = 100 * (cumulativeY / y2.dataSeries.plotUnit.dataPointYSums[x3]), u3 = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(yPercent) << 0) + 0.5 : this.parent.convertValueToPixel(yPercent) << 0, this.value = yPercent, m.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: yPercent }) : f2(this.options.label) ? da(
                    f2(c2) ? yPercent : c2,
                    this.valueFormatString,
                    this.chart._cultureInfo
                  ) : this.label) : (u3 = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(y2.dataPoint.y) << 0) + 0.5 : this.parent.convertValueToPixel(y2.dataPoint.y) << 0, this.value = y2.dataPoint.y, m.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y2.dataPoint.y }) : f2(this.options.label) ? da(f2(c2) ? y2.dataPoint.y : c2, this.valueFormatString, this.chart._cultureInfo) : this.label);
                b = e = u3;
                l2 = this.chart.plotArea.y1;
                k3 = this.chart.plotArea.y2;
                this.bounds = { x1: b - q / 2, y1: l2, x2: e + q / 2, y2: k3 };
                m.x = b - m.measureText().width / 2;
                m.x + m.width > this.chart.bounds.x2 ? m.x = this.chart.bounds.x2 - m.width : m.x < this.chart.bounds.x1 && (m.x = this.chart.bounds.x1);
                m.y = this.parent.lineCoordinates.y2 + ("top" === this.parent._position ? -m.height + this.parent.tickLength : m.fontSize / 2) + 2;
                m.y + m.height > this.chart.bounds.y2 ? m.y = this.chart.bounds.y2 - m.height : m.y < this.chart.bounds.y1 && (m.y = this.chart.bounds.y1);
              } else if ("left" === this.parent._position || "right" === this.parent._position) {
                l2 = k3 = s2 = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(y2.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(y2.dataPoint.x) << 0;
                b = this.chart.plotArea.x1;
                e = this.chart.plotArea.x2;
                this.bounds = { x1: b, y1: l2 - q / 2, x2: e, y2: k3 + q / 2 };
                t = false;
                if (this.parent.labels)
                  for (v2 = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += v2)
                    if (this.parent.labels[n])
                      t = true;
                    else {
                      t = false;
                      break;
                    }
                if (t) {
                  if ("axisX" === this.parent.type)
                    for (v2 = this.parent.convertPixelToValue({ y: d3 }), w2 = null, t = 0; t < this.parent.dataSeries.length; t++)
                      (w2 = this.parent.dataSeries[t].getDataPointAtX(
                        v2,
                        true
                      )) && 0 <= w2.index && (m.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y2.dataPoint.x }) : f2(this.options.label) ? w2.dataPoint.label : this.label);
                } else
                  m.text = "dateTime" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y2.dataPoint.x }) : f2(this.options.label) ? da(y2.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y2.dataPoint.x }) : f2(this.options.label) ? ea(y2.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label;
                this.value = y2.dataPoint.x;
                m.y = k3 + m.fontSize / 2 - m.measureText().height / 2 + 2;
                m.y - m.fontSize / 2 < this.chart.bounds.y1 ? m.y = this.chart.bounds.y1 + m.fontSize / 2 + 2 : m.y + m.measureText().height - m.fontSize / 2 > this.chart.bounds.y2 && (m.y = this.chart.bounds.y2 - m.measureText().height + m.fontSize / 2);
                "left" === this.parent._position ? m.x = this.parent.lineCoordinates.x2 - m.measureText().width : "right" === this.parent._position && (m.x = this.parent.lineCoordinates.x2);
              }
            } else if ("bottom" === this.parent._position || "top" === this.parent._position) {
              v2 = this.parent.convertPixelToValue({ x: a });
              for (t = 0; t < this.parent.dataSeries.length; t++)
                (w2 = this.parent.dataSeries[t].getDataPointAtX(v2, true)) && 0 <= w2.index && (w2.dataSeries = this.parent.dataSeries[t], null !== w2.dataPoint.y && w2.dataSeries.visible && n.push(w2));
              if (0 === n.length)
                return;
              n.sort(function(a2, b2) {
                return a2.distance - b2.distance;
              });
              y2 = n[0];
              b = e = u3 = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(y2.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(y2.dataPoint.x) << 0;
              l2 = this.chart.plotArea.y1;
              k3 = this.chart.plotArea.y2;
              this.bounds = { x1: b - q / 2, y1: l2, x2: e + q / 2, y2: k3 };
              t = false;
              if (this.parent.labels)
                for (v2 = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += v2)
                  if (this.parent.labels[n])
                    t = true;
                  else {
                    t = false;
                    break;
                  }
              if (t) {
                if ("axisX" === this.parent.type)
                  for (v2 = this.parent.convertPixelToValue({ x: a }), w2 = null, t = 0; t < this.parent.dataSeries.length; t++)
                    (w2 = this.parent.dataSeries[t].getDataPointAtX(v2, true)) && 0 <= w2.index && (m.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y2.dataPoint.x }) : f2(this.options.label) ? w2.dataPoint.label : this.label);
              } else
                m.text = "dateTime" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y2.dataPoint.x }) : f2(this.options.label) ? da(y2.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y2.dataPoint.x }) : f2(this.options.label) ? ea(y2.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label;
              this.value = y2.dataPoint.x;
              m.x = b - m.measureText().width / 2;
              m.x + m.width > this.chart.bounds.x2 && (m.x = this.chart.bounds.x2 - m.width);
              m.x < this.chart.bounds.x1 && (m.x = this.chart.bounds.x1);
              "bottom" === this.parent._position ? m.y = this.parent.lineCoordinates.y2 + m.fontSize / 2 + 2 : "top" === this.parent._position && (m.y = this.parent.lineCoordinates.y1 - m.height + m.fontSize / 2 + 2);
            } else if ("left" === this.parent._position || "right" === this.parent._position) {
              !f2(this.parent.dataSeries) && 0 < this.parent.dataSeries.length && (v2 = this.parent.dataSeries[0].axisX.convertPixelToValue({ x: a }));
              for (t = 0; t < this.parent.dataSeries.length; t++)
                (w2 = this.parent.dataSeries[t].getDataPointAtX(v2, true)) && 0 <= w2.index && (w2.dataSeries = this.parent.dataSeries[t], null !== w2.dataPoint.y && w2.dataSeries.visible && n.push(w2));
              if (0 === n.length)
                return;
              n.sort(function(a2, b2) {
                return a2.distance - b2.distance;
              });
              x3 = w2 = 0;
              v2 = Infinity;
              for (t = 0; t < n.length; t++) {
                if ("rangeColumn" === n[t].dataSeries.type || "rangeArea" === n[t].dataSeries.type || "error" === n[t].dataSeries.type || "rangeSplineArea" === n[t].dataSeries.type || "candlestick" === n[t].dataSeries.type || "ohlc" === n[t].dataSeries.type || "boxAndWhisker" === n[t].dataSeries.type) {
                  if (n[t].dataPoint.y)
                    for (D2 = 0; D2 < n[t].dataPoint.y.length; D2++)
                      x3 = Math.abs(d3 - this.parent.convertValueToPixel(n[t].dataPoint.y[D2])), x3 <= v2 && (v2 = x3, w2 = t);
                } else
                  "stackedColumn" === n[t].dataSeries.type ? (b = n[t].dataSeries.dataPointEOs[n[t].index].cumulativeY, x3 = Math.abs(d3 - this.parent.convertValueToPixel(b)), x3 <= v2 && (v2 = x3, w2 = t)) : "stackedArea" === n[t].dataSeries.type ? (b = n[t].dataSeries.dataPointEOs[n[t].index].cumulativeY, x3 = Math.abs(d3 - this.parent.convertValueToPixel(b)), x3 <= v2 && (v2 = x3, w2 = t)) : "stackedColumn100" === n[t].dataSeries.type || "stackedArea100" === n[t].dataSeries.type ? (x3 = n[0].dataPoint.x.getTime ? n[0].dataPoint.x.getTime() : n[0].dataPoint.x, f2(y2) && (y2 = Math.abs(d3 - this.parent.convertValueToPixel(100 * (n[0].dataSeries.dataPointEOs[n[0].index].cumulativeY / n[0].dataSeries.plotUnit.dataPointYSums[x3])))), "stackedColumn100" === n[t].dataSeries.type ? (s2 = n[t].dataSeries.dataPointEOs[n[t].index].cumulativeY, x3 = n[t].dataPoint.x.getTime ? n[t].dataPoint.x.getTime() : n[t].dataPoint.x, b = 100 * (s2 / n[t].dataSeries.plotUnit.dataPointYSums[x3]), x3 = Math.abs(d3 - this.parent.convertValueToPixel(b)), x3 <= y2 && (y2 = x3, w2 = t)) : "stackedArea100" === n[t].dataSeries.type && (s2 = n[t].dataSeries.dataPointEOs[n[t].index].cumulativeY, x3 = n[t].dataPoint.x.getTime ? n[t].dataPoint.x.getTime() : n[t].dataPoint.x, b = 100 * (s2 / n[t].dataSeries.plotUnit.dataPointYSums[x3]), x3 = Math.abs(d3 - this.parent.convertValueToPixel(b)), x3 <= y2 && (y2 = x3, w2 = t))) : "waterfall" === n[t].dataSeries.type ? (x3 = Math.abs(d3 - this.parent.convertValueToPixel(n[t].dataSeries.dataPointEOs[n[t].index].cumulativeSum)), x3 <= v2 && (y2 = v2 = x3, w2 = t)) : (x3 = Math.abs(d3 - this.parent.convertValueToPixel(n[t].dataPoint.y)), x3 <= v2 && (v2 = x3, w2 = t));
                f2(y2) || (v2 = Math.min(v2, y2));
              }
              y2 = n[w2];
              t = 0;
              if ("rangeColumn" === y2.dataSeries.type || "rangeArea" === y2.dataSeries.type || "error" === y2.dataSeries.type || "rangeSplineArea" === y2.dataSeries.type || "candlestick" === y2.dataSeries.type || "ohlc" === y2.dataSeries.type || "boxAndWhisker" === y2.dataSeries.type) {
                v2 = Math.abs(d3 - this.parent.convertValueToPixel(y2.dataPoint.y[0]));
                for (n = 0; n < y2.dataPoint.y.length; n++)
                  x3 = Math.abs(d3 - this.parent.convertValueToPixel(y2.dataPoint.y[n])), x3 < v2 && (v2 = x3, t = n);
                s2 = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(y2.dataPoint.y[t]) << 0) + 0.5 : this.parent.convertValueToPixel(y2.dataPoint.y[t]) << 0;
                m.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y2.dataPoint.y[t] }) : f2(this.options.label) ? da(f2(c2) ? y2.dataPoint.y[t] : c2, this.valueFormatString, this.chart._cultureInfo) : this.label;
                this.value = y2.dataPoint.y[t];
              } else
                "stackedColumn" === y2.dataSeries.type ? (b = y2.dataSeries.dataPointEOs[y2.index].cumulativeY, s2 = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(b) << 0) + 0.5 : this.parent.convertValueToPixel(b) << 0, m.text = this.labelFormatter ? this.labelFormatter({
                  chart: this.chart,
                  axis: this.parent.options,
                  crosshair: this.options,
                  value: b
                }) : f2(this.options.label) ? da(f2(c2) ? b : c2, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = b) : "stackedArea" === y2.dataSeries.type ? (b = y2.dataSeries.dataPointEOs[y2.index].cumulativeY, s2 = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(b) << 0) + 0.5 : this.parent.convertValueToPixel(b) << 0, m.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b }) : f2(this.options.label) ? da(f2(c2) ? b : c2, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = b) : "stackedColumn100" === y2.dataSeries.type ? (s2 = y2.dataSeries.dataPointEOs[y2.index].cumulativeY, x3 = y2.dataPoint.x.getTime ? y2.dataPoint.x.getTime() : y2.dataPoint.x, b = 100 * (s2 / y2.dataSeries.plotUnit.dataPointYSums[x3]), s2 = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(b) << 0) + 0.5 : this.parent.convertValueToPixel(b) << 0, m.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b }) : f2(this.options.label) ? da(f2(c2) ? b : c2, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = b) : "stackedArea100" === y2.dataSeries.type ? (s2 = y2.dataSeries.dataPointEOs[y2.index].cumulativeY, x3 = y2.dataPoint.x.getTime ? y2.dataPoint.x.getTime() : y2.dataPoint.x, b = 100 * (s2 / y2.dataSeries.plotUnit.dataPointYSums[x3]), s2 = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(b) << 0) + 0.5 : this.parent.convertValueToPixel(b) << 0, m.text = this.labelFormatter ? this.labelFormatter({
                  chart: this.chart,
                  axis: this.parent.options,
                  crosshair: this.options,
                  value: b
                }) : f2(this.options.label) ? da(f2(c2) ? b : c2, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = b) : "waterfall" === y2.dataSeries.type ? (s2 = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(y2.dataSeries.dataPointEOs[y2.index].cumulativeSum) << 0) + 0.5 : this.parent.convertValueToPixel(y2.dataSeries.dataPointEOs[y2.index].cumulativeSum) << 0, m.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y2.dataSeries.dataPointEOs[y2.index].cumulativeSum }) : f2(this.options.label) ? da(f2(c2) ? y2.dataSeries.dataPointEOs[y2.index].cumulativeSum : c2, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = y2.dataSeries.dataPointEOs[y2.index].cumulativeSum) : (s2 = 1 === g.lineWidth % 2 ? (f2(a) ? d3 : this.parent.convertValueToPixel(y2.dataPoint.y) << 0) + 0.5 : f2(a) ? d3 : this.parent.convertValueToPixel(y2.dataPoint.y) << 0, m.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: f2(c2) ? y2.dataPoint.y : c2 }) : f2(this.options.label) ? da(f2(c2) ? y2.dataPoint.y : c2, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = y2.dataPoint.y);
              l2 = k3 = s2;
              b = this.chart.plotArea.x1;
              e = this.chart.plotArea.x2;
              this.bounds = { x1: b, y1: l2 - q / 2, x2: e, y2: k3 + q / 2 };
              m.y = k3 + m.fontSize / 2 - m.measureText().height / 2 + 2;
              m.y - m.fontSize / 2 < this.chart.bounds.y1 ? m.y = this.chart.bounds.y1 + m.fontSize / 2 + 2 : m.y + m.measureText().height - m.fontSize / 2 > this.chart.bounds.y2 && (m.y = this.chart.bounds.y2 - m.measureText().height + m.fontSize / 2);
              "left" === this.parent._position ? m.x = this.parent.lineCoordinates.x2 - m.measureText().width : "right" === this.parent._position && (m.x = this.parent.lineCoordinates.x2);
            }
            n = null;
            g.globalAlpha = p;
            if ("bottom" === this.parent._position || "top" === this.parent._position)
              "top" === this.parent._position && m.y - m.fontSize / 2 < this.chart.bounds.y1 && (m.y = this.chart.bounds.y1 + m.fontSize / 2), "bottom" === this.parent._position && this.parent.lineCoordinates.y2 - m.fontSize / 2 + m.measureText().height > this.chart.bounds.y2 && (m.y = this.chart.bounds.y2 - m.height + m.fontSize / 2 + 2), this.value >= Math.min(
                this.parent.viewportMinimum,
                this.parent.viewportMaximum
              ) && this.value <= Math.max(this.parent.viewportMinimum, this.parent.viewportMaximum) && 0 < q && (g.moveTo(b, l2), g.lineTo(e, k3), g.stroke(), this._hidden = false);
            if ("left" === this.parent._position || "right" === this.parent._position)
              "left" === this.parent._position && m.x < this.chart.bounds.x1 && (m.x = this.chart.bounds.x1), "right" === this.parent._position && m.x + m.measureText().width > this.chart.bounds.x2 && (m.x = this.chart.bounds.x2 - m.measureText().width), this.value >= Math.min(
                this.parent.viewportMinimum,
                this.parent.viewportMaximum
              ) && this.value <= Math.max(this.parent.viewportMinimum, this.parent.viewportMaximum) && 0 < q && (g.moveTo(b, l2), g.lineTo(e, k3), g.stroke(), this._hidden = false);
          } else {
            if ("bottom" === this.parent._position || "top" === this.parent._position)
              b = e = u3 = 1 === g.lineWidth % 2 ? (a << 0) + 0.5 : a << 0, l2 = this.chart.plotArea.y1, k3 = this.chart.plotArea.y2, this.bounds = { x1: b - q / 2, y1: l2, x2: e + q / 2, y2: k3 };
            else if ("left" === this.parent._position || "right" === this.parent._position)
              l2 = k3 = s2 = 1 === g.lineWidth % 2 ? (d3 << 0) + 0.5 : d3 << 0, b = this.chart.plotArea.x1, e = this.chart.plotArea.x2, this.bounds = { x1: b, y1: l2 - q / 2, x2: e, y2: k3 + q / 2 };
            if ("xySwapped" === this.chart.plotInfo.axisPlacement)
              if ("left" === this.parent._position || "right" === this.parent._position) {
                t = false;
                if (this.parent.labels)
                  for (v2 = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += v2)
                    if (this.parent.labels[n])
                      t = true;
                    else {
                      t = false;
                      break;
                    }
                if (t) {
                  if ("axisX" === this.parent.type)
                    for (v2 = this.parent.convertPixelToValue({ y: d3 }), w2 = null, t = 0; t < this.parent.dataSeries.length; t++)
                      (w2 = this.parent.dataSeries[t].getDataPointAtX(
                        v2,
                        true
                      )) && 0 <= w2.index && (m.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: f2(c2) ? this.parent.convertPixelToValue(a) : c2 }) : f2(this.options.label) ? w2.dataPoint.label : this.label);
                } else
                  m.text = "dateTime" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: f2(c2) ? this.parent.convertPixelToValue(d3) : c2 }) : f2(this.options.label) ? da(f2(c2) ? this.parent.convertPixelToValue(d3) : c2, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: f2(c2) ? this.parent.convertPixelToValue(d3) : c2 }) : f2(this.options.label) ? ea(f2(c2) ? this.parent.convertPixelToValue(d3) : c2, this.valueFormatString, this.chart._cultureInfo) : this.label;
                m.y = d3 + m.fontSize / 2 - m.measureText().height / 2 + 2;
                m.y - m.fontSize / 2 < this.chart.bounds.y1 ? m.y = this.chart.bounds.y1 + m.fontSize / 2 + 2 : m.y + m.measureText().height - m.fontSize / 2 > this.chart.bounds.y2 && (m.y = this.chart.bounds.y2 - m.measureText().height + m.fontSize / 2);
                "left" === this.parent._position ? m.x = this.parent.lineCoordinates.x1 - m.measureText().width : "right" === this.parent._position && (m.x = this.parent.lineCoordinates.x2);
              } else {
                if ("bottom" === this.parent._position || "top" === this.parent._position)
                  m.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: f2(c2) ? this.parent.convertPixelToValue(a) : c2 }) : f2(this.options.label) ? da(f2(c2) ? this.parent.convertPixelToValue(a) : c2, this.valueFormatString, this.chart._cultureInfo) : this.label, m.x = b - m.measureText().width / 2, m.x + m.width > this.chart.bounds.x2 && (m.x = this.chart.bounds.x2 - m.width), m.x < this.chart.bounds.x1 && (m.x = this.chart.bounds.x1), "bottom" === this.parent._position ? m.y = this.parent.lineCoordinates.y2 + m.fontSize / 2 + 2 : "top" === this.parent._position && (m.y = this.parent.lineCoordinates.y1 - m.height + m.fontSize / 2 + 2);
              }
            else if ("bottom" === this.parent._position || "top" === this.parent._position) {
              t = false;
              n = "";
              if (this.parent.labels)
                for (v2 = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += v2)
                  if (this.parent.labels[n])
                    t = true;
                  else {
                    t = false;
                    break;
                  }
              if (t) {
                if ("axisX" === this.parent.type)
                  for (v2 = this.parent.convertPixelToValue({ x: a }), w2 = null, t = 0; t < this.parent.dataSeries.length; t++)
                    (w2 = this.parent.dataSeries[t].getDataPointAtX(v2, true)) && 0 <= w2.index && (m.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: f2(c2) ? this.parent.convertPixelToValue(a) : c2 }) : f2(this.options.label) ? f2(c2) ? w2.dataPoint.label : c2 : this.label);
              } else
                m.text = "dateTime" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: f2(c2) ? 0 < this.parent.dataSeries.length ? this.parent.convertPixelToValue(a) : "" : c2 }) : f2(this.options.label) ? da(f2(c2) ? this.parent.convertPixelToValue(a) : c2, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({
                  chart: this.chart,
                  axis: this.parent.options,
                  crosshair: this.options,
                  value: f2(c2) ? this.parent.convertPixelToValue(a) : c2
                }) : f2(this.options.label) ? ea(f2(c2) ? this.parent.convertPixelToValue(a) : c2, this.valueFormatString, this.chart._cultureInfo) : this.label;
              m.x = b - m.measureText().width / 2;
              m.x + m.width > this.chart.bounds.x2 && (m.x = this.chart.bounds.x2 - m.width);
              m.x < this.chart.bounds.x1 && (m.x = this.chart.bounds.x1);
              "bottom" === this.parent._position ? m.y = this.parent.lineCoordinates.y2 + m.fontSize / 2 + 2 : "top" === this.parent._position && (m.y = this.parent.lineCoordinates.y1 - m.height + m.fontSize / 2 + 2);
            } else if ("left" === this.parent._position || "right" === this.parent._position)
              m.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: f2(c2) ? this.parent.convertPixelToValue(d3) : c2 }) : f2(this.options.label) ? da(f2(c2) ? this.parent.convertPixelToValue(d3) : c2, this.valueFormatString, this.chart._cultureInfo) : this.label, m.y = d3 + m.fontSize / 2 - m.measureText().height / 2 + 2, m.y - m.fontSize / 2 < this.chart.bounds.y1 ? m.y = this.chart.bounds.y1 + m.fontSize / 2 + 2 : m.y + m.measureText().height - m.fontSize / 2 > this.chart.bounds.y2 && (m.y = this.chart.bounds.y2 - m.measureText().height + m.fontSize / 2), "left" === this.parent._position ? m.x = this.parent.lineCoordinates.x2 - m.measureText().width : "right" === this.parent._position && (m.x = this.parent.lineCoordinates.x2);
            "left" === this.parent._position && m.x < this.chart.bounds.x1 ? m.x = this.chart.bounds.x1 : "right" === this.parent._position && m.x + m.measureText().width > this.chart.bounds.x2 ? m.x = this.chart.bounds.x2 - m.measureText().width : "top" === this.parent._position && m.y - m.fontSize / 2 < this.chart.bounds.y1 ? m.y = this.chart.bounds.y1 + m.fontSize / 2 : "bottom" === this.parent._position && this.parent.lineCoordinates.y2 - m.fontSize / 2 + m.measureText().height > this.chart.bounds.y2 && (m.y = this.chart.bounds.y2 - m.height + m.fontSize / 2 + 2);
            g.globalAlpha = p;
            0 < q && (g.moveTo(b, l2), g.lineTo(e, k3), g.stroke(), this._hidden = false);
            this.value = "bottom" === this.parent._position || "top" === this.parent._position ? this.parent.convertPixelToValue(a) : this.parent.convertPixelToValue(d3);
          }
          if ("bottom" === this.parent._position || "top" === this.parent._position)
            this._updatedValue = this.parent.convertPixelToValue(u3);
          if ("left" === this.parent._position || "right" === this.parent._position)
            this._updatedValue = this.parent.convertPixelToValue(s2);
          this._textBlock = m;
          this._label = c2;
          f2(c2) || this.renderLabel();
          g.restore();
          g.globalAlpha = r2;
        };
        X2.prototype.renderLabel = function() {
          this.value >= Math.min(this.parent.viewportMinimum, this.parent.viewportMaximum) && this.value <= Math.max(this.parent.viewportMinimum, this.parent.viewportMaximum) && (f2(this._textBlock) || (f2(this._textBlock.text) || !("number" === typeof this._textBlock.text.valueOf() || 0 < this._textBlock.text.length) || this._hidden) || this._textBlock.render(true), f2(this._label) && this.dispatchEvent("updated", { chart: this.chart, crosshair: this.options, axis: this.parent, value: this.value }, this.parent));
        };
        ga(pa, $);
        pa.prototype._initialize = function() {
          this.updateOption("updated");
          this.updateOption("hidden");
          if (this.enabled) {
            this.container = document.createElement("div");
            this.container.setAttribute(
              "class",
              "canvasjs-chart-tooltip"
            );
            this.container.style.position = "absolute";
            this.container.style.height = "auto";
            this.container.style.boxShadow = "1px 1px 2px 2px rgba(0,0,0,0.1)";
            this.container.style.zIndex = "1000";
            this.container.style.pointerEvents = "none";
            this.container.style.display = "none";
            var a = document.createElement("div");
            a.style.width = "auto";
            a.style.height = "auto";
            a.style.minWidth = "50px";
            a.style.lineHeight = "normal";
            a.style.margin = "0px 0px 0px 0px";
            a.style.padding = "5px";
            a.style.fontFamily = "Calibri, Arial, Georgia, serif";
            a.style.fontWeight = "normal";
            a.style.fontStyle = r ? "italic" : "normal";
            a.style.fontSize = "14px";
            a.style.color = "#000000";
            a.style.textShadow = "1px 1px 1px rgba(0, 0, 0, 0.1)";
            a.style.textAlign = "left";
            a.style.border = "2px solid gray";
            a.style.background = r ? "rgba(255,255,255,.9)" : "rgb(255,255,255)";
            a.style.textIndent = "0px";
            a.style.whiteSpace = "nowrap";
            a.style.borderRadius = "5px";
            a.style.MozUserSelect = "none";
            a.style.WebkitUserSelect = "none";
            a.style.msUserSelect = "none";
            a.style.userSelect = "none";
            r || (a.style.filter = "alpha(opacity = 90)", a.style.filter = "progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666')");
            a.innerText = "Sample Tooltip";
            this.container.appendChild(a);
            this.contentDiv = this.container.firstChild;
            this.container.style.borderRadius = this.contentDiv.style.borderRadius;
            this.chart._canvasJSContainer.appendChild(this.container);
          }
        };
        pa.prototype.mouseMoveHandler = function(a, d3) {
          this._lastUpdated && 4 > new Date().getTime() - this._lastUpdated || (this._lastUpdated = new Date().getTime(), this.chart.resetOverlayedCanvas(), this._updateToolTip(a, d3), !this._updatedEventParameters || (isNaN(this._prevX) || isNaN(this._prevY)) || this.dispatchEvent("updated", this._updatedEventParameters, this));
        };
        pa.prototype._updateToolTip = function(a, d3, c2) {
          c2 = "undefined" === typeof c2 ? true : c2;
          this.container || this._initialize();
          this.enabled || this.hide();
          if (!this.chart.disableToolTip) {
            if ("undefined" === typeof a || "undefined" === typeof d3) {
              if (isNaN(this._prevX) || isNaN(this._prevY))
                return;
              a = this._prevX;
              d3 = this._prevY;
            } else
              this._prevX = a, this._prevY = d3;
            var b = null, e = null, l2 = [], k3 = 0;
            if (this.shared && this.enabled && "none" !== this.chart.plotInfo.axisPlacement) {
              var u3 = [];
              if (this.chart.axisX)
                for (var s2 = 0; s2 < this.chart.axisX.length; s2++) {
                  for (var k3 = "xySwapped" === this.chart.plotInfo.axisPlacement ? this.chart.axisX[s2].convertPixelToValue({ y: d3 }) : this.chart.axisX[s2].convertPixelToValue({ x: a }), m = null, b = 0; b < this.chart.axisX[s2].dataSeries.length; b++)
                    (m = this.chart.axisX[s2].dataSeries[b].getDataPointAtX(k3, c2)) && 0 <= m.index && (m.dataSeries = this.chart.axisX[s2].dataSeries[b], null !== m.dataPoint.y && m.dataSeries.visible && u3.push(m));
                  m = null;
                }
              if (this.chart.axisX2)
                for (s2 = 0; s2 < this.chart.axisX2.length; s2++) {
                  k3 = "xySwapped" === this.chart.plotInfo.axisPlacement ? this.chart.axisX2[s2].convertPixelToValue({ y: d3 }) : this.chart.axisX2[s2].convertPixelToValue({ x: a });
                  m = null;
                  for (b = 0; b < this.chart.axisX2[s2].dataSeries.length; b++)
                    (m = this.chart.axisX2[s2].dataSeries[b].getDataPointAtX(k3, c2)) && 0 <= m.index && (m.dataSeries = this.chart.axisX2[s2].dataSeries[b], null !== m.dataPoint.y && m.dataSeries.visible && u3.push(m));
                  m = null;
                }
              if (0 === u3.length)
                return;
              u3.sort(function(a2, b2) {
                return a2.distance - b2.distance;
              });
              c2 = u3[0];
              for (b = 0; b < u3.length; b++)
                u3[b].dataPoint.x.valueOf() === c2.dataPoint.x.valueOf() && l2.push(u3[b]);
              u3 = null;
            } else {
              if (b = this.chart.getDataPointAtXY(a, d3, c2))
                this.currentDataPointIndex = b.dataPointIndex, this.currentSeriesIndex = b.dataSeries.index;
              else if (r)
                if (b = jb(a, d3, this.chart._eventManager.ghostCtx), 0 < b && "undefined" !== typeof this.chart._eventManager.objectMap[b]) {
                  b = this.chart._eventManager.objectMap[b];
                  if ("legendItem" === b.objectType)
                    return;
                  this.currentSeriesIndex = b.dataSeriesIndex;
                  this.currentDataPointIndex = 0 <= b.dataPointIndex ? b.dataPointIndex : -1;
                } else
                  this.currentDataPointIndex = -1;
              else
                this.currentDataPointIndex = -1;
              if (0 <= this.currentSeriesIndex) {
                e = this.chart.data[this.currentSeriesIndex];
                m = {};
                if (0 <= this.currentDataPointIndex)
                  b = e.dataPoints[this.currentDataPointIndex], m.dataSeries = e, m.dataPoint = b, m.index = this.currentDataPointIndex, m.distance = Math.abs(b.x - k3), "waterfall" === e.type && (m.cumulativeSumYStartValue = e.dataPointEOs[this.currentDataPointIndex].cumulativeSumYStartValue, m.cumulativeSum = e.dataPointEOs[this.currentDataPointIndex].cumulativeSum);
                else if (this.enabled && e && ("line" === e.type || "stepLine" === e.type || "spline" === e.type || "area" === e.type || "stepArea" === e.type || "splineArea" === e.type || "stackedArea" === e.type || "stackedArea100" === e.type || "rangeArea" === e.type || "rangeSplineArea" === e.type || "candlestick" === e.type || "ohlc" === e.type || "boxAndWhisker" === e.type))
                  k3 = e.axisX.convertPixelToValue({ x: a }), m = e.getDataPointAtX(k3, c2), f2(m) || (m.dataSeries = e, this.currentDataPointIndex = m.index, b = m.dataPoint);
                else {
                  "toolTip" === this.chart.clearedOverlayedCanvas && (this.chart.resetOverlayedCanvas(), this.chart.clearedOverlayedCanvas = null);
                  return;
                }
                if (!f2(m) && !f2(m.dataPoint) && !f2(m.dataPoint.y))
                  if (m.dataSeries.axisY)
                    if (0 < m.dataPoint.y.length) {
                      for (b = c2 = 0; b < m.dataPoint.y.length; b++)
                        m.dataPoint.y[b] < m.dataSeries.axisY.viewportMinimum ? c2-- : m.dataPoint.y[b] > m.dataSeries.axisY.viewportMaximum && c2++;
                      c2 < m.dataPoint.y.length && c2 > -m.dataPoint.y.length && l2.push(m);
                    } else
                      "column" === e.type || "bar" === e.type ? 0 > m.dataPoint.y ? 0 > m.dataSeries.axisY.viewportMinimum && m.dataSeries.axisY.viewportMaximum >= m.dataPoint.y && l2.push(m) : m.dataSeries.axisY.viewportMinimum <= m.dataPoint.y && 0 <= m.dataSeries.axisY.viewportMaximum && l2.push(m) : "bubble" === e.type ? (c2 = this.chart._eventManager.objectMap[e.dataPointIds[m.index]].size / 2, m.dataPoint.y >= m.dataSeries.axisY.viewportMinimum - c2 && m.dataPoint.y <= m.dataSeries.axisY.viewportMaximum + c2 && l2.push(m)) : "waterfall" === e.type ? (c2 = 0, m.cumulativeSumYStartValue < m.dataSeries.axisY.viewportMinimum ? c2-- : m.cumulativeSumYStartValue > m.dataSeries.axisY.viewportMaximum && c2++, m.cumulativeSum < m.dataSeries.axisY.viewportMinimum ? c2-- : m.cumulativeSum > m.dataSeries.axisY.viewportMaximum && c2++, 2 > c2 && -2 < c2 && l2.push(m)) : (0 <= m.dataSeries.type.indexOf("100") || "stackedColumn" === e.type || "stackedBar" === e.type || m.dataPoint.y >= m.dataSeries.axisY.viewportMinimum && m.dataPoint.y <= m.dataSeries.axisY.viewportMaximum) && l2.push(m);
                  else
                    l2.push(m);
              }
            }
            if (0 < l2.length) {
              if (this.highlightObjects(l2), this.enabled) {
                c2 = "";
                c2 = this.getToolTipInnerHTML({ entries: l2 });
                if (null !== c2) {
                  this.contentDiv.innerHTML = c2;
                  if (this.isToolTipDefinedInData && f2(this.options.content) && f2(this.options.contentFormatter))
                    for (k3 = this.contentDiv.getElementsByTagName("span"), b = 0; b < k3.length; b++)
                      k3[b] && (k3[b].style.color = k3[b].getAttribute("data-color"));
                  k3 = false;
                  "none" === this.container.style.display && (k3 = true, this.container.style.display = "block");
                  try {
                    this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : r ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", this.borderColor = "waterfall" === l2[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : l2[0].dataPoint.color ? l2[0].dataPoint.color : 0 < l2[0].dataPoint.y ? l2[0].dataSeries.risingColor : l2[0].dataSeries.fallingColor : "error" === l2[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : l2[0].dataSeries.color ? l2[0].dataSeries.color : l2[0].dataSeries._colorSet[e.index % l2[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : l2[0].dataPoint.color ? l2[0].dataPoint.color : l2[0].dataSeries.color ? l2[0].dataSeries.color : l2[0].dataSeries._colorSet[l2[0].index % l2[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + "px" : "2px", this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + "px" : "5px", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + "px" : "14px", this.contentDiv.style.color = this.fontColor ? this.fontColor : "#000000", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : "Calibri, Arial, Georgia, serif;", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : "normal", this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : r ? "italic" : "normal";
                  } catch (n) {
                  }
                  "pie" === l2[0].dataSeries.type || "doughnut" === l2[0].dataSeries.type || "funnel" === l2[0].dataSeries.type || "pyramid" === l2[0].dataSeries.type || "bar" === l2[0].dataSeries.type || "rangeBar" === l2[0].dataSeries.type || "stackedBar" === l2[0].dataSeries.type || "stackedBar100" === l2[0].dataSeries.type ? a = a - 10 - this.container.clientWidth : (a = l2[0].dataSeries.axisX.convertValueToPixel(l2[0].dataPoint.x) - this.container.clientWidth << 0, a -= 10);
                  0 > a && (a += this.container.clientWidth + 20);
                  a + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width) && (a = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth));
                  d3 = 1 !== l2.length || this.shared || "line" !== l2[0].dataSeries.type && "stepLine" !== l2[0].dataSeries.type && "spline" !== l2[0].dataSeries.type && "area" !== l2[0].dataSeries.type && "stepArea" !== l2[0].dataSeries.type && "splineArea" !== l2[0].dataSeries.type ? "bar" === l2[0].dataSeries.type || "rangeBar" === l2[0].dataSeries.type || "stackedBar" === l2[0].dataSeries.type || "stackedBar100" === l2[0].dataSeries.type ? l2[0].dataSeries.axisX.convertValueToPixel(l2[0].dataPoint.x) : d3 : l2[0].dataSeries.axisY.convertValueToPixel(l2[0].dataPoint.y);
                  d3 = -d3 + 10;
                  0 < d3 + this.container.clientHeight + 5 && (d3 -= d3 + this.container.clientHeight + 5 - 0);
                  this.fixMozTransitionDelay(a, d3);
                  !this.animationEnabled || k3 ? this.disableAnimation() : (this.enableAnimation(), this.container.style.MozTransition = this.mozContainerTransition);
                  this.positionLeft = a;
                  this.positionBottom = d3;
                  this.container.style.left = a + "px";
                  this.container.style.bottom = d3 + "px";
                } else
                  this.hide(false), this.enabled && this.dispatchEvent("hidden", { chart: this.chart, toolTip: this }, this);
                d3 = [];
                for (b = 0; b < l2.length; b++)
                  d3.push({ xValue: l2[b].dataPoint.x, dataPoint: l2[b].dataPoint, dataSeries: l2[b].dataSeries, dataPointIndex: l2[b].index, dataSeriesIndex: l2[b].dataSeries._index });
                this._updatedEventParameters = { chart: this.chart, toolTip: this.options, content: c2, entries: d3 };
                this._entries = l2;
              }
            } else
              this.hide(), this.enabled && this.dispatchEvent("hidden", {
                chart: this.chart,
                toolTip: this
              }, this);
          }
        };
        pa.prototype.highlightObjects = function(a) {
          var h2 = this.chart.overlaidCanvasCtx;
          f2(this.chart.clearedOverlayedCanvas) || "toolTip" === this.chart.clearedOverlayedCanvas ? (this.chart.resetOverlayedCanvas(), h2.clearRect(0, 0, this.chart.width, this.chart.height), this.chart.clearedOverlayedCanvas = "toolTip") : this.chart.clearedOverlayedCanvas = null;
          h2.save();
          var c2 = this.chart.plotArea, b = 0;
          h2.beginPath();
          h2.rect(c2.x1, c2.y1, c2.x2 - c2.x1, c2.y2 - c2.y1);
          h2.clip();
          for (c2 = 0; c2 < a.length; c2++) {
            var e = a[c2];
            if ((e = this.chart._eventManager.objectMap[e.dataSeries.dataPointIds[e.index]]) && e.objectType && "dataPoint" === e.objectType) {
              var b = this.chart.data[e.dataSeriesIndex], l2 = b.dataPoints[e.dataPointIndex], k3 = e.dataPointIndex;
              false === l2.highlightEnabled || true !== b.highlightEnabled && true !== l2.highlightEnabled || ("line" === b.type || "stepLine" === b.type || "spline" === b.type || "scatter" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "stackedArea" === b.type || "stackedArea100" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type ? (l2 = b.getMarkerProperties(k3, e.x1, e.y1, this.chart.overlaidCanvasCtx), l2.size = Math.max(1.5 * l2.size << 0, 10), l2.borderColor = l2.borderColor || "#FFFFFF", l2.borderThickness = l2.borderThickness || Math.ceil(0.1 * l2.size), v.drawMarkers([l2]), "undefined" !== typeof e.y2 && (l2 = b.getMarkerProperties(k3, e.x1, e.y2, this.chart.overlaidCanvasCtx), l2.size = Math.max(1.5 * l2.size << 0, 10), l2.borderColor = l2.borderColor || "#FFFFFF", l2.borderThickness = l2.borderThickness || Math.ceil(0.1 * l2.size), v.drawMarkers([l2]))) : "bubble" === b.type ? (l2 = b.getMarkerProperties(k3, e.x1, e.y1, this.chart.overlaidCanvasCtx), l2.size = e.size, l2.color = "white", l2.borderColor = "white", h2.globalAlpha = 0.3, v.drawMarkers([l2]), h2.globalAlpha = 1) : "column" === b.type || "stackedColumn" === b.type || "stackedColumn100" === b.type || "bar" === b.type || "rangeBar" === b.type || "stackedBar" === b.type || "stackedBar100" === b.type || "rangeColumn" === b.type || "waterfall" === b.type ? ba(h2, e.x1, e.y1, e.x2, e.y2, "white", 0, null, false, false, false, false, 0.3) : "pie" === b.type || "doughnut" === b.type ? d2(h2, e.center, e.radius, "white", b.type, e.startAngle, e.endAngle, 0.3, e.percentInnerRadius) : "funnel" === b.type || "pyramid" === b.type ? u2(h2, e.funnelSection, 0.3, "white") : "candlestick" === b.type ? (h2.globalAlpha = 1, h2.strokeStyle = e.color, h2.lineWidth = 2 * e.borderThickness, b = 0 === h2.lineWidth % 2 ? 0 : 0.5, h2.beginPath(), h2.moveTo(e.x3 - b, Math.min(e.y2, e.y3)), h2.lineTo(e.x3 - b, Math.min(e.y1, e.y4)), h2.stroke(), h2.beginPath(), h2.moveTo(e.x3 - b, Math.max(e.y1, e.y4)), h2.lineTo(e.x3 - b, Math.max(e.y2, e.y3)), h2.stroke(), ba(h2, e.x1, Math.min(e.y1, e.y4), e.x2, Math.max(e.y1, e.y4), "transparent", 2 * e.borderThickness, e.color, false, false, false, false), h2.globalAlpha = 1) : "ohlc" === b.type ? (h2.globalAlpha = 1, h2.strokeStyle = e.color, h2.lineWidth = 2 * e.borderThickness, b = 0 === h2.lineWidth % 2 ? 0 : 0.5, h2.beginPath(), h2.moveTo(e.x3 - b, e.y2), h2.lineTo(e.x3 - b, e.y3), h2.stroke(), h2.beginPath(), h2.moveTo(e.x3, e.y1), h2.lineTo(e.x1, e.y1), h2.stroke(), h2.beginPath(), h2.moveTo(e.x3, e.y4), h2.lineTo(e.x2, e.y4), h2.stroke(), h2.globalAlpha = 1) : "boxAndWhisker" === b.type ? (h2.save(), h2.globalAlpha = 1, h2.strokeStyle = e.stemColor, h2.lineWidth = 2 * e.stemThickness, 0 < e.stemThickness && (h2.beginPath(), h2.moveTo(e.x3, e.y2 + e.borderThickness / 2), h2.lineTo(e.x3, e.y1 + e.whiskerThickness / 2), h2.stroke(), h2.beginPath(), h2.moveTo(e.x3, e.y4 - e.whiskerThickness / 2), h2.lineTo(e.x3, e.y3 - e.borderThickness / 2), h2.stroke()), h2.beginPath(), ba(h2, e.x1, Math.max(e.y2, e.y3), e.x2, Math.min(e.y2, e.y3), "transparent", 2 * e.borderThickness, e.color, false, false, false, false), h2.globalAlpha = 1, h2.strokeStyle = e.whiskerColor, h2.lineWidth = 2 * e.whiskerThickness, 0 < e.whiskerThickness && (h2.beginPath(), h2.moveTo(Math.floor(e.x3 - e.whiskerLength / 2), e.y4), h2.lineTo(Math.ceil(e.x3 + e.whiskerLength / 2), e.y4), h2.stroke(), h2.beginPath(), h2.moveTo(Math.floor(e.x3 - e.whiskerLength / 2), e.y1), h2.lineTo(Math.ceil(e.x3 + e.whiskerLength / 2), e.y1), h2.stroke()), h2.globalAlpha = 1, h2.strokeStyle = e.lineColor, h2.lineWidth = 2 * e.lineThickness, 0 < e.lineThickness && (h2.beginPath(), h2.moveTo(e.x1, e.y5), h2.lineTo(e.x2, e.y5), h2.stroke()), h2.restore(), h2.globalAlpha = 1) : "error" === b.type && F2(h2, e.x1, e.y1, e.x2, e.y2, "white", e.whiskerProperties, e.stemProperties, e.isXYSwapped, 0.3));
            }
          }
          h2.restore();
          h2.globalAlpha = 1;
          h2.beginPath();
        };
        pa.prototype.getToolTipInnerHTML = function(a) {
          a = a.entries;
          var d3 = null, c2 = null, b = null, e = 0, f3 = "";
          this.isToolTipDefinedInData = true;
          for (var k3 = 0; k3 < a.length; k3++)
            if (a[k3].dataSeries.toolTipContent || a[k3].dataPoint.toolTipContent) {
              this.isToolTipDefinedInData = false;
              break;
            }
          if (this.isToolTipDefinedInData && (this.content && "function" === typeof this.content || this.contentFormatter))
            a = { chart: this.chart, toolTip: this.options, entries: a }, d3 = this.contentFormatter ? this.contentFormatter(a) : this.content(a);
          else if (this.shared && "none" !== this.chart.plotInfo.axisPlacement) {
            for (var u3 = null, s2 = "", k3 = 0; k3 < a.length; k3++) {
              c2 = a[k3].dataSeries;
              b = a[k3].dataPoint;
              e = a[k3].index;
              f3 = "";
              if (0 === k3 && this.isToolTipDefinedInData && !this.content) {
                this.chart.axisX && 0 < this.chart.axisX.length ? s2 += "undefined" !== typeof this.chart.axisX[0].labels[b.x] ? this.chart.axisX[0].labels[b.x] : "{x}" : this.chart.axisX2 && 0 < this.chart.axisX2.length && (s2 += "undefined" !== typeof this.chart.axisX2[0].labels[b.x] ? this.chart.axisX2[0].labels[b.x] : "{x}");
                s2 += "</br>";
                if (!c2.visible)
                  continue;
                s2 = this.chart.replaceKeywordsWithValue(s2, b, c2, e);
              }
              null === b.toolTipContent || "undefined" === typeof b.toolTipContent && null === c2.options.toolTipContent || ("line" === c2.type || "stepLine" === c2.type || "spline" === c2.type || "area" === c2.type || "stepArea" === c2.type || "splineArea" === c2.type || "column" === c2.type || "bar" === c2.type || "scatter" === c2.type || "stackedColumn" === c2.type || "stackedColumn100" === c2.type || "stackedBar" === c2.type || "stackedBar100" === c2.type || "stackedArea" === c2.type || "stackedArea100" === c2.type || "waterfall" === c2.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (f3 += u3 != c2.axisXIndex ? c2.axisX.title ? c2.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), f3 += b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>{name}:</span>&nbsp;&nbsp;{y}`, u3 = c2.axisXIndex) : "bubble" === c2.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (f3 += u3 != c2.axisXIndex ? c2.axisX.title ? c2.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), f3 += b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}`) : "rangeColumn" === c2.type || "rangeBar" === c2.type || "rangeArea" === c2.type || "rangeSplineArea" === c2.type || "error" === c2.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (f3 += u3 != c2.axisXIndex ? c2.axisX.title ? c2.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), f3 += b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}`) : "candlestick" === c2.type || "ohlc" === c2.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (f3 += u3 != c2.axisXIndex ? c2.axisX.title ? c2.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), f3 += b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>{name}:</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}`) : "boxAndWhisker" === c2.type && (this.chart.axisX && 1 < this.chart.axisX.length && (f3 += u3 != c2.axisXIndex ? c2.axisX.title ? c2.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), f3 += b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>{name}:</span><br/>Minimum: &nbsp;{y[0]}<br/>Q1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}`), null === d3 && (d3 = ""), c2.visible && (true === this.reversed ? (d3 = this.chart.replaceKeywordsWithValue(f3, b, c2, e) + d3, k3 < a.length - 1 && (d3 = "</br>" + d3)) : (d3 += this.chart.replaceKeywordsWithValue(f3, b, c2, e), k3 < a.length - 1 && (d3 += "</br>"))));
            }
            null !== d3 && (d3 = s2 + d3);
          } else {
            c2 = a[0].dataSeries;
            b = a[0].dataPoint;
            e = a[0].index;
            if (null === b.toolTipContent || "undefined" === typeof b.toolTipContent && null === c2.options.toolTipContent)
              return null;
            "line" === c2.type || "stepLine" === c2.type || "spline" === c2.type || "area" === c2.type || "stepArea" === c2.type || "splineArea" === c2.type || "column" === c2.type || "bar" === c2.type || "scatter" === c2.type || "stackedColumn" === c2.type || "stackedColumn100" === c2.type || "stackedBar" === c2.type || "stackedBar100" === c2.type || "stackedArea" === c2.type || "stackedArea100" === c2.type || "waterfall" === c2.type ? f3 = b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}" : "bubble" === c2.type ? f3 = b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}" : "pie" === c2.type || "doughnut" === c2.type || "funnel" === c2.type || "pyramid" === c2.type ? f3 = b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.name ? "{name}:</span>&nbsp;&nbsp;" : b.label ? "{label}:</span>&nbsp;&nbsp;" : "</span>") + "{y}" : "rangeColumn" === c2.type || "rangeBar" === c2.type || "rangeArea" === c2.type || "rangeSplineArea" === c2.type || "error" === c2.type ? f3 = b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.label ? "{label}" : "{x}") + " :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}" : "candlestick" === c2.type || "ohlc" === c2.type ? f3 = b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.label ? "{label}" : "{x}") + "</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}" : "boxAndWhisker" === c2.type && (f3 = b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.label ? "{label}" : "{x}") + "</span><br/>Minimum: &nbsp;{y[0]}<br/>Q1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}");
            null === d3 && (d3 = "");
            d3 += this.chart.replaceKeywordsWithValue(
              f3,
              b,
              c2,
              e
            );
          }
          return d3;
        };
        pa.prototype.enableAnimation = function() {
          if (!this.container.style.WebkitTransition) {
            var a = this.getContainerTransition(this.containerTransitionDuration);
            this.container.style.WebkitTransition = a;
            this.container.style.MsTransition = a;
            this.container.style.transition = a;
            this.container.style.MozTransition = this.mozContainerTransition;
          }
        };
        pa.prototype.disableAnimation = function() {
          this.container.style.WebkitTransition && (this.container.style.WebkitTransition = "", this.container.style.MozTransition = "", this.container.style.MsTransition = "", this.container.style.transition = "");
        };
        pa.prototype.hide = function(a) {
          this.container && (this.container.style.display = "none", this.currentSeriesIndex = -1, this._prevY = this._prevX = NaN, ("undefined" === typeof a || a) && this.chart.resetOverlayedCanvas());
        };
        pa.prototype.show = function(a, d3, c2) {
          this._updateToolTip(a, d3, "undefined" === typeof c2 ? false : c2);
        };
        pa.prototype.showAtIndex = function(a, d3) {
        };
        pa.prototype.showAtX = function(a, d3) {
          if (!this.enabled)
            return false;
          this.chart.clearedOverlayedCanvas = null;
          var c2, b, e, l2 = [];
          e = false;
          d3 = !f2(d3) && 0 <= d3 && d3 < this.chart.data.length ? d3 : 0;
          if (this.shared)
            for (var k3 = 0; k3 < this.chart.data.length; k3++)
              c2 = this.chart.data[k3], (b = c2.getDataPointAtX(a, false)) && (b.dataPoint && !f2(b.dataPoint.y) && c2.visible) && (b.dataSeries = c2, l2.push(b));
          else
            c2 = this.chart.data[d3], (b = c2.getDataPointAtX(a, false)) && (b.dataPoint && !f2(b.dataPoint.y) && c2.visible) && (b.dataSeries = c2, l2.push(b));
          if (0 < l2.length) {
            for (k3 = 0; k3 < l2.length; k3++)
              if (b = l2[k3], (this.shared || 0 <= b.dataSeries.type.indexOf("100")) && b.dataPoint.x >= b.dataSeries.axisX.viewportMinimum && b.dataPoint.x <= b.dataSeries.axisX.viewportMaximum) {
                e = false;
                break;
              } else if (b.dataPoint.x < b.dataSeries.axisX.viewportMinimum || b.dataPoint.x > b.dataSeries.axisX.viewportMaximum || b.dataPoint.y < b.dataSeries.axisY.viewportMinimum || b.dataPoint.y > b.dataSeries.axisY.viewportMaximum)
                e = true;
              else {
                e = false;
                break;
              }
            if (e)
              return this.hide(), false;
            this.highlightObjects(l2);
            this._entries = l2;
            k3 = "";
            k3 = this.getToolTipInnerHTML({ entries: l2 });
            if (null !== k3) {
              this.contentDiv.innerHTML = k3;
              if (this.isToolTipDefinedInData && f2(this.options.content) && f2(this.options.contentFormatter))
                for (b = this.contentDiv.getElementsByTagName("span"), k3 = 0; k3 < b.length; k3++)
                  b[k3] && (b[k3].style.color = b[k3].getAttribute("data-color"));
              k3 = false;
              "none" === this.container.style.display && (k3 = true, this.container.style.display = "block");
              try {
                this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : r ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", this.borderColor = "waterfall" === l2[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : l2[0].dataPoint.color ? l2[0].dataPoint.color : 0 < l2[0].dataPoint.y ? l2[0].dataSeries.risingColor : l2[0].dataSeries.fallingColor : "error" === l2[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : l2[0].dataSeries.color ? l2[0].dataSeries.color : l2[0].dataSeries._colorSet[c2.index % l2[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : l2[0].dataPoint.color ? l2[0].dataPoint.color : l2[0].dataSeries.color ? l2[0].dataSeries.color : l2[0].dataSeries._colorSet[l2[0].index % l2[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + "px" : "2px", this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + "px" : "5px", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + "px" : "14px", this.contentDiv.style.color = this.fontColor ? this.fontColor : "#000000", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : "Calibri, Arial, Georgia, serif;", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : "normal", this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : r ? "italic" : "normal";
              } catch (u3) {
              }
              "pie" === l2[0].dataSeries.type || "doughnut" === l2[0].dataSeries.type || "funnel" === l2[0].dataSeries.type || "pyramid" === l2[0].dataSeries.type ? c2 = mouseX - 10 - this.container.clientWidth : (c2 = "bar" === l2[0].dataSeries.type || "rangeBar" === l2[0].dataSeries.type || "stackedBar" === l2[0].dataSeries.type || "stackedBar100" === l2[0].dataSeries.type ? l2[0].dataSeries.axisY.convertValueToPixel(l2[0].dataPoint.y) - this.container.clientWidth << 0 : l2[0].dataSeries.axisX.convertValueToPixel(l2[0].dataPoint.x) - this.container.clientWidth << 0, c2 -= 10);
              0 > c2 && (c2 += this.container.clientWidth + 20);
              c2 + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width) && (c2 = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth));
              l2 = 1 !== l2.length || this.shared || "line" !== l2[0].dataSeries.type && "stepLine" !== l2[0].dataSeries.type && "spline" !== l2[0].dataSeries.type && "area" !== l2[0].dataSeries.type && "stepArea" !== l2[0].dataSeries.type && "splineArea" !== l2[0].dataSeries.type ? "bar" === l2[0].dataSeries.type || "rangeBar" === l2[0].dataSeries.type || "stackedBar" === l2[0].dataSeries.type || "stackedBar100" === l2[0].dataSeries.type ? l2[0].dataSeries.axisX.convertValueToPixel(l2[0].dataPoint.x) : l2[0].dataSeries.axisY.convertValueToPixel(l2[0].dataPoint.y) : l2[0].dataSeries.axisY.convertValueToPixel(l2[0].dataPoint.y);
              l2 = -l2 + 10;
              0 < l2 + this.container.clientHeight + 5 && (l2 -= l2 + this.container.clientHeight + 5 - 0);
              this.fixMozTransitionDelay(c2, l2);
              !this.animationEnabled || k3 ? this.disableAnimation() : (this.enableAnimation(), this.container.style.MozTransition = this.mozContainerTransition);
              this.container.style.left = c2 + "px";
              this.container.style.bottom = l2 + "px";
            } else
              return this.hide(false), false;
          } else
            return this.hide(), false;
          return true;
        };
        pa.prototype.fixMozTransitionDelay = function(a, d3) {
          if (20 < this.chart._eventManager.lastObjectId)
            this.mozContainerTransition = this.getContainerTransition(0);
          else {
            var c2 = parseFloat(this.container.style.left), c2 = isNaN(c2) ? 0 : c2, b = parseFloat(this.container.style.bottom), b = isNaN(b) ? 0 : b;
            10 < Math.sqrt(Math.pow(c2 - a, 2) + Math.pow(b - d3, 2)) ? this.mozContainerTransition = this.getContainerTransition(0.1) : this.mozContainerTransition = this.getContainerTransition(0);
          }
        };
        pa.prototype.getContainerTransition = function(a) {
          return "left " + a + "s ease-out 0s, bottom " + a + "s ease-out 0s";
        };
        ia2.prototype.reset = function() {
          this.lastObjectId = 0;
          this.objectMap = [];
          this.rectangularRegionEventSubscriptions = [];
          this.previousDataPointEventObject = null;
          this.eventObjects = [];
          r && (this.ghostCtx.clearRect(0, 0, this.chart.width, this.chart.height), this.ghostCtx.beginPath());
        };
        ia2.prototype.getNewObjectTrackingId = function() {
          return ++this.lastObjectId;
        };
        ia2.prototype.mouseEventHandler = function(a) {
          if ("mousemove" === a.type || "click" === a.type) {
            var d3 = [], c2 = Aa(a), b = null;
            if ((b = this.chart.getObjectAtXY(c2.x, c2.y, false)) && "undefined" !== typeof this.objectMap[b])
              if (b = this.objectMap[b], "dataPoint" === b.objectType) {
                var e = this.chart.data[b.dataSeriesIndex], f3 = e.dataPoints[b.dataPointIndex], k3 = b.dataPointIndex;
                b.eventParameter = { x: c2.x, y: c2.y, dataPoint: f3, dataSeries: e.options, dataPointIndex: k3, dataSeriesIndex: e.index, chart: this.chart };
                b.eventContext = {
                  context: f3,
                  userContext: f3,
                  mouseover: "mouseover",
                  mousemove: "mousemove",
                  mouseout: "mouseout",
                  click: "click"
                };
                d3.push(b);
                b = this.objectMap[e.id];
                b.eventParameter = { x: c2.x, y: c2.y, dataPoint: f3, dataSeries: e.options, dataPointIndex: k3, dataSeriesIndex: e.index, chart: this.chart };
                b.eventContext = { context: e, userContext: e.options, mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", click: "click" };
                d3.push(this.objectMap[e.id]);
              } else
                "legendItem" === b.objectType && (e = this.chart.data[b.dataSeriesIndex], f3 = null !== b.dataPointIndex ? e.dataPoints[b.dataPointIndex] : null, b.eventParameter = {
                  x: c2.x,
                  y: c2.y,
                  dataSeries: e.options,
                  dataPoint: f3,
                  dataPointIndex: b.dataPointIndex,
                  dataSeriesIndex: b.dataSeriesIndex,
                  chart: this.chart
                }, b.eventContext = { context: this.chart.legend, userContext: this.chart.legend.options, mouseover: "itemmouseover", mousemove: "itemmousemove", mouseout: "itemmouseout", click: "itemclick" }, d3.push(b));
            e = [];
            for (c2 = 0; c2 < this.mouseoveredObjectMaps.length; c2++) {
              f3 = true;
              for (b = 0; b < d3.length; b++)
                if (d3[b].id === this.mouseoveredObjectMaps[c2].id) {
                  f3 = false;
                  break;
                }
              f3 ? this.fireEvent(this.mouseoveredObjectMaps[c2], "mouseout", a) : e.push(this.mouseoveredObjectMaps[c2]);
            }
            this.mouseoveredObjectMaps = e;
            for (c2 = 0; c2 < d3.length; c2++) {
              e = false;
              for (b = 0; b < this.mouseoveredObjectMaps.length; b++)
                if (d3[c2].id === this.mouseoveredObjectMaps[b].id) {
                  e = true;
                  break;
                }
              e || (this.fireEvent(d3[c2], "mouseover", a), this.mouseoveredObjectMaps.push(d3[c2]));
              "click" === a.type ? this.fireEvent(d3[c2], "click", a) : "mousemove" === a.type && this.fireEvent(d3[c2], "mousemove", a);
            }
          }
        };
        ia2.prototype.fireEvent = function(a, d3, c2) {
          if (a && d3) {
            var b = a.eventParameter, e = a.eventContext, f3 = a.eventContext.userContext;
            f3 && (e && f3[e[d3]]) && f3[e[d3]].call(f3, b);
            "mouseout" !== d3 ? f3.cursor && f3.cursor !== c2.target.style.cursor && (c2.target.style.cursor = f3.cursor) : (c2.target.style.cursor = this.chart.panEnabled ? "itemmouseout" !== e.mouseout || f3.dockInsidePlotArea ? "move" : this.chart._defaultCursor : this.chart._defaultCursor, delete a.eventParameter, delete a.eventContext);
            "click" === d3 && ("dataPoint" === a.objectType && this.chart.pieDoughnutClickHandler) && this.chart.pieDoughnutClickHandler.call(this.chart.data[a.dataSeriesIndex], b);
            "click" === d3 && ("dataPoint" === a.objectType && this.chart.funnelPyramidClickHandler) && this.chart.funnelPyramidClickHandler.call(
              this.chart.data[a.dataSeriesIndex],
              b
            );
          }
        };
        la2.prototype.animate = function(a, d3, c2, b, e) {
          var f3 = this;
          this.chart.isAnimating = true;
          e = e || s.easing.linear;
          c2 && this.animations.push({ startTime: new Date().getTime() + (a ? a : 0), duration: d3, animationCallback: c2, onComplete: b });
          for (a = []; 0 < this.animations.length; )
            if (d3 = this.animations.shift(), c2 = new Date().getTime(), b = 0, d3.startTime <= c2 && (b = e(Math.min(c2 - d3.startTime, d3.duration), 0, 1, d3.duration), b = Math.min(b, 1), isNaN(b) || !isFinite(b)) && (b = 1), 1 > b && a.push(d3), d3.animationCallback(b), 1 <= b && d3.onComplete)
              d3.onComplete();
          this.animations = a;
          0 < this.animations.length ? this.animationRequestId = this.chart.requestAnimFrame.call(window, function() {
            f3.animate.call(f3);
          }) : this.chart.isAnimating = false;
        };
        la2.prototype.cancelAllAnimations = function() {
          this.animations = [];
          this.animationRequestId && this.chart.cancelRequestAnimFrame.call(window, this.animationRequestId);
          this.animationRequestId = null;
          this.chart.isAnimating = false;
        };
        var s = { yScaleAnimation: function(a, d3) {
          if (0 !== a) {
            var c2 = d3.dest, b = d3.source.canvas, e = d3.animationBase;
            c2.drawImage(b, 0, 0, b.width, b.height, 0, e - e * a, c2.canvas.width / ja, a * c2.canvas.height / ja);
          }
        }, xScaleAnimation: function(a, d3) {
          if (0 !== a) {
            var c2 = d3.dest, b = d3.source.canvas, e = d3.animationBase;
            c2.drawImage(b, 0, 0, b.width, b.height, e - e * a, 0, a * c2.canvas.width / ja, c2.canvas.height / ja);
          }
        }, xClipAnimation: function(a, d3) {
          if (0 !== a) {
            var c2 = d3.dest, b = d3.source.canvas;
            c2.save();
            0 < a && c2.drawImage(b, 0, 0, b.width * a, b.height, 0, 0, b.width * a / ja, b.height / ja);
            c2.restore();
          }
        }, fadeInAnimation: function(a, d3) {
          if (0 !== a) {
            var c2 = d3.dest, b = d3.source.canvas;
            c2.save();
            c2.globalAlpha = a;
            c2.drawImage(
              b,
              0,
              0,
              b.width,
              b.height,
              0,
              0,
              c2.canvas.width / ja,
              c2.canvas.height / ja
            );
            c2.restore();
          }
        }, easing: { linear: function(a, d3, c2, b) {
          return c2 * a / b + d3;
        }, easeOutQuad: function(a, d3, c2, b) {
          return -c2 * (a /= b) * (a - 2) + d3;
        }, easeOutQuart: function(a, d3, c2, b) {
          return -c2 * ((a = a / b - 1) * a * a * a - 1) + d3;
        }, easeInQuad: function(a, d3, c2, b) {
          return c2 * (a /= b) * a + d3;
        }, easeInQuart: function(a, d3, c2, b) {
          return c2 * (a /= b) * a * a * a + d3;
        } } }, v = { drawMarker: function(a, d3, c2, b, e, f3, k3, u3) {
          if (c2) {
            var s2 = 1;
            c2.fillStyle = f3 ? f3 : "#000000";
            c2.strokeStyle = k3 ? k3 : "#000000";
            c2.lineWidth = u3 ? u3 : 0;
            c2.setLineDash && c2.setLineDash(R(
              "solid",
              u3
            ));
            "circle" === b ? (c2.moveTo(a, d3), c2.beginPath(), c2.arc(a, d3, e / 2, 0, 2 * Math.PI, false), f3 && c2.fill(), u3 && (k3 ? c2.stroke() : (s2 = c2.globalAlpha, c2.globalAlpha = 0.15, c2.strokeStyle = "black", c2.stroke(), c2.globalAlpha = s2))) : "square" === b ? (c2.beginPath(), c2.rect(a - e / 2, d3 - e / 2, e, e), f3 && c2.fill(), u3 && (k3 ? c2.stroke() : (s2 = c2.globalAlpha, c2.globalAlpha = 0.15, c2.strokeStyle = "black", c2.stroke(), c2.globalAlpha = s2))) : "triangle" === b ? (c2.beginPath(), c2.moveTo(a - e / 2, d3 + e / 2), c2.lineTo(a + e / 2, d3 + e / 2), c2.lineTo(a, d3 - e / 2), c2.closePath(), f3 && c2.fill(), u3 && (k3 ? c2.stroke() : (s2 = c2.globalAlpha, c2.globalAlpha = 0.15, c2.strokeStyle = "black", c2.stroke(), c2.globalAlpha = s2)), c2.beginPath()) : "cross" === b && (c2.strokeStyle = f3, c2.lineWidth = e / 4, c2.beginPath(), c2.moveTo(a - e / 2, d3 - e / 2), c2.lineTo(a + e / 2, d3 + e / 2), c2.stroke(), c2.moveTo(a + e / 2, d3 - e / 2), c2.lineTo(a - e / 2, d3 + e / 2), c2.stroke());
          }
        }, drawMarkers: function(a) {
          for (var d3 = 0; d3 < a.length; d3++) {
            var c2 = a[d3];
            v.drawMarker(c2.x, c2.y, c2.ctx, c2.type, c2.size, c2.color, c2.borderColor, c2.borderThickness);
          }
        } };
        return w;
      }();
      Ja.version = "v3.8.2 GA";
      window.CanvasJS && (Ja && !window.CanvasJS.Chart) && (window.CanvasJS.Chart = Ja);
      ia.StockChart = { width: 500, height: 600, backgroundColor: "white", theme: "light1", animationEnabled: false, animationDuration: 1200, culture: "en", creditHref: "", creditText: "CanvasJS", exportEnabled: false, exportFileName: "StockChart", colorSet: "colorSet1", rangeChanging: null, rangeChanged: null, publicProperties: { title: "readWrite", subtitles: "readWrite", toolbar: "readWrite", navigator: "readWrite", rangeSelector: "readWrite", charts: "readWrite", options: "readWrite", bounds: "readOnly", container: "readOnly", selectedColorSet: "readOnly" } };
      ia.Navigator = { enabled: true, width: 500, height: 70, verticalAlign: "bottom", horizontalAlign: "left", dynamicUpdate: true, backgroundColor: "#fff", animationEnabled: false, animationDuration: 1200, theme: "light1", publicProperties: { slider: "readWrite", backgroundColor: "readWrite", animationEnabled: "readWrite", animationDuration: "readWrite", theme: "readWrite", axisX: "readWrite", axisY: "readWrite", axisX2: "readWrite", axisY2: "readWrite", data: "readWrite", options: "readWrite", bounds: "readOnly" } };
      ia.RangeSelector = {
        enabled: true,
        width: 500,
        height: 35,
        label: "Range",
        verticalAlign: "top",
        horizontalAlign: "center",
        selectedRangeButtonIndex: null,
        publicProperties: { options: "readWrite", buttons: "readWrite", inputFields: "readWrite", buttonStyle: "readWrite", bounds: "readOnly" }
      };
      ia.RangeButton = { range: null, rangeType: null, label: null, style: "position: inline; margin: 5px 0;text-align:center;cursor: pointer;", backgroundColorDisabled: "#ddd", publicProperties: { options: "readWrite", bounds: "readOnly" } };
      ia.ButtonStyle = {
        backgroundColor: "#fff",
        backgroundColorOnHover: "#2196f3",
        backgroundColorOnSelect: "#2196f3",
        borderColor: "#2196f3",
        borderThickness: 2,
        labelFontColor: "#000",
        labelFontColorOnHover: "#fff",
        labelFontSize: 14,
        labelFontStyle: "normal",
        labelFontFamily: r ? "Trebuchet MS, Helvetica, sans-serif" : "Arial",
        labelFontWeight: "normal",
        width: null,
        maxWidth: null,
        padding: { left: 5, right: 5, top: 2, bottom: 2 },
        spacing: 5,
        cursor: "pointer",
        publicProperties: { options: "readWrite" }
      };
      ia.InputFields = { enabled: true, startValue: null, endValue: null, valueType: "dateTime", valueFormatString: "MMM DD YYYY", publicProperties: {
        style: "readWrite",
        options: "readWrite"
      } };
      ia.Style = { backgroundColor: "#fff", borderColor: "#2196f3", borderColorOnFocus: "#008eff", borderThickness: 2, fontColor: "#000", fontSize: 12, fontStyle: "normal", fontFamily: r ? "Trebuchet MS, Helvetica, sans-serif" : "Arial", fontWeight: "normal", width: null, maxWidth: null, padding: { left: 5, right: 5, top: 2, bottom: 2 }, spacing: 5, cursor: "text", publicProperties: { options: "readWrite" } };
      ia.Slider = {
        maskColor: "#d9e8f9",
        maskInverted: false,
        maskOpacity: 0.7,
        handleColor: "#ddd",
        handleBorderColor: "#aaa",
        handleBorderThickness: 1,
        handleWidth: 8,
        handleHeight: 18,
        minimum: null,
        maximum: null,
        outlineThickness: 1,
        outlineColor: "#666",
        outlineInverted: false,
        publicProperties: { options: "readWrite" }
      };
      ia.CultureInfo.rangeSelector = { fromText: "From", toText: "To", rangeText: "Range" };
      L = "#FFFFFF";
      T = "#333333";
      M = "#000000";
      Ga = { colorSet: "colorSet1", backgroundColor: L, title: Ga.title, subtitles: Ga.subtitles, charts: [Ga], rangeSelector: { buttonStyle: {
        backgroundColor: "#FEFEFE",
        backgroundColorOnHover: "#41a5f5",
        backgroundColorOnSelect: "#2196f3",
        borderColor: "#2196f3",
        borderThickness: 1,
        labelFontColor: M,
        labelFontColorOnHover: "#ffffff",
        labelFontSize: 14,
        labelFontStyle: "normal",
        labelFontFamily: x,
        labelFontWeight: "normal",
        spacing: 0
      }, inputFields: { style: { backgroundColor: "#ffffff", borderColor: "#2196f3", borderColorOnFocus: "#2196f3", borderThickness: 1, fontColor: M, fontSize: 14, fontStyle: "normal", fontFamily: x, fontWeight: "normal" } } }, navigator: { backgroundColor: L, slider: {
        maskColor: "#d9e8f9",
        maskOpacity: 0.6,
        handleColor: "#efefef",
        handleBorderColor: "#666666",
        handleBorderThickness: 1,
        outlineColor: "#666666",
        outlineThickness: 1
      } }, toolbar: Ga.toolbar };
      L = "#FFFFFF";
      T = "#3A3A3A";
      M = "#666666";
      Ia = { colorSet: "colorSet2", backgroundColor: L, title: Ia.title, subtitles: Ia.subtitles, charts: [Ia], rangeSelector: { buttonStyle: { backgroundColor: "#FEFEFE", backgroundColorOnHover: "#41a5f5", backgroundColorOnSelect: "#2196f3", borderColor: "#2196f3", borderThickness: 1, labelFontColor: M, labelFontColorOnHover: "#ffffff", labelFontSize: 14, labelFontStyle: "normal", labelFontFamily: x, labelFontWeight: "normal", spacing: 0 }, inputFields: { style: {
        backgroundColor: "#ffffff",
        borderColor: "#2196f3",
        borderColorOnFocus: "#2196f3",
        borderThickness: 1,
        fontColor: M,
        fontSize: 14,
        fontStyle: "normal",
        fontFamily: x,
        fontWeight: "normal"
      } } }, navigator: { backgroundColor: L, slider: { maskColor: "#D9E8F9", maskOpacity: 0.6, handleColor: "#EFEFEF", handleBorderColor: "#BBBBBB", handleBorderThickness: 1, outlineColor: "#BBBBBB", outlineThickness: 1 } }, toolbar: Ia.toolbar };
      L = "#2A2A2A";
      M = T = "#F5F5F5";
      za = { colorSet: "colorSet1", backgroundColor: L, title: za.title, subtitles: za.subtitles, charts: [za], rangeSelector: { buttonStyle: {
        backgroundColor: "#666666",
        backgroundColorOnHover: "#FF7372",
        backgroundColorOnSelect: "#FF7372",
        borderColor: "#FF7372",
        borderThickness: 1,
        labelFontColor: M,
        labelFontColorOnHover: "#F5F5F5",
        labelFontSize: 14,
        labelFontStyle: "normal",
        labelFontFamily: x,
        labelFontWeight: "normal",
        spacing: 0
      }, inputFields: { style: { backgroundColor: "#666666", borderColor: "#FF7372", borderColorOnFocus: "#FF7372", borderThickness: 1, fontColor: M, fontSize: 14, fontStyle: "normal", fontFamily: x, fontWeight: "normal" } } }, navigator: { backgroundColor: L, slider: {
        maskColor: "#d9e8f9",
        maskOpacity: 0.6,
        handleColor: "#efefef",
        handleBorderColor: "#666666",
        handleBorderThickness: 1,
        outlineColor: "#FFFFFF",
        outlineThickness: 1
      } }, toolbar: za.toolbar };
      L = "#32373A";
      M = T = "#FAFAFA";
      var bb = { light1: Ga, light2: Ia, dark1: za, dark2: { colorSet: "colorSet2", backgroundColor: L, title: X.title, subtitles: X.subtitles, charts: [X], rangeSelector: { buttonStyle: {
        backgroundColor: "#666666",
        backgroundColorOnHover: "#FF7372",
        backgroundColorOnSelect: "#FF7372",
        borderColor: "#FF7372",
        borderThickness: 1,
        labelFontColor: M,
        labelFontColorOnHover: "#F5F5F5",
        labelFontSize: 14,
        labelFontStyle: "normal",
        labelFontFamily: x,
        labelFontWeight: "normal",
        spacing: 0
      }, inputFields: { style: { backgroundColor: "#666666", borderColor: "#FF7372", borderColorOnFocus: "#FF7372", borderThickness: 1, fontColor: M, fontSize: 14, fontStyle: "normal", fontFamily: x, fontWeight: "normal" } } }, navigator: { backgroundColor: L, slider: { maskColor: "#d9e8f9", maskOpacity: 0.6, handleColor: "#efefef", handleBorderColor: "#666666", handleBorderThickness: 1, outlineColor: "#FFFFFF", outlineThickness: 1 } }, toolbar: X.toolbar } };
      T = Sa.StockChart = function() {
        function k2(d2) {
          var f3;
          f3 = document.createElement("div");
          f3.setAttribute("class", d2);
          O(f3, { position: "absolute", textAlign: "left", cursor: "auto", webkitTapHighlightColor: "transparent" });
          return f3;
        }
        function w(d2, k3, s) {
          d2 = document.createElement(d2);
          d2.setAttribute("class", k3);
          O(d2, { webkitTapHighlightColor: "transparent" });
          f2(s) || d2.setAttribute("type", s);
          return d2;
        }
        function F2(d2, k3) {
          k3 = k3 || {};
          this.theme = f2(k3.theme) || f2(Ra[k3.theme]) ? "light1" : k3.theme;
          this.predefinedThemes = bb;
          F2.base.constructor.call(
            this,
            "StockChart",
            null,
            k3,
            null,
            null
          );
          this.optionsName = "stockChart";
          var s = this;
          this.sessionVariables = {};
          this._axisXMax = this._axisXMin = null;
          this._containerId = d2;
          this._objectsInitialized = false;
          this.ctx = null;
          this.plotArea = { canvas: null, ctx: null, x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 };
          this._dataInRenderedOrder = [];
          this.allDOMEventHandlers = [];
          if (this.container = "string" === typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) {
            this.container.innerHTML = "";
            var v = 0, a = 0;
            this._defaultCursor = "default";
            v = this.options.width ? this.width : 0 < this.container.clientWidth ? this.container.clientWidth : this.width;
            a = this.options.height ? this.height : 0 < this.container.clientHeight ? this.container.clientHeight : this.height;
            this.width = v;
            this.height = a;
            this.x1 = this.y1 = 0;
            this.x2 = this.width;
            this.y2 = this.height;
            this.selectedColorSet = "undefined" !== typeof sa[this.colorSet] ? sa[this.colorSet] : sa.colorSet1;
            this._canvasJSContainer = document.createElement("div");
            this._canvasJSContainer.setAttribute("class", "canvasjs-stock-container");
            this._canvasJSContainer.style.position = "relative";
            this._canvasJSContainer.style.userSelect = this._canvasJSContainer.style.WebkitUserSelect = this._canvasJSContainer.style.MozUserSelect = this._canvasJSContainer.style.msUserSelect = "none";
            this._canvasJSContainer.style.textAlign = "left";
            this._canvasJSContainer.style.cursor = "auto";
            this._canvasJSContainer.style.direction = "ltr";
            this._canvasJSContainer.style.fontFamily = x;
            r || (this._canvasJSContainer.style.height = "0px");
            this.container.appendChild(this._canvasJSContainer);
            this.canvas = ra(v, a);
            this.canvas.style.position = "absolute";
            this.canvas.getContext && (this._canvasJSContainer.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d"), this.ctx.textBaseline = "top", Da(this.ctx), this.overlaidCanvas = ra(v, a), this.overlaidCanvas.style.position = "absolute", this.overlaidCanvas.style.webkitTapHighlightColor = "transparent", this.overlaidCanvas.getContext && (this._canvasJSContainer.appendChild(this.overlaidCanvas), this.overlaidCanvasCtx = this.overlaidCanvas.getContext("2d"), this.overlaidCanvasCtx.textBaseline = "top", Da(this.overlaidCanvasCtx)), r ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = ra(v, a), this.plotArea.canvas.style.position = "absolute", this.plotArea.canvas.setAttribute("class", "plotAreaCanvas"), this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext("2d")), this._toolBar = document.createElement("div"), this._toolBar.setAttribute("class", "canvasjs-chart-toolbar"), O(this._toolBar, { position: "absolute", right: "1px", top: "1px", zIndex: 999 }), this._canvasJSContainer.appendChild(this._toolBar), this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height }, this.charts = [], Ea(this.charts), this._eventManager = new P(this), D(this.overlaidCanvas, "click", function(a2) {
              s._mouseEventHandler(a2);
            }, this.allDOMEventHandlers), D(this.overlaidCanvas, "mousemove", function(a2) {
              s._mouseEventHandler(a2);
            }, this.allDOMEventHandlers), D(this.overlaidCanvas, "mouseup", function(a2) {
              s._mouseEventHandler(a2);
            }, this.allDOMEventHandlers), D(this.overlaidCanvas, "mousedown", function(a2) {
              s._mouseEventHandler(a2);
              ya(s._dropdownMenu);
            }, this.allDOMEventHandlers), D(this.overlaidCanvas, "mouseout", function(a2) {
              s._mouseEventHandler(a2);
            }, this.allDOMEventHandlers), D(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", function(a2) {
              s._touchEventHandler(a2);
            }, this.allDOMEventHandlers), D(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerMove" : "touchmove", function(a2) {
              s._touchEventHandler(a2);
            }, this.allDOMEventHandlers), D(
              this.overlaidCanvas,
              window.navigator.msPointerEnabled ? "MSPointerUp" : "touchend",
              function(a2) {
                s._touchEventHandler(a2);
              },
              this.allDOMEventHandlers
            ), D(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerCancel" : "touchcancel", function(a2) {
              s._touchEventHandler(a2);
            }, this.allDOMEventHandlers), this.windowResizeHandler = D(window, "resize", function() {
              s._updateSize() && s.render();
            }, this.allDOMEventHandlers));
          } else
            window.console && window.console.log('CanvasJS Error: StockChart Container with id "' + this._containerId + '" was not found');
        }
        function J(d2, f3) {
          J.base.constructor.call(this, d2, f3);
          this.options = f3;
          this.dockInsidePlotArea = false;
        }
        function L2(d2, f3, k3) {
          L2.base.constructor.call(this, d2, f3, k3);
          this.options = f3;
          this.dockInsidePlotArea = false;
        }
        function P(d2) {
          this.stockChart = d2;
          this.lastObjectId = 0;
          this.objectMap = [];
          this.rectangularRegionEventSubscriptions = [];
          this.ghostCanvas = ra(this.stockChart.width, this.stockChart.height);
          this.ghostCtx = this.ghostCanvas.getContext("2d");
          this.mouseoveredObjectMaps = [];
        }
        function A(d2, f3) {
          f3 = f3 || {};
          this.optionsName = "navigator";
          A.base.constructor.call(this, "Navigator", "navigator", f3, null, d2);
          this.parent = this.stockChart = d2;
        }
        function M2(d2, u2) {
          this.panel = k2("canvasjs-slider-panel");
          this.parent = this.navigator = d2;
          this.stockChart = d2.stockChart;
          this.navigator.panel.appendChild(this.panel);
          M2.base.constructor.call(this, "Slider", "slider", u2, null, d2);
          this.options = f2(u2.navigator) || f2(u2.navigator.slider) ? {} : u2.navigator.slider;
          this.optionsName = "slider";
          this.panMode = false;
          this.sessionVariables = {};
        }
        function R2(d2, k3) {
          R2.base.constructor.call(this, "RangeSelector", "rangeSelector", k3, null, d2);
          this.parent = this.stockChart = d2;
          this.options = f2(k3) || f2(k3.rangeSelector) ? {} : k3.rangeSelector;
          this.optionsName = "rangeSelector";
          this.ctx = d2.ctx;
        }
        function Q(d2, k3, s) {
          Q.base.constructor.call(this, "RangeButton", "rangeButton", s, k3, d2.rangeSelector);
          this.stockChart = d2;
          this.parent = this.rangeSelector = d2.rangeSelector;
          this.options = f2(s) ? {} : s;
          this.optionsName = "rangeButton";
          this.enabled = false;
          this.state = "off";
        }
        function T2(d2, k3) {
          T2.base.constructor.call(this, "InputFields", "inputFields", k3, null, d2.rangeSelector);
          this.stockChart = d2;
          this.options = f2(k3) || f2(k3.inputFields) ? {} : k3.inputFields;
          this.parent = this.rangeSelector = d2.rangeSelector;
          this.elements = [];
          this._textBlocks = [];
          this.optionsName = "inputFields";
          this.elements.push(w("input", "canvasjs-input-field", "text"));
          this.elements.push(w("input", "canvasjs-input-field", "text"));
          for (var s = 0; s < this.elements.length; s++)
            this.stockChart._canvasJSContainer.appendChild(this.elements[s]);
          var v = this, a = null, h2 = null;
          D(this.elements[0], "focus", function() {
            v.enabled && (v.elements[0].focused = true, v._textBlocks[0].borderColor = v.style.borderColorOnFocus, v._textBlocks[0].render(true));
          }, this.rangeSelector.stockChart.allDOMEventHandlers);
          D(this.elements[0], "focusout", function() {
            if (v.enabled) {
              v.elements[0].focused = false;
              var a2;
              v.stockChart.charts && v.stockChart.charts.length && (a2 = v.stockChart.charts[0].axisX && v.stockChart.charts[0].axisX.length ? v.stockChart.charts[0].axisX[0] : v.stockChart.charts[0].axisX2[0]);
              this.value = "dateTime" === v.valueType ? ea(a2 ? a2.viewportMinimum : null, "YYYY-MM-DD", v.stockChart._cultureInfo) : da(a2 ? a2.viewportMinimum : null, v.valueFormatString, v.stockChart._cultureInfo);
              this.style.display = "none";
              v._textBlocks[0].borderColor = v.style.borderColor;
              v._textBlocks[0].render(true);
            }
          }, this.rangeSelector.stockChart.allDOMEventHandlers);
          D(this.elements[1], "focus", function() {
            v.enabled && (v.elements[1].focused = true, v._textBlocks[1].borderColor = v.style.borderColorOnFocus, v._textBlocks[1].render(true));
          }, this.rangeSelector.stockChart.allDOMEventHandlers);
          D(this.elements[1], "focusout", function() {
            if (v.enabled) {
              v.elements[1].focused = false;
              var a2;
              v.stockChart.charts && v.stockChart.charts.length && (a2 = v.stockChart.charts[0].axisX && v.stockChart.charts[0].axisX.length ? v.stockChart.charts[0].axisX[0] : v.stockChart.charts[0].axisX2[0]);
              this.value = "dateTime" === v.valueType ? ea(a2 ? a2.viewportMaximum : null, "YYYY-MM-DD", v.stockChart._cultureInfo) : da(a2 ? a2.viewportMaximum : null, v.valueFormatString, v.stockChart._cultureInfo);
              this.style.display = "none";
              v._textBlocks[1].borderColor = v.style.borderColor;
              v._textBlocks[1].render(true);
            }
          }, this.rangeSelector.stockChart.allDOMEventHandlers);
          D(this.elements[0], "change", function(c2) {
            if (v.enabled) {
              var b, d3;
              v.stockChart.charts && v.stockChart.charts.length && (v.stockChart.navigator && v.stockChart.navigator.enabled && (d3 = v.stockChart.navigator && v.stockChart.navigator.chart && v.stockChart.navigator.chart.axisX ? v.stockChart.navigator.chart.axisX[0] : v.stockChart.navigator.chart.axisX2[0]), b = v.stockChart.charts[0].axisX && v.stockChart.charts[0].axisX.length ? v.stockChart.charts[0].axisX[0] : v.stockChart.charts[0].axisX2[0]);
              c2 = "dateTime" === v.valueType ? isNaN(new Date(this.value.replace(/-/g, "/")).getTime()) ? null : new Date(this.value.replace(/-/g, "/")).getTime() : this.value;
              a = f2(d3) ? !f2(c2) && c2 < (f2(b) ? null : b.maximum) ? Math.max(f2(b) ? null : b.minimum, c2) : f2(b) ? null : b.minimum : !f2(c2) && c2 < (f2(d3) ? null : d3.maximum) ? Math.max(f2(d3) ? null : d3.minimum, c2) : f2(d3) ? null : d3.minimum;
              h2 = f2(b) ? null : b.viewportMaximum;
              v.stockChart._rangeEventParameter = { stockChart: v.stockChart, source: "inputFields", index: null, minimum: a, maximum: h2 };
              v.stockChart._rangeEventParameter.type = "rangeChanging";
              v.stockChart.dispatchEvent("rangeChanging", v.stockChart._rangeEventParameter, v.stockChart);
              v.stockChart.sessionVariables._axisXMin = a;
              v.stockChart.sessionVariables._axisXMax = h2;
              v.stockChart._syncCharts(a, h2);
              v.stockChart._rangeEventParameter.type = "rangeChanged";
              v.stockChart.dispatchEvent("rangeChanged", v.stockChart._rangeEventParameter, v.stockChart);
              v.stockChart.rangeSelector && v.stockChart.rangeSelector.resetRangeButtons();
            }
          }, this.rangeSelector.stockChart.allDOMEventHandlers);
          D(this.elements[1], "change", function(c2) {
            if (v.enabled) {
              var b, d3;
              v.stockChart.charts && v.stockChart.charts.length && (v.stockChart.navigator && v.stockChart.navigator.enabled && (d3 = v.stockChart.navigator && v.stockChart.navigator.chart && v.stockChart.navigator.chart.axisX ? v.stockChart.navigator.chart.axisX[0] : v.stockChart.navigator.chart.axisX2[0]), b = v.stockChart.charts[0].axisX && v.stockChart.charts[0].axisX.length ? v.stockChart.charts[0].axisX[0] : v.stockChart.charts[0].axisX2[0]);
              c2 = "dateTime" === v.valueType ? isNaN(new Date(this.value.replace(/-/g, "/")).getTime()) ? null : new Date(this.value.replace(/-/g, "/")).getTime() : this.value;
              a = b ? b.viewportMinimum : null;
              h2 = f2(d3) ? !f2(c2) && c2 > (b ? b.minimum : null) ? Math.min(b ? b.maximum : null, c2) : b ? b.maximum : null : !f2(c2) && c2 > (d3 ? d3.minimum : null) ? Math.min(d3 ? d3.maximum : null, c2) : d3 ? d3.maximum : null;
              v.stockChart._rangeEventParameter = { stockChart: v.stockChart, source: "inputFields", index: null, minimum: a, maximum: h2 };
              v.stockChart._rangeEventParameter.type = "rangeChanging";
              v.stockChart.dispatchEvent("rangeChanging", v.stockChart._rangeEventParameter, v.stockChart);
              v.stockChart.sessionVariables._axisXMin = a;
              v.stockChart.sessionVariables._axisXMax = h2;
              v.stockChart._syncCharts(
                a,
                h2
              );
              v.stockChart._rangeEventParameter.type = "rangeChanged";
              v.stockChart.dispatchEvent("rangeChanged", v.stockChart._rangeEventParameter, v.stockChart);
              v.stockChart.rangeSelector && v.stockChart.rangeSelector.resetRangeButtons();
            }
          }, this.rangeSelector.stockChart.allDOMEventHandlers);
          D(this.elements[0], "keydown", function(a2) {
            if (v.enabled && 13 === a2.keyCode) {
              var b = "dateTime" === v.valueType ? ea(v.startValue, "YYYY-MM-DD") : da(v.startValue, v.valueFormatString);
              this.value != b && hb(this, "change");
              this.blur();
              a2.preventDefault && a2.preventDefault();
            }
          }, this.rangeSelector.stockChart.allDOMEventHandlers);
          D(this.elements[1], "keydown", function(a2) {
            if (v.enabled && 13 === a2.keyCode) {
              var b = "dateTime" === v.valueType ? ea(v.endValue, "YYYY-MM-DD") : da(v.endValue, v.valueFormatString);
              this.value != b && hb(this, "change");
              this.blur();
              a2.preventDefault && a2.preventDefault();
            }
          }, this.rangeSelector.stockChart.allDOMEventHandlers);
        }
        function V2(d2, k3) {
          V2.base.constructor.call(this, "ButtonStyle", "buttonStyle", k3, null, d2.rangeSelector);
          this.stockChart = d2;
          this.parent = this.rangeSelector = d2.rangeSelector;
          this.options = f2(k3) || f2(k3.buttonStyle) ? {} : k3.buttonStyle;
          this.optionsName = "buttonStyle";
        }
        function X2(d2, k3) {
          X2.base.constructor.call(this, "Style", "style", k3, null, d2.rangeSelector.inputFields);
          this.stockChart = d2;
          this.parent = this.inputFields = d2.rangeSelector.inputFields;
          this.options = f2(k3) || f2(k3.style) ? {} : k3.style;
          this.optionsName = "style";
        }
        var aa2 = true;
        ga(F2, $);
        F2.prototype._updateOptions = function() {
          this.updateOption("width");
          this.updateOption("height");
          this.updateOption("theme");
          this.updateOption("colorSet") && (this.selectedColorSet = "undefined" !== typeof sa[this.colorSet] ? sa[this.colorSet] : sa.colorSet1);
          this.updateOption("backgroundColor");
          this.backgroundColor || (this.backgroundColor = "rgba(0,0,0,0)");
          this.updateOption("exportEnabled");
          this.updateOption("exportFileName");
          this.updateOption("creditHref");
          this.updateOption("creditHref");
          this.updateOption("culture");
          this._cultureInfo = new Oa(this.options.culture);
          this.updateOption("animationEnabled");
          this.updateOption("animationDuration");
          this.updateOption("rangeChanging");
          this.updateOption("rangeChanged");
          this.toolbar = new Xa(this, this.options.toolbar);
          ib(this);
        };
        F2._supportedChartTypes = Ea("line stepLine spline column area stepArea splineArea bubble scatter stackedColumn stackedColumn100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeArea rangeSplineArea waterfall".split(" "));
        F2.prototype._initialize = function() {
          this._updateOptions();
          this.animationEnabled = this.animationEnabled && r;
          this._updateSize();
          this.clearCanvas();
          this.ctx.beginPath();
          var d2, u2 = f2(this.options.charts) ? [] : this.options.charts;
          Ea(u2);
          for (var s = 0; s < this.charts.length; s++)
            d2 = this.charts[s], 0 > u2.indexOf(d2.options) && (this.charts.splice(s, 1), d2.destroy(), this._canvasJSContainer.removeChild(d2.panel), s--);
          this.layoutManager = new Ka(0, 0, this.width, this.height, 2);
          this.plotArea.layoutManager && this.plotArea.layoutManager.reset();
          this.title = null;
          this.subtitles = [];
          this.options.title && (this.title = new J(this, this.options.title), this.title.setLayout());
          if (this.options.subtitles)
            for (s = 0; s < this.options.subtitles.length; s++)
              d2 = new L2(this, this.options.subtitles[s], s), this.subtitles.push(d2), d2.setLayout();
          this.navigator = this.navigator || new A(this, this.options.navigator);
          this.navigator._initialize();
          if (this.navigator.enabled) {
            d2 = { theme: this.options.navigator && this.options.navigator.theme ? this.options.navigator.theme : this.theme, animationEnabled: this.options.navigator && !f2(this.options.navigator.animationEnabled) ? this.options.navigator.animationEnabled : this.animationEnabled, animationDuration: this.options.navigator && this.options.navigator.animationDuration ? this.options.navigator.animationDuration : this.animationDuration, culture: this.options.navigator && this.options.navigator.culture ? this.options.navigator.culture : this.culture, zoomEnabled: false, data: this.options.navigator && this.options.navigator.data ? this.options.navigator.data : this.options.charts && this.options.charts[0] && this.options.charts[0].data ? $a(this.options.charts[0].data) : [], axisX: this.options.navigator && this.options.navigator.axisX ? this.options.navigator.axisX : {}, axisY: this.options.navigator && this.options.navigator.axisY ? this.options.navigator.axisY : {}, axisX2: this.options.navigator && this.options.navigator.axisX2 ? this.options.navigator.axisX2 : {}, axisY2: this.options.navigator && this.options.navigator.axisY2 ? this.options.navigator.axisY2 : {}, interactivityEnabled: false, exportEnabled: false };
            for (s = 0; s < d2.data.length; s++)
              !f2(this.navigator.options.data) || !f2(d2.data[s].type) && (f2(d2.data[s].type) || 0 <= d2.data[s].type.indexOf("range") || 0 <= d2.data[s].type.indexOf("ohlc") || 0 <= d2.data[s].type.indexOf("candlestick") || 0 <= d2.data[s].type.indexOf("error")) ? this.navigator.options.data && f2(this.navigator.options.data[s].type) && (d2.data[s].type = "splineArea") : d2.data[s].type = "splineArea";
            if (d2.axisX.length)
              for (s = 0; s < d2.axisX.length; s++)
                d2.axisX[s].titleFontSize = f2(d2.axisX[s].titleFontSize) ? 1 : d2.axisX[s].titleFontSize, d2.axisX[s].labelFontSize = f2(d2.axisX[s].labelFontSize) ? 12 : d2.axisX[s].labelFontSize, d2.axisX[s].labelAngle = f2(d2.axisX[s].labelAngle) ? 0 : d2.axisX[s].labelAngle, d2.axisX[s].labelPlacement = f2(d2.axisX[s].labelPlacement) ? "inside" : d2.axisX[s].labelPlacement, d2.axisX[s].tickLength = f2(d2.axisX[s].tickLength) ? 0 : d2.axisX[s].tickLength, d2.axisX[s].lineThickness = f2(d2.axisX[s].lineThickness) ? 0 : d2.axisX[s].lineThickness, d2.axisX[s].tickThickness = f2(d2.axisX[s].tickThickness) ? 0 : d2.axisX[s].tickThickness, d2.axisX[s].gridThickness = f2(d2.axisX[s].gridThickness) ? 1 : d2.axisX[s].gridThickness;
            else
              d2.axisX.titleFontSize = this.options.navigator && this.options.navigator.axisX && !f2(this.options.navigator.axisX.titleFontSize) ? this.options.navigator.axisX.titleFontSize : r ? 0 : 1, d2.axisX.labelFontSize = this.options.navigator && this.options.navigator.axisX && !f2(this.options.navigator.axisX.labelFontSize) ? this.options.navigator.axisX.labelFontSize : 12, d2.axisX.labelAngle = this.options.navigator && this.options.navigator.axisX && !f2(this.options.navigator.axisX.labelAngle) ? this.options.navigator.axisX.labelAngle : 0, d2.axisX.labelPlacement = this.options.navigator && this.options.navigator.axisX && !f2(this.options.navigator.axisX.labelPlacement) ? this.options.navigator.axisX.labelPlacement : "inside", d2.axisX.tickLength = this.options.navigator && this.options.navigator.axisX && !f2(this.options.navigator.axisX.tickLength) ? this.options.navigator.axisX.tickLength : 0, d2.axisX.lineThickness = this.options.navigator && this.options.navigator.axisX && !f2(this.options.navigator.axisX.lineThickness) ? this.options.navigator.axisX.lineThickness : 0, d2.axisX.tickThickness = this.options.navigator && this.options.navigator.axisX && !f2(this.options.navigator.axisX.tickThickness) ? this.options.navigator.axisX.tickThickness : 0, d2.axisX.gridThickness = this.options.navigator && this.options.navigator.axisX && !f2(this.options.navigator.axisX.gridThickness) ? this.options.navigator.axisX.gridThickness : 1;
            if (d2.axisY.length)
              for (s = 0; s < d2.axisY.length; s++)
                d2.axisY[s].titleFontSize = d2.axisY[s].titleFontSize ? d2.axisY[s].titleFontSize : r ? 0 : 1, d2.axisY[s].labelFontSize = d2.axisY[s].labelFontSize ? d2.axisY[s].labelFontSize : r ? 0 : 1, d2.axisY[s].labelPlacement = d2.axisY[s].labelPlacement ? d2.axisY[s].labelPlacement : "inside", d2.axisY[s].includeZero = false, d2.axisY[s].lineThickness = 0, d2.axisY[s].tickThickness = 0, d2.axisY[s].tickLength = 0, d2.axisY[s].gridThickness = 0;
            else
              d2.axisY.titleFontSize = this.options.navigator && this.options.navigator.axisY && this.options.navigator.axisY.titleFontSize ? this.options.navigator.axisY.titleFontSize : r ? 0 : 1, d2.axisY.labelFontSize = this.options.navigator && this.options.navigator.axisY && this.options.navigator.axisY.labelFontSize ? this.options.navigator.axisY.labelFontSize : r ? 0 : 1, d2.axisY.labelPlacement = this.options.navigator && this.options.navigator.axisY && this.options.navigator.axisY.labelPlacement ? this.options.navigator.axisY.labelPlacement : "inside", d2.axisY.includeZero = false, d2.axisY.lineThickness = 0, d2.axisY.tickThickness = 0, d2.axisY.tickLength = 0, d2.axisY.gridThickness = 0;
            if (d2.axisX2.length)
              for (s = 0; s < d2.axisX2.length; s++)
                d2.axisX2[s].titleFontSize = d2.axisX2[s].titleFontSize ? d2.axisX2[s].titleFontSize : r ? 0 : 1, d2.axisX2[s].labelFontSize = d2.axisX2[s].labelFontSize ? d2.axisX2[s].labelFontSize : 12, d2.axisX2[s].labelAngle = f2(d2.axisX2[s].labelAngle) ? 0 : d2.axisX2[s].labelAngle, d2.axisX2[s].labelPlacement = d2.axisX2[s].labelPlacement ? d2.axisX2[s].labelPlacement : "inside", d2.axisX2[s].tickLength = f2(d2.axisX2[s].tickLength) ? 0 : d2.axisX2[s].tickLength, d2.axisX2[s].lineThickness = d2.axisX2[s].lineThickness ? d2.axisX2[s].lineThickness : 0, d2.axisX2[s].tickThickness = d2.axisX2[s].tickThickness ? d2.axisX2[s].tickThickness : 1, d2.axisX2[s].gridThickness = f2(d2.axisX2[s].gridThickness) ? 1 : d2.axisX2[s].gridThickness;
            else
              d2.axisX2.titleFontSize = this.options.navigator && this.options.navigator.axisX2 && this.options.navigator.axisX2.titleFontSize ? this.options.navigator.axisX2.titleFontSize : r ? 0 : 1, d2.axisX2.labelFontSize = this.options.navigator && this.options.navigator.axisX2 && this.options.navigator.axisX2.labelFontSize ? this.options.navigator.axisX2.labelFontSize : 12, d2.axisX2.labelAngle = this.options.navigator && this.options.navigator.axisX2 && this.options.navigator.axisX2.labelAngle ? this.options.navigator.axisX2.labelAngle : 0, d2.axisX2.labelPlacement = this.options.navigator && this.options.navigator.axisX2 && this.options.navigator.axisX2.labelPlacement ? this.options.navigator.axisX2.labelPlacement : "inside", d2.axisX2.tickLength = this.options.navigator && this.options.navigator.axisX2 && this.options.navigator.axisX2.tickLength ? this.options.navigator.axisX2.tickLength : 0, d2.axisX2.lineThickness = this.options.navigator && this.options.navigator.axisX2 && this.options.navigator.axisX2.lineThickness ? this.options.navigator.axisX2.lineThickness : 0, d2.axisX2.tickThickness = this.options.navigator && this.options.navigator.axisX2 && this.options.navigator.axisX2.tickThickness ? this.options.navigator.axisX2.tickThickness : 1, d2.axisX2.gridThickness = this.options.navigator && this.options.navigator.axisX2 && this.options.navigator.axisX2.gridThickness ? this.options.navigator.axisX2.gridThickness : 1;
            if (d2.axisY2.length)
              for (s = 0; s < d2.axisY2.length; s++)
                d2.axisY2[s].titleFontSize = d2.axisY2[s].titleFontSize ? d2.axisY2[s].titleFontSize : r ? 0 : 1, d2.axisY2[s].labelFontSize = d2.axisY2[s].labelFontSize ? d2.axisY2[s].labelFontSize : r ? 0 : 1, d2.axisY2[s].labelPlacement = d2.axisY2[s].labelPlacement ? d2.axisY2[s].labelPlacement : "inside", d2.axisY2[s].includeZero = false, d2.axisY2[s].lineThickness = 0, d2.axisY2[s].margin = 0, d2.axisY2[s].tickLength = 0, d2.axisY2[s].tickThickness = 0, d2.axisY2[s].gridThickness = 0;
            else
              d2.axisY2.titleFontSize = this.options.navigator && this.options.navigator.axisY2 && this.options.navigator.axisY2.titleFontSize ? this.options.navigator.axisY2.titleFontSize : r ? 0 : 1, d2.axisY2.labelFontSize = this.options.navigator && this.options.navigator.axisY2 && this.options.navigator.axisY2.labelFontSize ? this.options.navigator.axisY2.labelFontSize : r ? 0 : 1, d2.axisY2.labelPlacement = this.options.navigator && this.options.navigator.axisY2 && this.options.navigator.axisY2.labelPlacement ? this.options.navigator.axisY2.labelPlacement : "inside", d2.axisY2.includeZero = false, d2.axisY2.lineThickness = 0, d2.axisY2.margin = 0, d2.axisY2.tickLength = 0, d2.axisY2.tickThickness = 0, d2.axisY2.gridThickness = 0;
            d2.backgroundColor = this.navigator.backgroundColor;
            0 === this.navigator.height && (d2.height = this.navigator.height);
            for (s = 0; s < d2.data.length; s++)
              d2.data[s].markerSize = d2.data[s].markerSize ? d2.data[s].markerSize : 0;
            if (!this.navigator.chart) {
              var v = k2("canvasjs-chart-panel");
              this.navigator.panel.appendChild(v);
              v.style.height = this.navigator.height + "px";
              v.style.width = this.navigator.width + "px";
            }
            this.navigator.chart && (this.navigator.chart.panel.style.width = this.navigator.width + "px", this.navigator.chart.panel.style.height = this.navigator.height + "px");
            this.navigator.chart = this.navigator.chart || new Ja(v, d2, { parent: this.navigator, isOptionsInArray: false, index: null, predefinedThemes: bb, optionsName: "navigator", stockChart: this });
            this.navigator.chart._initialize();
            this.navigator.chart.setLayout();
            this.navigator.chart.selectedColorSet = this.selectedColorSet;
            this.navigator._chartOptions = d2;
            this.navigator.slider = this.navigator.slider || new M2(this.navigator, this.options);
            this.navigator.slider._initialize();
          }
          if (this.rangeSelector && this.rangeSelector.inputFields)
            for (s = 0; s < this.rangeSelector.inputFields.elements.length; s++)
              this._canvasJSContainer.removeChild(this.rangeSelector.inputFields.elements[s]);
          this.rangeSelector = new R2(this, this.options);
          this.rangeSelector.buttonStyle = new V2(this, this.rangeSelector.options);
          this.rangeSelector.inputFields = new T2(this, this.rangeSelector.options);
          this.rangeSelector.inputFields.style = new X2(this, this.rangeSelector.inputFields.options);
          this.rangeSelector.inputFields.style._updateOptions();
          this.rangeSelector.inputFields._initialize();
          if (this.rangeSelector.inputFields && this.rangeSelector.inputFields.enabled)
            for (this.rangeSelector.inputFields._textBlocks = [], this.rangeSelector.inputFields._labels = [], this.rangeSelector.inputFieldsWidth = 0, v = this.rangeSelector.inputFields.style.maxWidth = this.rangeSelector.inputFields.style.options.maxWidth ? this.rangeSelector.inputFields.style.options.maxWidth : this.rangeSelector.stockChart.width / 2, s = 0; s < this.rangeSelector.inputFields.elements.length; s++) {
              d2 = new ma(this.rangeSelector.ctx, {
                x: 0,
                y: 0,
                backgroundColor: this.rangeSelector.inputFields.style.backgroundColor,
                borderColor: this.rangeSelector.inputFields.style.borderColor,
                borderThickness: this.rangeSelector.inputFields.style.borderThickness,
                cornerRadius: 0,
                maxWidth: f2(this.rangeSelector.inputFields.style.options.width) ? v : this.rangeSelector.inputFields.style.width,
                maxHeight: 2 * this.rangeSelector.inputFields.style.fontSize,
                angle: 0,
                padding: this.rangeSelector.inputFields.style.padding,
                text: this.rangeSelector.inputFields.valueFormatString,
                horizontalAlign: "center",
                textAlign: "center",
                fontSize: this.rangeSelector.inputFields.style.fontSize,
                fontFamily: this.rangeSelector.inputFields.style.fontFamily,
                fontWeight: this.rangeSelector.inputFields.style.fontWeight,
                fontColor: this.rangeSelector.inputFields.style.fontColor,
                fontStyle: this.rangeSelector.inputFields.style.fontStyle,
                textBaseline: "middle"
              });
              var u2 = d2.measureText(), a = new ma(this.rangeSelector.ctx, {
                x: 0,
                y: 0,
                backgroundColor: r ? "transparent" : null,
                borderColor: this.rangeSelector.inputFields.style.borderColor,
                borderThickness: 0,
                cornerRadius: 0,
                maxWidth: this.rangeSelector.inputFields.style.maxWidth,
                maxHeight: 2 * this.rangeSelector.inputFields.style.fontSize,
                angle: 0,
                padding: this.rangeSelector.inputFields.style.padding,
                text: "From",
                horizontalAlign: "left",
                fontSize: this.rangeSelector.inputFields.style.fontSize,
                fontFamily: this.rangeSelector.inputFields.style.fontFamily,
                fontWeight: this.rangeSelector.inputFields.style.fontWeight,
                fontColor: this.rangeSelector.inputFields.style.fontColor,
                fontStyle: this.rangeSelector.inputFields.style.fontStyle,
                textBaseline: "middle"
              });
              this.rangeSelector.inputFields._textBlocks.push(d2);
              this.rangeSelector.inputFields._labels.push(a);
              this.rangeSelector.inputFields._textBlocks[s].bounds = { x1: null, x2: null, y1: null, y2: null, width: null, height: null };
              this.rangeSelector.inputFields._labels[s].bounds = { x1: null, x2: null, y1: null, y2: null, width: null, height: null };
              this.rangeSelector.inputFieldsWidth += u2.width + this.rangeSelector.inputFields.style.spacing + a.measureText().width;
              this.rangeSelector.inputFieldsHeight = this.rangeSelector.inputFieldsHeight < u2.height ? u2.height : this.rangeSelector.inputFieldsHeight;
              d2 = this.rangeSelector.inputFields._textBlocks[s];
              d2.id = ++this.rangeSelector.stockChart._eventManager.lastObjectId;
              this.rangeSelector.stockChart._eventManager.objectMap[d2.id] = {
                id: d2.id,
                objectType: "inputFields",
                inputFieldIndex: s
              };
            }
          this.rangeSelector.buttonStyle._updateOptions();
          this.rangeSelector._initialize();
          this._objectsInitialized = true;
        };
        F2.prototype.render = function(d2) {
          var u2 = this;
          d2 && (this.options = d2);
          this._initialize();
          this.title && this.title.render();
          if (this.subtitles)
            for (d2 = 0; d2 < this.subtitles.length; d2++)
              this.subtitles[d2].render();
          var s;
          if (this.options.charts) {
            s = Array(this.options.charts.length);
            var v = this.layoutManager.getFreeSpace(), a = v.height, v = v.height, h2 = this.options.charts.length;
            for (d2 = 0; d2 < this.options.charts.length; d2++)
              !f2(this.options.charts[d2].height) && parseFloat(this.options.charts[d2].height) && (s[d2] = 0 <= this.options.charts[d2].height.toString().indexOf("%") ? Math.floor(Wa(this.options.charts[d2].height, a, Math.floor(v / h2), this.height, 0)) : this.options.charts[d2].height, v -= s[d2], h2--);
            v = Math.floor(v / h2);
            for (d2 = 0; d2 < this.options.charts.length; d2++)
              f2(s[d2]) && (s[d2] = v);
            var c2, h2 = this.options.charts, b = this.charts;
            this.charts = [];
            for (d2 = 0; d2 < h2.length; d2++) {
              v = this.layoutManager.getFreeSpace();
              a = h2[d2];
              a.animationEnabled = f2(h2[d2].animationEnabled) ? this.animationEnabled : h2[d2].animationEnabled;
              a.animationDuration = h2[d2].animationDuration ? h2[d2].animationDuration : this.animationDuration;
              a.culture = h2[d2].culture ? h2[d2].culture : this.culture;
              for (c2 = b.length; 0 < c2-- && b[c2].options !== a; )
                ;
              0 <= c2 ? (this.charts[d2] = b[c2], this.charts[d2].options = a) : (c2 = k2("canvasjs-chart-panel"), c2.style.height = s[d2] + "px", this._canvasJSContainer.appendChild(c2), this.charts[d2] = new Ja(c2, a, { parent: this, isOptionsInArray: true, index: d2, height: s[d2], predefinedThemes: bb, optionsName: "charts", stockChart: this }));
              this.charts[d2].index = d2;
              this.charts[d2].panel.style.width = v.width + "px";
              this.charts[d2].panel.style.top = v.y1 + "px";
              this.charts[d2].panel.style.left = v.x1 + "px";
              this.charts[d2].panel.style.height = s[d2] + "px";
              this.layoutManager.registerSpace("top", { width: v.width, height: s[d2] });
            }
            this._chartsHeight = s;
            b = null;
            for (d2 = 0; d2 < this.charts.length; d2++)
              if (!f2(this.options.charts[d2].data))
                for (c2 = 0; c2 < this.options.charts[d2].data.length; c2++)
                  s = this.options.charts[d2].data[c2], 0 <= F2._supportedChartTypes.indexOf(s.type) || f2(s.type) || (aa2 = false, window.console && window.console.log("CanvasJS Error: " + s.type + " Chart is not Supported in StockChart"));
            if (!aa2)
              return;
            this.setChartsLayout();
            for (d2 = s = 0; d2 < this.charts.length; d2++)
              if (f2(this.charts[d2].options.colorSet)) {
                this.charts[d2].selectedColorSet = [];
                for (c2 = s; c2 < s + this.charts[d2].data.length; c2++)
                  this.charts[d2].selectedColorSet.push(this.selectedColorSet[c2 % this.selectedColorSet.length]);
                s += this.charts[d2].data.length;
              }
            if (this.navigator && this.navigator.enabled)
              if (f2(this.navigator.options.colorSet))
                if (this.navigator.options.data) {
                  this.navigator.chart.selectedColorSet = [];
                  for (c2 = s; c2 < s + this.navigator.chart.data.length; c2++)
                    this.navigator.chart.selectedColorSet.push(this.selectedColorSet[c2 % this.selectedColorSet.length]);
                  s += this.navigator.chart.data.length;
                } else
                  this.navigator.chart.selectedColorSet = this.charts[0].selectedColorSet;
              else
                this.navigator.chart.selectedColorSet = "undefined" !== typeof sa[this.navigator.options.colorSet] ? sa[this.navigator.options.colorSet] : sa.colorSet1;
          }
          if (this.navigator && this.navigator.enabled) {
            for (d2 = 0; d2 < this.navigator.chart.data.length; d2++)
              0 <= F2._supportedChartTypes.indexOf(this.navigator.chart.data[d2].type) || (aa2 = false, window.console && window.console.log("CanvasJS Error: " + this.navigator.chart.data[d2].type + " Chart is not Supported in Navigator"));
            if (aa2) {
              var e = this.navigator.chart.axisX && this.navigator.chart.axisX.length ? this.navigator.chart.axisX[0] : this.navigator.chart.axisX2[0];
              e && (e.bounds && e.bounds.x1 > this._chartsPlotAreaX1) && (this._chartsPlotAreaX1 = e.bounds.x1);
              this.navigator.width = this.navigator.chart.width = this.navigator.slider.fullWidth = this.navigator.options.width ? this.navigator.options.width : this._chartsPlotAreaX2 - this._chartsPlotAreaX1 + (e && e.bounds ? e.bounds.x1 : 0);
              this.navigator.panel.style.left = this._chartsPlotAreaX1 + this.layoutManager.getFreeSpace().x1 - (e && e.bounds ? e.bounds.x1 : 0) + "px";
              this.navigator.panel.style.width = this.navigator.chart.panel.style.width = this.navigator.options.width ? this.navigator.options.width : this._chartsPlotAreaX2 - this._chartsPlotAreaX1 + (e && e.bounds ? e.bounds.x1 : 0) + "px";
              0 < this.navigator.height && this.navigator.chart.render(this.navigator._chartOptions);
              this.navigator.backgroundColor = this.navigator.chart.backgroundColor;
              this.navigator.animationEnabled = this.navigator.chart.animationEnabled;
              this.navigator.animationDuration = this.navigator.chart.animationDuration;
              this.navigator.theme = this.navigator.chart.theme;
              this.navigator.axisX = this.navigator.chart.axisX;
              this.navigator.axisX2 = this.navigator.chart.axisX2;
              this.navigator.axisY = this.navigator.chart.axisY;
              this.navigator.axisY2 = this.navigator.chart.axisY2;
              this.navigator.data = this.navigator.chart.data;
            }
          }
          v = s = null;
          c2 = 0;
          h2 = a = null;
          for (d2 = 0; d2 < this.charts.length; d2++)
            for (b = this.charts[d2].axisX && this.charts[d2].axisX.length ? this.charts[d2].axisX : this.charts[d2].axisX2, s = s || (b && 0 < b.length ? b[0].minimum : null), v = v || (b && 0 < b.length ? b[0].maximum : null), c2 = 0; c2 < b.length; c2++)
              e = b[c2], e.minimum < s && (s = e.minimum), e.maximum > v && (v = e.maximum);
          var l2;
          this.navigator && (this.navigator.chart && aa2) && (l2 = this.navigator.chart.axisX && 0 < this.navigator.chart.axisX.length ? this.navigator.chart.axisX[0] : this.navigator.chart.axisX2[0], this._axisXMin = this.navigator.slider.minimum = f2(this.navigator.options.slider) || f2(this.navigator.options.slider.minimum) ? null : Math.max(l2.minimum, this.navigator.slider.minimum), this._axisXMax = this.navigator.slider.maximum = f2(this.navigator.options.slider) || f2(this.navigator.options.slider.maximum) ? null : Math.min(l2.maximum, this.navigator.slider.maximum));
          if (this.rangeSelector && this.rangeSelector.enabled) {
            c2 = l2 ? l2.maximum - l2.minimum : v - s;
            this.charts && this.charts.length && (e = this.charts[0].axisX && this.charts[0].axisX.length ? this.charts[0].axisX[0] : this.charts[0].axisX2[0]);
            for (d2 = 0; d2 < this.rangeSelector.buttons.length; d2++) {
              var w2 = null, b = this.rangeSelector.buttons[d2];
              "year" === b.rangeType ? w2 = 31104e6 * b.range : "ytd" === b.rangeType ? w2 = "ytd" : "month" === b.rangeType ? w2 = 2592e6 * b.range : "week" === b.rangeType ? w2 = 6048e5 * b.range : "day" === b.rangeType ? w2 = 864e5 * b.range : "hour" === b.rangeType ? w2 = 36e5 * b.range : "minute" === b.rangeType ? w2 = 6e4 * b.range : "second" === b.rangeType ? w2 = 1e3 * b.range : "millisecond" === b.rangeType ? w2 = b.range : "all" === b.rangeType ? w2 = null : "number" === b.rangeType && (w2 = b.range);
              if ("ytd" === b.rangeType || w2 < c2)
                b.enabled = true;
              b.enabled ? (b.cursor = this.rangeSelector.buttonStyle.cursor, "on" === b.state && ((f2(this._axisXMin) && f2(this._axisXMax) && (b.textBlock.fontWeight = "bold", b.textBlock.fontColor = this.rangeSelector.buttonStyle.labelFontColorOnHover, b.textBlock.backgroundColor = this.rangeSelector.buttonStyle.backgroundColorOnSelect), "ytd" === b.rangeType && e) ? (a = new Date(e.viewportMaximum), a.setDate(1), a.setMonth(0), a = a.getTime()) : f2(w2) ? l2 ? (a = l2.minimum, h2 = l2.maximum) : e && (a = e.minimum, h2 = e.maximum) : e.viewportMaximum - w2 < (l2 ? l2.minimum : e.minimum) ? (h2 = l2.minimum - (e.viewportMaximum - w2), a = l2.minimum, h2 = Math.min(l2.maximum, e.viewportMaximum + h2)) : (a = e.viewportMaximum - w2, h2 = e.viewportMaximum)), f2(this._axisXMin) && f2(this._axisXMax) || (b.state = "off"), this._axisXMin = f2(this._axisXMin) ? a : this._axisXMin, this._axisXMax = f2(this._axisXMax) ? h2 : this._axisXMax) : b.cursor = "not-allowed";
              b.mousemove = function(a2) {
                this.enabled && "off" === this.state && (this.textBlock.backgroundColor = a2.stockChart.rangeSelector.buttonStyle.backgroundColorOnHover, this.textBlock.fontColor = a2.stockChart.rangeSelector.buttonStyle.labelFontColorOnHover, this.textBlock.render(true));
              };
              b.mouseover = function(a2) {
                this.enabled && "off" === this.state && (this.textBlock.backgroundColor = a2.stockChart.rangeSelector.buttonStyle.backgroundColorOnHover, this.textBlock.fontColor = a2.stockChart.rangeSelector.buttonStyle.labelFontColorOnHover, this.textBlock.render(true));
              };
              b.mouseout = function(a2) {
                this.enabled && "off" === this.state && (this.textBlock.backgroundColor = a2.stockChart.rangeSelector.buttonStyle.backgroundColor, this.textBlock.fontColor = a2.stockChart.rangeSelector.buttonStyle.labelFontColor, this.textBlock.render(true));
              };
              b.click = function(a2) {
                if (this.enabled) {
                  for (var b2 = 0, c3 = null, d3 = null, e2 = 0; e2 < u2.rangeSelector.buttons.length; e2++)
                    u2.rangeSelector.buttons[e2] != this && (u2.rangeSelector.buttons[e2].state = "off"), u2.rangeSelector.buttons[e2].textBlock.fontWeight = u2.rangeSelector.buttonStyle.labelFontWeight, u2.rangeSelector.buttons[e2].textBlock.fontColor = a2.stockChart.rangeSelector.buttonStyle.labelFontColor, u2.rangeSelector.buttons[e2].textBlock.backgroundColor = a2.stockChart.rangeSelector.buttonStyle.backgroundColor, u2.rangeSelector.buttons[e2].textBlock.render(true);
                  var h3;
                  u2.charts && u2.charts.length && (h3 = u2.charts[0].axisX && u2.charts[0].axisX.length ? u2.charts[0].axisX[0] : u2.charts[0].axisX2[0]);
                  var g;
                  u2.navigator && u2.navigator.chart && (g = u2.navigator.chart.axisX ? u2.navigator.chart.axisX[0] : u2.navigator.chart.axisX2[0]);
                  "year" === this.rangeType ? b2 = 31104e6 * this.range : "month" === this.rangeType ? b2 = 2592e6 * this.range : "week" === this.rangeType ? b2 = 6048e5 * this.range : "day" === this.rangeType ? b2 = 864e5 * this.range : "hour" === this.rangeType ? b2 = 36e5 * this.range : "minute" === this.rangeType ? b2 = 6e4 * this.range : "second" === this.rangeType ? b2 = 1e3 * this.range : "millisecond" === this.rangeType ? b2 = this.range : "all" === this.rangeType ? b2 = null : "number" === this.rangeType && (b2 = this.range);
                  "ytd" === this.rangeType && h3 ? (c3 = new Date(h3.viewportMaximum), c3.setDate(1), c3.setMonth(0), b2 = c3.getTime(), c3 = Math.max(b2, g ? g.minimum : h3.minimum), d3 = h3.viewportMaximum) : f2(b2) ? g ? (c3 = g.minimum, d3 = g.maximum) : h3 && (c3 = h3.minimum, d3 = h3.maximum) : g && h3.viewportMaximum - b2 < (g ? g.minimum : h3.minimum) ? (g = u2.navigator.chart.axisX[0].minimum - (h3.viewportMaximum - b2), c3 = u2.navigator.chart.axisX[0].minimum, d3 = Math.min(u2.navigator.chart.axisX[0].maximum, h3.viewportMaximum + g)) : (c3 = h3.viewportMaximum - b2, d3 = h3.viewportMaximum);
                  u2._rangeEventParameter = { stockChart: u2, source: "buttons", index: this._index, minimum: c3, maximum: d3 };
                  "on" != this.state && (u2._rangeEventParameter.type = "rangeChanging", u2.dispatchEvent("rangeChanging", u2._rangeEventParameter, u2), u2._syncCharts(c3, d3), u2.sessionVariables._axisXMin = c3, u2.sessionVariables._axisXMax = d3, u2._rangeEventParameter.type = "rangeChanged", u2.dispatchEvent("rangeChanged", u2._rangeEventParameter, u2), this.state = "on");
                  this.textBlock.fontWeight = "bold";
                  this.textBlock.fontColor = a2.stockChart.rangeSelector.buttonStyle.labelFontColorOnHover;
                  this.textBlock.backgroundColor = a2.stockChart.rangeSelector.buttonStyle.backgroundColorOnSelect;
                  this.textBlock.render(true);
                }
              };
            }
            if (this.rangeSelector.inputFields && this.rangeSelector.inputFields.enabled) {
              this.rangeSelector.inputFields.valueType = this.options.rangeSelector && this.options.rangeSelector.inputFields && this.options.rangeSelector.inputFields.valueType ? this.options.rangeSelector.inputFields.valueType : this.isDateTime ? "dateTime" : "number";
              for (d2 = 0; d2 < this.rangeSelector.inputFields._textBlocks.length; d2++)
                e = this.rangeSelector.inputFields._textBlocks[d2], e.mousemove = function(a2) {
                  u2.rangeSelector && u2.rangeSelector.inputFields && !u2.rangeSelector.inputFields.enabled || (a2.inputField.cursor = a2.stockChart.rangeSelector.inputFields.style.cursor);
                }, e.mouseover = function(a2) {
                  u2.rangeSelector && u2.rangeSelector.inputFields && !u2.rangeSelector.inputFields.enabled || (a2.inputField.cursor = a2.stockChart.rangeSelector.inputFields.style.cursor);
                }, e.mouseout = function(a2) {
                  u2.rangeSelector && u2.rangeSelector.inputFields && !u2.rangeSelector.inputFields.enabled || (a2.inputField.cursor = "auto");
                }, e.click = function(a2) {
                  u2.rangeSelector && u2.rangeSelector.inputFields && !u2.rangeSelector.inputFields.enabled || (a2.stockChart.rangeSelector.inputFields.elements[a2.inputFieldIndex].style.display = "inline", a2.stockChart.rangeSelector.inputFields.elements[a2.inputFieldIndex].focus());
                };
              if (isFinite(s) && isFinite(v)) {
                "dateTime" === this.rangeSelector.inputFields.valueType ? (this.rangeSelector.inputFields.valueFormatString = this.options.rangeSelector && this.options.rangeSelector.inputFields && this.options.rangeSelector.inputFields.valueFormatString ? this.options.rangeSelector.inputFields.valueFormatString : "MMM DD YYYY", this.rangeSelector.inputFields.startValue = f2(this.rangeSelector.inputFields.options.startValue) ? f2(a) ? s : a : ea(this.rangeSelector.inputFields.options.startValue, this.rangeSelector.inputFields.valueFormatString), this.rangeSelector.inputFields.endValue = f2(this.rangeSelector.inputFields.options.endValue) ? f2(h2) ? v : h2 : ea(this.rangeSelector.inputFields.options.endValue, this.rangeSelector.inputFields.valueFormatString)) : (this.rangeSelector.inputFields.valueFormatString = this.options.rangeSelector && this.options.rangeSelector.inputFields && this.options.rangeSelector.inputFields.valueFormatString ? this.options.rangeSelector.inputFields.valueFormatString : "#,##0.##", this.rangeSelector.inputFields.startValue = f2(this.rangeSelector.inputFields.options.startValue) ? f2(a) ? s : a : this.rangeSelector.inputFields.options.startValue, this.rangeSelector.inputFields.endValue = f2(this.rangeSelector.inputFields.options.endValue) ? f2(h2) ? v : h2 : this.rangeSelector.inputFields.options.endValue);
                if (!(f2(this._axisXMin) && f2(this._axisXMax) && f2(this.rangeSelector.inputFields.options.startValue) && f2(this.rangeSelector.inputFields.options.endValue)))
                  for (c2 = 0; c2 < this.rangeSelector.buttons.length; c2++)
                    b = this.rangeSelector.buttons[c2];
                d2 = ea(this.rangeSelector.inputFields.startValue, "YYYY-MM-DD'T'HH:mm:ssZ");
                e = ea(this.rangeSelector.inputFields.endValue, "YYYY-MM-DD'T'HH:mm:ssZ");
                r || (d2 = d2.replace(/-/g, "/"), e = e.replace(/-/g, "/"), d2 = d2.replace("T", " "), e = e.replace("T", " "), d2 = d2.replace(/(\+[0-9]{2})(\:)([0-9]{2}$)/, " UTC$1$3"), e = e.replace(/(\+[0-9]{2})(\:)([0-9]{2}$)/, " UTC$1$3"));
                this._axisXMin = f2(this._axisXMin) ? "dateTime" === this.rangeSelector.inputFields.valueType ? new Date(d2).getTime() : this.rangeSelector.inputFields.startValue : this._axisXMin;
                this._axisXMax = f2(this._axisXMax) ? "dateTime" === this.rangeSelector.inputFields.valueType ? new Date(e).getTime() : this.rangeSelector.inputFields.endValue : this._axisXMax;
              }
              for (d2 = 0; d2 < this.rangeSelector.inputFields.elements.length; d2++)
                this.rangeSelector.inputFields.elements[d2].title = "dateTime" === this.rangeSelector.inputFields.valueType ? "YYYY-MM-DD" : this.rangeSelector.inputFields.valueFormatString;
            }
            this.rangeSelector.render();
          }
          f2(this._axisXMin) && (this._axisXMin = s);
          f2(this._axisXMax) && (this._axisXMax = v);
          this._axisXMin = !f2(this.sessionVariables._axisXMin) && this.navigator && this.navigator.slider && !this.navigator.slider.hasOptionChanged("minimum") ? this.sessionVariables._axisXMin : this._axisXMin;
          this._axisXMax = !f2(this.sessionVariables._axisXMax) && this.navigator && this.navigator.slider && !this.navigator.slider.hasOptionChanged("maximum") ? this.sessionVariables._axisXMax : this._axisXMax;
          if (!f2(l2)) {
            this.navigator.slider.hasOptionChanged("minimum") && (this._axisXMin = this.sessionVariables._axisXMin = this.navigator.slider.sessionVariables.minimum = this.navigator.slider.minimum = this.navigator.slider.options.minimum);
            this.navigator.slider.hasOptionChanged("maximum") && (this._axisXMax = this.sessionVariables._axisXMax = this.navigator.slider.sessionVariables.maximum = this.navigator.slider.maximum = this.navigator.slider.options.maximum);
            if (this._axisXMin < l2.minimum || this._axisXMin > l2.maximum)
              this._axisXMin = l2.minimum;
            if (this._axisXMax < l2.minimum || this._axisXMax > l2.maximum)
              this._axisXMax = l2.maximum;
          }
          !f2(l2) && l2.reversed ? this._syncCharts(this._axisXMax, this._axisXMin) : this._syncCharts(this._axisXMin, this._axisXMax);
        };
        F2.prototype.setChartsLayout = function() {
          var d2, f3, k3 = 0, v = this.width;
          this.isPlotAreaSet = this.isDateTime = false;
          for (var a = 0; a < this.charts.length; a++) {
            d2 = this.charts[a];
            d2._initialize();
            d2.setLayout();
            f3 = {};
            if ((d2.axisX[0] || d2.axisX2[0]) && (d2.axisY[0] || d2.axisY2[0])) {
              var h2 = d2.axisX[0] ? d2.axisX[0].lineCoordinates : d2.axisX2[0].lineCoordinates;
              if (d2.axisY && 0 < d2.axisY.length && d2.axisY[0]) {
                var c2 = d2.axisY[0];
                f3.x1 = h2.x1 < h2.x2 ? h2.x1 : c2.lineCoordinates.x1;
                f3.x2 = h2.x2 > c2.lineCoordinates.x2 ? h2.x2 : c2.lineCoordinates.x2;
              }
              d2.axisY2 && 0 < d2.axisY2.length && d2.axisY2[0] && (c2 = d2.axisY2[0], f3.x1 = h2.x1 < h2.x2 ? h2.x1 : c2.lineCoordinates.x1, f3.x2 = h2.x2 > c2.lineCoordinates.x2 ? h2.x2 : c2.lineCoordinates.x2);
            }
            for (h2 = 0; h2 < d2.data.length; h2++)
              "dateTime" === d2.data[h2].xValueType && (this.isDateTime = true);
            k3 = Math.max(k3, f3.x1);
            v = Math.min(v, f3.x2);
            d2.sessionVariables.plotAreaBounds = f3;
          }
          this._chartsPlotAreaX1 = k3;
          this._chartsPlotAreaX2 = v;
        };
        F2.prototype._updateSize = function() {
          return lb.call(this, [this.canvas, this.overlaidCanvas]);
        };
        F2.prototype._syncCharts = function(d2, k3) {
          for (var s = this, v = null, a = Math.min(d2, k3), h2 = Math.max(d2, k3), c2 = 0; c2 < this.charts.length; c2++) {
            v = this.charts[c2];
            v.toolTip && (isNaN(v.toolTip._prevX) || isNaN(v.toolTip._prevY)) && v.toolTip.hide();
            for (var b = 0; b < v.axisX.length; b++)
              v.axisX[b].setViewPortRange(d2, k3), v.axisX[b].options.labelAngle = f2(v.axisX[b].options.labelAngle) ? 0 : v.axisX[b].options.labelAngle, this.charts[c2].axisX[b].crosshair && this.charts[c2].axisX[b].crosshair.enabled && (this.charts[c2].axisX[b].crosshair.options.updated || (this.charts[c2].axisX[b].crosshair.options.updated = function(a2) {
                for (var b2 = 0; b2 < s.charts.length; b2++)
                  if (s.charts[b2] != a2.chart)
                    for (var c3 = 0; c3 < s.charts[b2].axisX.length; c3++)
                      s.charts[b2].axisX[c3].crosshair && s.charts[b2].axisX[c3].crosshair.showAt(a2.value);
              }), this.charts[c2].axisX[b].crosshair.options.hidden || (this.charts[c2].axisX[b].crosshair.options.hidden = function(a2) {
                for (var b2 = 0; b2 < s.charts.length; b2++)
                  if (s.charts[b2] != a2.chart)
                    for (var c3 = 0; c3 < s.charts[b2].axisX.length; c3++)
                      s.charts[b2].axisX[c3].crosshair && s.charts[b2].axisX[c3].crosshair.hide();
              }));
            for (b = 0; b < v.axisX2.length; b++)
              v.axisX2[b].setViewPortRange(d2, k3), v.axisX2[b].options.labelAngle = f2(v.axisX2[b].options.labelAngle) ? 0 : v.axisX2[b].options.labelAngle, this.charts[c2].axisX2[b].crosshair && this.charts[c2].axisX2[b].crosshair.enabled && (this.charts[c2].axisX2[b].crosshair.options.updated || (this.charts[c2].axisX2[b].crosshair.options.updated = function(a2) {
                for (var b2 = 0; b2 < s.charts.length; b2++)
                  if (s.charts[b2] != a2.chart)
                    for (var c3 = 0; c3 < s.charts[b2].axisX2.length; c3++)
                      s.charts[b2].axisX2[c3].crosshair && s.charts[b2].axisX2[c3].crosshair.showAt(a2.value);
              }), this.charts[c2].axisX2[b].crosshair.options.hidden || (this.charts[c2].axisX2[b].crosshair.options.hidden = function(a2) {
                for (var b2 = 0; b2 < s.charts.length; b2++)
                  if (s.charts[b2] != a2.chart)
                    for (var c3 = 0; c3 < s.charts[b2].axisX2.length; c3++)
                      s.charts[b2].axisX2[c3].crosshair && s.charts[b2].axisX2[c3].crosshair.hide();
              }));
            v.options.toolbar ? v.options.toolbar = v.options.toolbar : s.options.toolbar && (v.options.toolbar = s.options.toolbar);
            v._initialize();
            v.setLayout();
            v.panEnabled = v.options.zoomEnabled && v.zoomEnabled ? false : true;
            v.renderElements();
            (f2(this.charts[c2].options.toolTip) || !f2(this.charts[c2].options.toolTip) && f2(this.charts[c2].options.toolTip.updated)) && this.charts[c2].toolTip && (this.charts[c2].toolTip.updated = function(a2) {
              for (var b2 = 0; b2 < s.charts.length; b2++)
                s.charts[b2] != a2.chart && s.charts[b2].toolTip.showAtX(a2.entries[0].xValue, a2.entries[0].dataSeriesIndex);
            });
            (f2(this.charts[c2].options.toolTip) || !f2(this.charts[c2].options.toolTip) && f2(this.charts[c2].options.toolTip.hidden)) && this.charts[c2].toolTip && (this.charts[c2].toolTip.hidden = function(a2) {
              for (var b2 = 0; b2 < s.charts.length; b2++)
                s.charts[b2] != a2.chart && s.charts[b2].toolTip.hide();
            });
          }
          this.rangeSelector && (this.rangeSelector.enabled && this.rangeSelector.inputFields && this.rangeSelector.inputFields.enabled) && this.rangeSelector._updateInputFields(a, h2);
          this.navigator && this.navigator.enabled && this.navigator._updateSlider(a, h2);
        };
        F2.prototype.destroy = function() {
          for (var d2 = this.allDOMEventHandlers, f3 = 0; f3 < this.charts.length; f3++)
            this.charts[f3].destroy();
          this.navigator && this.navigator.enabled && this.navigator.chart.destroy();
          for (f3 = 0; f3 < d2.length; f3++)
            gb(d2[f3][0], d2[f3][1], d2[f3][2], d2[f3][3]);
          for (this.allDOMEventHandlers = []; this.navigator && this.navigator.enabled && this.navigator.panel.hasChildNodes(); )
            this.navigator.panel.removeChild(this.navigator.panel.lastChild);
          for (; this._canvasJSContainer && this._canvasJSContainer.hasChildNodes(); )
            this._canvasJSContainer.removeChild(this._canvasJSContainer.lastChild);
          for (; this.container && this.container.hasChildNodes(); )
            this.container.removeChild(this.container.lastChild);
          this.container = this._canvasJSContainer = null;
          Ca(this.canvas);
          Ca(this.overlaidCanvas);
          this._eventManager && this._eventManager.ghostCanvas && Ca(this._eventManager.ghostCanvas);
          this.navigator.panel = null;
          this.rangeSelector.panel = null;
        };
        F2.prototype.exportChart = function(d2) {
          d2 = "undefined" === typeof d2 ? {} : d2;
          var f3 = d2.format ? d2.format : "png", k3 = d2.fileName ? d2.fileName : this.exportFileName, v = this.canvas.cloneNode();
          v.setAttribute("class", v.getAttribute("class") + "-clone");
          var a = v.getContext("2d");
          a.drawImage(this.canvas, 0, 0);
          for (var h2 = [], c2 = 0; c2 < this.charts.length; c2++) {
            var b = this.charts[c2];
            h2.push({ canvas: b.canvas, position: { x: b.container.offsetLeft, y: b.container.offsetTop } });
            h2.push({ canvas: b.overlaidCanvas, position: { x: b.container.offsetLeft, y: b.container.offsetTop } });
          }
          this.navigator && this.navigator.enabled && (c2 = this.navigator, h2.push({ canvas: c2.chart.canvas, position: { x: c2.panel.offsetLeft, y: c2.panel.offsetTop } }), h2.push({ canvas: c2.chart.overlaidCanvas, position: { x: c2.panel.offsetLeft, y: c2.panel.offsetTop } }));
          for (c2 = 0; c2 < h2.length; c2++)
            a.drawImage(h2[c2].canvas, h2[c2].position.x * ja, h2[c2].position.y * ja);
          if (d2.toDataURL)
            return v.toDataURL("image/" + f3);
          db(v, f3, k3);
        };
        F2.prototype.print = function() {
          var d2 = this.exportChart({ toDataURL: true }), f3 = document.createElement("iframe");
          f3.setAttribute("class", "canvasjs-chart-print-frame");
          O(f3, {
            position: "absolute",
            width: "100%",
            border: 0,
            margin: 0,
            padding: 0
          });
          f3.style.height = this.height + "px";
          this._canvasJSContainer.appendChild(f3);
          var k3 = this, v = f3.contentWindow || f3.contentDocument.document || f3.contentDocument;
          v.document.open();
          v.document.write('<!DOCTYPE HTML>\n<html><body><img src="' + d2 + '"/><body/></html>');
          v.document.body && v.document.body.style && (v.document.body.style.margin = "0px 0px 0px 0px", v.document.body.style.padding = "0px 0px 0px 0px");
          v.document.close();
          setTimeout(function() {
            v.focus();
            v.print();
            setTimeout(
              function() {
                k3._canvasJSContainer.removeChild(f3);
              },
              1e3
            );
          }, 500);
        };
        F2.prototype.getObjectAtXY = function(d2, k3, s) {
          s = null;
          if (!f2(this.rangeSelector)) {
            for (var v = 0; v < this.rangeSelector.buttons.length; v++) {
              var a = this.rangeSelector.buttons[v];
              d2 >= a.bounds.x1 && (d2 <= a.bounds.x2 && k3 >= a.bounds.y1 && k3 <= a.bounds.y2) && (s = a.id);
            }
            for (v = 0; v < this.rangeSelector.inputFields._textBlocks.length; v++)
              a = this.rangeSelector.inputFields._textBlocks[v], d2 >= a.bounds.x1 && (d2 <= a.bounds.x2 && k3 >= a.bounds.y1 && k3 <= a.bounds.y2) && (s = a.id);
          }
          return s;
        };
        F2.prototype._touchEventHandler = function(d2) {
          if (d2.changedTouches) {
            var k3 = [], s = d2.changedTouches, v = s ? s[0] : d2, a = null;
            switch (d2.type) {
              case "touchstart":
              case "MSPointerDown":
                k3 = ["mousemove", "mousedown"];
                this._lastTouchData = Aa(v);
                this._lastTouchData.time = new Date();
                break;
              case "touchmove":
              case "MSPointerMove":
                k3 = ["mousemove"];
                break;
              case "touchend":
              case "MSPointerUp":
                var h2 = this._lastTouchData && this._lastTouchData.time ? new Date() - this._lastTouchData.time : 0, k3 = "touchstart" === this._lastTouchEventType || "MSPointerDown" === this._lastTouchEventType || 300 > h2 ? ["mouseup", "click"] : ["mouseup"];
                break;
              default:
                return;
            }
            if (!(s && 1 < s.length)) {
              a = Aa(v);
              a.time = new Date();
              try {
                var c2 = a.y - this._lastTouchData.y, h2 = a.time - this._lastTouchData.time;
                if (1 < Math.abs(c2) && this._lastTouchData.scroll || 5 < Math.abs(c2) && 250 > h2)
                  this._lastTouchData.scroll = true;
              } catch (b) {
              }
              this._lastTouchEventType = d2.type;
              if (this._lastTouchData && this._lastTouchData.scroll)
                this.isDrag && this.resetOverlayedCanvas(), this.isDrag = false;
              else
                for (s = 0; s < k3.length; s++)
                  if (a = k3[s], c2 = document.createEvent("MouseEvent"), c2.initMouseEvent(
                    a,
                    true,
                    true,
                    window,
                    1,
                    v.screenX,
                    v.screenY,
                    v.clientX,
                    v.clientY,
                    false,
                    false,
                    false,
                    false,
                    0,
                    null
                  ), v.target.dispatchEvent(c2), this._lastTouchData && !f2(this._lastTouchData.scroll) && !this._lastTouchData.scroll || this._lastTouchData && !this._lastTouchData.scroll && 250 < h2 || "click" === a)
                    d2.preventManipulation && d2.preventManipulation(), d2.preventDefault && d2.cancelable && d2.preventDefault();
            }
          }
        };
        F2.prototype._mouseEventHandler = function(d2) {
          "undefined" === typeof d2.target && d2.srcElement && (d2.target = d2.srcElement);
          var f3 = Aa(d2), k3 = d2.type, v, a;
          d2.which ? a = 3 == d2.which : d2.button && (a = 2 == d2.button);
          F2.capturedEventParam && (v = F2.capturedEventParam, "mouseup" === k3 && (F2.capturedEventParam = null, v.stockChart.overlaidCanvas.releaseCapture ? v.stockChart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", v.stockChart._mouseEventHandler, false)), v.hasOwnProperty(k3) && ("mouseup" !== k3 || v.stockChart.overlaidCanvas.releaseCapture ? d2.target !== v.stockChart.overlaidCanvas && r || v[k3].call(v.context, f3.x, f3.y) : d2.target !== v.stockChart.overlaidCanvas && (v.stockChart.isDrag = false)));
          if (this._ignoreNextEvent)
            this._ignoreNextEvent = false;
          else if (d2.preventManipulation && d2.preventManipulation(), d2.preventDefault && d2.preventDefault(), Ma && window.console && (window.console.log(k3 + " --> x: " + f3.x + "; y:" + f3.y), a && window.console.log(d2.which), "mouseup" === k3 && window.console.log("mouseup")), !a) {
            if (!F2.capturedEventParam && this._events) {
              for (var h2 = 0; h2 < this._events.length; h2++)
                if (this._events[h2].hasOwnProperty(k3))
                  if (v = this._events[h2], a = v.bounds, f3.x >= a.x1 && f3.x <= a.x2 && f3.y >= a.y1 && f3.y <= a.y2) {
                    v[k3].call(v.context, f3.x, f3.y);
                    "mousedown" === k3 && true === v.capture ? (Chart.capturedEventParam = v, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener("mouseup", this._mouseEventHandler, false)) : "mouseup" === k3 && (v.stockChart.overlaidCanvas.releaseCapture ? v.stockChart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", this._mouseEventHandler, false));
                    break;
                  } else
                    v = null;
              d2.target.style.cursor = v && v.cursor ? v.cursor : this._defaultCursor;
            }
            k3 = this.bounds;
            (f3.x < k3.x1 || f3.x > k3.x2 || f3.y < k3.y1 || f3.y > k3.y2) && this.resetOverlayedCanvas();
            !this.isDrag && this._eventManager && this._eventManager.mouseEventHandler(d2);
          }
        };
        F2.prototype.resetOverlayedCanvas = function() {
          this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height);
        };
        F2.prototype.clearCanvas = mb;
        F2.prototype.getAutoFontSize = nb;
        ga(J, Ha);
        ga(L2, Na);
        Ja.prototype.alignVerticalAxes = function() {
          if (!this.isNavigator && this.stockChart) {
            for (var d2 = this.sessionVariables.plotAreaBounds, f3 = this.stockChart._chartsPlotAreaX1 - d2.x1, d2 = d2.x2 - this.stockChart._chartsPlotAreaX2, k3 = 0; k3 < this.axisX.length; k3++)
              this.axisX[k3].lineCoordinates.x1 += f3, this.axisX[k3].lineCoordinates.x2 -= d2, this.axisX[k3].lineCoordinates.width = this.axisX[k3].lineCoordinates.x2 - this.axisX[k3].lineCoordinates.x1, this.axisX[k3].bounds.x1 += f3, this.axisX[k3].bounds.x2 -= d2, this.axisX[k3].calculateValueToPixelConversionParameters();
            for (k3 = 0; k3 < this.axisX2.length; k3++)
              this.axisX2[k3].lineCoordinates.x1 += f3, this.axisX2[k3].lineCoordinates.x2 -= d2, this.axisX2[k3].lineCoordinates.width = this.axisX2[k3].lineCoordinates.x2 - this.axisX2[k3].lineCoordinates.x1, this.axisX2[k3].bounds.x1 += f3, this.axisX2[k3].bounds.x2 -= d2, this.axisX2[k3].calculateValueToPixelConversionParameters();
            for (k3 = 0; k3 < this.axisY.length; k3++)
              this.axisY[k3].lineCoordinates.x1 += f3, this.axisY[k3].lineCoordinates.x2 += f3, this.axisY[k3].bounds.x1 += f3, this.axisY[k3].bounds.x2 += f3;
            for (k3 = 0; k3 < this.axisY2.length; k3++)
              this.axisY2[k3].lineCoordinates.x1 -= d2, this.axisY2[k3].lineCoordinates.x2 -= d2, this.axisY2[k3].bounds.x1 -= d2, this.axisY2[k3].bounds.x2 -= d2;
          }
        };
        Ja.prototype.syncCharts = function(d2, k3) {
          this.stockChart && (d2 = f2(d2) ? this.stockChart._axisXMin : d2, k3 = f2(k3) ? this.stockChart._axisXMax : k3, this.stockChart._syncCharts(d2, k3), this.stockChart.sessionVariables._axisXMin = d2, this.stockChart.sessionVariables._axisXMax = k3, this.stockChart.rangeSelector && "zoom" !== this._zoomButton.getAttribute("state") && this.stockChart.rangeSelector.resetRangeButtons());
        };
        P.prototype.reset = function() {
          this.lastObjectId = 0;
          this.objectMap = [];
          this.rectangularRegionEventSubscriptions = [];
          this.eventObjects = [];
          r && (this.ghostCtx.clearRect(0, 0, this.stockChart.width, this.stockChart.height), this.ghostCtx.beginPath());
        };
        P.prototype.getNewObjectTrackingId = function() {
          return ++this.lastObjectId;
        };
        P.prototype.mouseEventHandler = function(d2) {
          if ("mousemove" === d2.type || "click" === d2.type) {
            var f3 = [], k3 = Aa(d2), v = null;
            if ((v = this.stockChart.getObjectAtXY(k3.x, k3.y, false)) && "undefined" !== typeof this.objectMap[v])
              if (v = this.objectMap[v], "rangeButton" === v.objectType) {
                var a = this.stockChart.rangeSelector.buttons[v.rangeButtonIndex];
                v.eventParameter = { x: k3.x, y: k3.y, rangeButton: a, rangeButtonIndex: v.rangeButtonIndex, stockChart: this.stockChart };
                v.eventContext = {
                  context: this.stockChart.rangeSelector,
                  userContext: a,
                  mouseover: "mouseover",
                  mousemove: "mousemove",
                  mouseout: "mouseout",
                  click: "click"
                };
                f3.push(v);
              } else
                "inputFields" === v.objectType && (a = this.stockChart.rangeSelector.inputFields._textBlocks[v.inputFieldIndex], v.eventParameter = { x: k3.x, y: k3.y, inputField: a, inputFieldIndex: v.inputFieldIndex, stockChart: this.stockChart }, v.eventContext = { context: this.stockChart.rangeSelector, userContext: a, mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", click: "click" }, f3.push(v));
            a = [];
            for (k3 = 0; k3 < this.mouseoveredObjectMaps.length; k3++) {
              for (var h2 = true, v = 0; v < f3.length; v++)
                if (f3[v].id === this.mouseoveredObjectMaps[k3].id) {
                  h2 = false;
                  break;
                }
              h2 ? this.fireEvent(this.mouseoveredObjectMaps[k3], "mouseout", d2) : a.push(this.mouseoveredObjectMaps[k3]);
            }
            this.mouseoveredObjectMaps = a;
            for (k3 = 0; k3 < f3.length; k3++) {
              a = false;
              for (v = 0; v < this.mouseoveredObjectMaps.length; v++)
                if (f3[k3].id === this.mouseoveredObjectMaps[v].id) {
                  a = true;
                  break;
                }
              a || (this.fireEvent(f3[k3], "mouseover", d2), this.mouseoveredObjectMaps.push(f3[k3]));
              "click" === d2.type ? this.fireEvent(f3[k3], "click", d2) : "mousemove" === d2.type && this.fireEvent(
                f3[k3],
                "mousemove",
                d2
              );
            }
          }
        };
        P.prototype.fireEvent = function(d2, f3, k3) {
          if (d2 && f3) {
            var v = d2.eventParameter, a = d2.eventContext, h2 = d2.eventContext.userContext;
            h2 && (a && h2[a[f3]]) && h2[a[f3]].call(h2, v);
            "mouseout" !== f3 ? h2.cursor && h2.cursor !== k3.target.style.cursor && (k3.target.style.cursor = h2.cursor) : (k3.target.style.cursor = this.stockChart._defaultCursor, delete d2.eventParameter, delete d2.eventContext);
          }
        };
        ga(A, $);
        A.prototype._updateOptions = function() {
          this.updateOption("enabled");
          this.updateOption("backgroundColor");
          "undefined" === typeof this.options.backgroundColor && "undefined" !== typeof this.stockChart.options.backgroundColor && (this.backgroundColor = this.stockChart.backgroundColor);
          this.backgroundColor || (this.backgroundColor = "rgba(0, 0, 0, 0)");
          this.updateOption("animationEnabled");
          this.animationEnabled = this.animationEnabled && r;
          this.updateOption("animationDuration");
          this.updateOption("theme");
          this.updateOption("verticalAlign");
          this.updateOption("horizontalAlign");
          this.updateOption("width");
          this.updateOption("height");
          this.updateOption("dynamicUpdate");
        };
        A.prototype._initialize = function() {
          this._updateOptions();
          var d2;
          this.enabled && !this.panel && (this.panel = k2("canvasjs-navigator-panel"), (d2 = !f2(this.panel) && this.stockChart._canvasJSContainer.contains(this.panel)) || this.stockChart._canvasJSContainer.appendChild(this.panel));
          d2 = !f2(this.panel) && this.stockChart._canvasJSContainer.contains(this.panel);
          if (this.enabled) {
            this.height = f2(this.options.height) ? 0.14 * this.stockChart.height : parseInt(this.options.height);
            d2 || this.stockChart._canvasJSContainer.appendChild(this.panel);
            var u2 = this.stockChart.layoutManager.getFreeSpace(), s = u2.x1, v = u2.y1;
            this.width = this.options.width ? this.width : u2.width;
            "top" === this.verticalAlign ? (v = u2.y1 + 2, d2 = "top") : (v = u2.y2 - this.height - 2, d2 = "bottom");
            "left" === this.horizontalAlign ? s = u2.x1 - 2 : "center" === this.horizontalAlign ? s = u2.x1 + u2.width / 2 - this.width / 2 : "right" === this.horizontalAlign && (s = u2.x2 - 2 - this.width);
            this.panel.style.top = v + "px";
            this.panel.style.left = s + "px";
            this.panel.style.height = this.height + "px";
            this.panel.style.width = this.width + "px";
            this.stockChart.layoutManager.registerSpace(d2, { width: this.width, height: this.height + 2 });
            this.bounds = { x1: s, y1: v, x2: s + this.width, y2: v + this.height };
          } else
            d2 && this.stockChart._canvasJSContainer.removeChild(this.panel);
        };
        A.prototype._updateSlider = function(d2, k3) {
          var s = this.chart.axisX && this.chart.axisX.length ? this.chart.axisX[0] : this.chart.axisX2[0];
          if (!f2(s)) {
            var v = Math.min(s.bounds.x2, Math.max(s.bounds.x1, s.convertValueToPixel(s.reversed ? Math.max(d2, Math.min(s.maximum, k3)) : Math.min(d2, Math.min(s.maximum, k3))))), a = Math.max(s.bounds.x1, Math.min(s.bounds.x2, s.convertValueToPixel(s.reversed ? Math.min(
              d2,
              Math.min(s.maximum, k3)
            ) : Math.max(d2, Math.min(s.maximum, k3)))));
            this.slider.panel.style.left = v + "px";
            this.slider.left = v;
            this.slider.panel.style.width = a - v + "px";
            this.slider.width = a - v;
            this.slider.minimum = s.convertPixelToValue(s.reversed ? a : v);
            this.slider.maximum = s.convertPixelToValue(s.reversed ? v : a);
            this.chart.resetOverlayedCanvas();
            this.slider.maskInverted ? ba(this.chart.overlaidCanvasCtx, v, 0, a, this.height, this.slider.maskColor, 0, this.slider.outlineColor, 0, 0, 0, 0, this.slider.maskOpacity) : (ba(
              this.chart.overlaidCanvasCtx,
              s.bounds.x1,
              0,
              v,
              this.height,
              this.slider.maskColor,
              0,
              this.slider.outlineColor,
              false,
              false,
              false,
              false,
              this.slider.maskOpacity
            ), ba(this.chart.overlaidCanvasCtx, a, 0, this.width, this.height, this.slider.maskColor, 0, this.slider.outlineColor, false, false, false, false, this.slider.maskOpacity));
            this.chart.overlaidCanvasCtx.lineWidth = this.slider.outlineThickness;
            this.chart.overlaidCanvasCtx.strokeStyle = this.slider.outlineColor;
            this.chart.overlaidCanvasCtx.save();
            this.chart.overlaidCanvasCtx.beginPath();
            0 < this.slider.outlineThickness && (this.slider.outlineInverted ? (this.chart.overlaidCanvasCtx.moveTo(s.bounds.x1, this.height - this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(1 === this.slider.outlineThickness % 2 ? (v - this.slider.outlineThickness / 2 << 0) + 0.5 : v, this.height - this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(1 === this.slider.outlineThickness % 2 ? (v - this.slider.outlineThickness / 2 << 0) + 0.5 : v, this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(1 === this.slider.outlineThickness % 2 ? (a - this.slider.outlineThickness / 2 << 0) + 0.5 : a, this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(1 === this.slider.outlineThickness % 2 ? (a - this.slider.outlineThickness / 2 << 0) + 0.5 : a, this.height - this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(this.width, this.height - this.slider.outlineThickness)) : (this.chart.overlaidCanvasCtx.moveTo(s.bounds.x1, this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(1 === this.slider.outlineThickness % 2 ? (v - this.slider.outlineThickness / 2 << 0) + 0.5 : v, this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(1 === this.slider.outlineThickness % 2 ? (v - this.slider.outlineThickness / 2 << 0) + 0.5 : v, this.height - this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(1 === this.slider.outlineThickness % 2 ? (a - this.slider.outlineThickness / 2 << 0) + 0.5 : a, this.height - this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(1 === this.slider.outlineThickness % 2 ? (a - this.slider.outlineThickness / 2 << 0) + 0.5 : a, this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(this.width, this.slider.outlineThickness / 2)));
            this.chart.overlaidCanvasCtx.stroke();
            this.chart.overlaidCanvasCtx.restore();
            ba(this.chart.overlaidCanvasCtx, 1 === this.slider.handleBorderThickness % 2 ? v - this.slider.handleWidth / 2 << 0.5 : v - this.slider.handleWidth / 2 << 0, 1 === this.slider.handleBorderThickness % 2 ? this.height / 2 - this.slider.handleHeight / 2 << 0.5 : this.height / 2 - this.slider.handleHeight / 2 << 0, 1 === this.slider.handleBorderThickness % 2 ? v + this.slider.handleWidth / 2 << 0.5 : v + this.slider.handleWidth / 2 << 0, 1 === this.slider.handleBorderThickness % 2 ? this.height / 2 + this.slider.handleHeight / 2 << 0.5 : this.height / 2 + this.slider.handleHeight / 2 << 0, this.slider.handleColor, this.slider.handleBorderThickness, this.slider.handleBorderColor, false, false, false, false, 1);
            ba(this.chart.overlaidCanvasCtx, 1 === this.slider.handleBorderThickness % 2 ? a - this.slider.handleWidth / 2 << 0.5 : a - this.slider.handleWidth / 2 << 0, 1 === this.slider.handleBorderThickness % 2 ? this.height / 2 - this.slider.handleHeight / 2 << 0.5 : this.height / 2 - this.slider.handleHeight / 2 << 0, 1 === this.slider.handleBorderThickness % 2 ? a + this.slider.handleWidth / 2 << 0.5 : a + this.slider.handleWidth / 2 << 0, 1 === this.slider.handleBorderThickness % 2 ? this.height / 2 + this.slider.handleHeight / 2 << 0.5 : this.height / 2 + this.slider.handleHeight / 2 << 0, this.slider.handleColor, this.slider.handleBorderThickness, this.slider.handleBorderColor, false, false, false, false, 1);
            this.chart.overlaidCanvasCtx.lineWidth = this.slider.handleBorderThickness;
            this.chart.overlaidCanvasCtx.strokeStyle = this.slider.handleBorderColor;
            this.chart.overlaidCanvasCtx.save();
            this.chart.overlaidCanvasCtx.beginPath();
            this.chart.overlaidCanvasCtx.moveTo((1 === this.slider.handleBorderThickness % 2 ? (v - this.slider.handleBorderThickness / 2 << 0) + 0.5 : v) - Math.round(this.slider.handleBorderThickness), this.height / 2 - this.slider.handleHeight / 4);
            this.chart.overlaidCanvasCtx.lineTo((1 === this.slider.handleBorderThickness % 2 ? (v - this.slider.handleBorderThickness / 2 << 0) + 0.5 : v) - Math.round(this.slider.handleBorderThickness), this.height / 2 + this.slider.handleHeight / 4);
            this.chart.overlaidCanvasCtx.moveTo((1 === this.slider.handleBorderThickness % 2 ? (v + this.slider.handleBorderThickness / 2 << 0) + 0.5 : v) + Math.round(this.slider.handleBorderThickness), this.height / 2 - this.slider.handleHeight / 4);
            this.chart.overlaidCanvasCtx.lineTo((1 === this.slider.handleBorderThickness % 2 ? (v + this.slider.handleBorderThickness / 2 << 0) + 0.5 : v) + Math.round(this.slider.handleBorderThickness), this.height / 2 + this.slider.handleHeight / 4);
            this.chart.overlaidCanvasCtx.moveTo((1 === this.slider.handleBorderThickness % 2 ? (a - this.slider.handleBorderThickness / 2 << 0) + 0.5 : a) - Math.round(this.slider.handleBorderThickness), this.height / 2 - this.slider.handleHeight / 4);
            this.chart.overlaidCanvasCtx.lineTo((1 === this.slider.handleBorderThickness % 2 ? (a - this.slider.handleBorderThickness / 2 << 0) + 0.5 : a) - Math.round(this.slider.handleBorderThickness), this.height / 2 + this.slider.handleHeight / 4);
            this.chart.overlaidCanvasCtx.moveTo((1 === this.slider.handleBorderThickness % 2 ? (a + this.slider.handleBorderThickness / 2 << 0) + 0.5 : a) + Math.round(this.slider.handleBorderThickness), this.height / 2 - this.slider.handleHeight / 4);
            this.chart.overlaidCanvasCtx.lineTo((1 === this.slider.handleBorderThickness % 2 ? (a + this.slider.handleBorderThickness / 2 << 0) + 0.5 : a) + Math.round(this.slider.handleBorderThickness), this.height / 2 + this.slider.handleHeight / 4);
            this.chart.overlaidCanvasCtx.stroke();
            this.chart.overlaidCanvasCtx.restore();
          }
        };
        ga(M2, $);
        M2.prototype._updateOptions = function() {
          this.updateOption("maskColor");
          this.updateOption("maskInverted");
          this.updateOption("maskOpacity");
          this.updateOption("handleColor");
          this.updateOption("handleBorderColor");
          this.updateOption("handleBorderThickness");
          this.updateOption("handleWidth");
          this.updateOption("handleHeight");
          this.updateOption("outlineColor");
          this.updateOption("outlineThickness");
          this.updateOption("outlineInverted");
          this.updateOption("minimum");
          this.updateOption("maximum");
        };
        M2.prototype._attachEvents = function() {
          var d2 = this;
          D(this.panel, "mousedown", function(f3) {
            d2.stockChart.isDrag = true;
            f3.target !== d2.leftHandle && f3.target !== d2.rightHandle && (d2.stockChart.navigatorClicked = true, d2.currentHandle = d2.leftHandle, d2.panMode = true, d2.startPosition = Aa(f3), f3.target === d2.currentHandle ? d2.startPosition.x += d2.currentHandle.offsetLeft + d2.currentHandle.clientWidth / 2 + d2.panel.offsetLeft : f3.target === d2.panel && (d2.startPosition.x += d2.panel.offsetLeft), d2.startWidth = d2.panel.clientWidth, d2.startLeft = d2.panel.offsetLeft);
          }, this.stockChart.allDOMEventHandlers);
          D(this.panel, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", function(f3) {
            d2.stockChart._touchEventHandler(f3);
          }, this.stockChart.allDOMEventHandlers);
          D(this.navigator.panel, "mousedown", function(k3) {
            if (k3.target !== d2.navigator.slider.panel && k3.target !== d2.leftHandle && k3.target !== d2.rightHandle) {
              d2.stockChart.navigatorClicked = true;
              var s = Aa(k3), v, a;
              v = 0;
              var h2 = d2.navigator.chart.axisX && d2.navigator.chart.axisX.length ? d2.navigator.chart.axisX[0] : d2.navigator.chart.axisX2[0];
              k3 = d2.navigator.slider.left;
              f2(d2.startLeft) && (d2.startLeft = k3);
              v = k3 + d2.navigator.slider.width;
              a = s.x - (k3 + v) / 2;
              if (s.x < k3 || s.x > v) {
                var s = Math.max(0, k3 + a), c2 = Math.min(v + a, d2.navigator.width);
                v + a > d2.navigator.width && (v = v + a - d2.navigator.width, s -= v);
                0 > k3 + a && (v = Math.abs(k3 + a), c2 += v);
                d2.stockChart._rangeEventParameter = { stockChart: d2.stockChart, source: "navigator", index: null, minimum: h2.convertPixelToValue(s), maximum: h2.convertPixelToValue(c2) };
                d2.stockChart.sessionVariables._axisXMin = h2.convertPixelToValue(s);
                d2.stockChart.sessionVariables._axisXMax = h2.convertPixelToValue(c2);
                d2.navigator.dynamicUpdate ? (d2.stockChart._rangeEventParameter.type = "rangeChanging", d2.stockChart.dispatchEvent(
                  "rangeChanging",
                  d2.stockChart._rangeEventParameter,
                  d2.stockChart
                ), d2.stockChart._syncCharts(h2.convertPixelToValue(s), h2.convertPixelToValue(c2)), d2.stockChart._rangeEventParameter.type = "rangeChanged", d2.stockChart.dispatchEvent("rangeChanged", d2.stockChart._rangeEventParameter, d2.stockChart)) : d2.navigator._updateSlider(d2.stockChart.sessionVariables._axisXMin, d2.stockChart.sessionVariables._axisXMax);
              }
            }
          }, this.navigator.stockChart.allDOMEventHandlers);
          D(
            this.navigator.panel,
            window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart",
            function(f3) {
              d2.stockChart._touchEventHandler(f3);
            },
            this.navigator.stockChart.allDOMEventHandlers
          );
          D(this.navigator.stockChart.container, "mousemove", function(k3) {
            var s = d2.navigator.chart.axisX && d2.navigator.chart.axisX.length ? d2.navigator.chart.axisX[0] : d2.navigator.chart.axisX2[0];
            if (!f2(d2.currentHandle) && d2.startPosition) {
              d2.navigator.chart.overlaidCanvas.style.cursor = d2.navigator.chart.container.style.cursor = d2.navigator.panel.style.cursor = "ew-resize";
              var v;
              v = d2.currentHandle === d2.leftHandle ? 1 : -1;
              var a = Aa(k3);
              k3 = k3.target || k3.srcElement;
              a.x = k3 === d2.currentHandle ? a.x + (d2.currentHandle.offsetLeft + d2.currentHandle.clientWidth / 2 + d2.panel.offsetLeft) : k3 === d2.mask || k3 === d2.panel ? a.x + d2.panel.offsetLeft : k3 === d2.rightHandle && d2.currentHandle === d2.leftHandle ? a.x + (d2.rightHandle.offsetLeft + d2.rightHandle.clientWidth / 2 + d2.panel.offsetLeft) : k3 === d2.leftHandle && d2.currentHandle === d2.rightHandle ? a.x + d2.panel.offsetLeft : a.x + ("canvasjs-chart-toolbar" === k3.parentElement.className ? k3.offsetParent.offsetLeft + k3.offsetLeft - d2.stockChart._chartsPlotAreaX1 : k3.parentElement.parentElement.parentElement === d2.navigator.panel ? k3.offsetLeft : k3.offsetLeft - d2.stockChart._chartsPlotAreaX1);
              var h2 = a.x - d2.startPosition.x;
              if (0 !== h2) {
                k3 = d2.panel.offsetLeft;
                var c2 = d2.panel.clientWidth;
                0 < v && (k3 = Math.max(d2.startLeft + v * h2, d2._left));
                d2.panMode || (c2 = Math.min(d2.startWidth - v * h2, d2.fullWidth), v * h2 > d2.startWidth ? (k3 = 0 < v ? d2.startLeft + d2.startWidth : Math.max(a.x, d2._left), c2 = (0 < v ? a.x : d2.startLeft) - parseFloat(k3)) : 0 > v && (k3 = d2.startLeft));
                k3 + c2 <= d2._left + d2.fullWidth && (2 < Math.abs(d2.startLeft - k3) || 2 < Math.abs(d2.startWidth - parseFloat(c2))) && (0 < v && (d2.left = k3, d2.panel.style.left = d2.left + "px"), d2.panMode || (d2.panel.style.width = d2.width = c2 + "px"), f2(s) || (v = s.convertPixelToValue(Math.max(s.bounds.x1, parseFloat(k3))), s = s.convertPixelToValue(parseFloat(k3) + parseFloat(c2)), d2.stockChart.sessionVariables._axisXMin = v, d2.stockChart.sessionVariables._axisXMax = s, d2.stockChart.rangeSelector && !d2.panMode && d2.stockChart.rangeSelector.resetRangeButtons(), d2.stockChart._rangeEventParameter = { stockChart: d2.stockChart, source: "navigator", index: null, minimum: v, maximum: s }, d2.navigator.dynamicUpdate ? (d2.stockChart._rangeEventParameter.type = "rangeChanging", d2.stockChart.dispatchEvent("rangeChanging", d2.stockChart._rangeEventParameter, d2.stockChart), d2.stockChart._syncCharts(v, s), d2.stockChart._rangeEventParameter.type = "rangeChanged", d2.stockChart.dispatchEvent("rangeChanged", d2.stockChart._rangeEventParameter, d2.stockChart)) : d2.navigator._updateSlider(d2.stockChart.sessionVariables._axisXMin, d2.stockChart.sessionVariables._axisXMax)));
              }
            } else
              d2.navigator.chart.overlaidCanvas.style.cursor = d2.navigator.chart.container.style.cursor = d2.navigator.panel.style.cursor = "auto";
          }, this.navigator.stockChart.allDOMEventHandlers);
          D(this.navigator.stockChart.container, window.navigator.msPointerEnabled ? "MSPointerMove" : "touchmove", function(f3) {
            d2.stockChart._touchEventHandler(f3);
          }, this.navigator.stockChart.allDOMEventHandlers);
        };
        M2.prototype._initialize = function() {
          var d2 = this, k3;
          this._updateOptions();
          aa2 && (this.eventsAttached || (this._attachEvents(), this.eventsAttached = true), this.handleWidth = this.options.handleWidth ? this.handleWidth : 8, this.handleHeight = this.options.handleHeight ? Math.min(
            this.navigator.height,
            this.options.handleHeight
          ) : 0.25 * this.navigator.height, this.leftHandle ? O(this.leftHandle, {
            height: this.navigator.height + "px",
            width: this.handleWidth + 10 + "px",
            position: "absolute",
            left: "-" + (this.handleWidth / 2 + 8) + "px",
            top: 0,
            cursor: "ew-resize",
            borderStyle: "solid",
            borderWidth: this.handleBorderThickness + "px",
            borderColor: "transparent",
            outline: "none",
            padding: 0,
            backgroundColor: "white",
            filter: "alpha(opacity = 0)",
            opacity: 0,
            color: "transparent",
            fontSize: "12px",
            fontFamily: "Arial",
            userSelect: "none",
            MozUserSelect: "none",
            WebkitUserSelect: "none",
            zIndex: 999
          }) : (this.leftHandle = w("button", "canvasjs-slider-handle", "button"), this.leftHandle.innerHTML = "||", O(this.leftHandle, {
            height: this.navigator.height + "px",
            width: this.handleWidth + 10 + "px",
            position: "absolute",
            left: "-" + (this.handleWidth / 2 + 8) + "px",
            top: 0,
            cursor: "ew-resize",
            borderStyle: "solid",
            borderWidth: this.handleBorderThickness + "px",
            borderColor: "transparent",
            outline: "none",
            padding: 0,
            backgroundColor: "white",
            filter: "alpha(opacity = 0)",
            opacity: 0,
            color: "transparent",
            fontSize: "12px",
            fontFamily: "Arial",
            userSelect: "none",
            MozUserSelect: "none",
            WebkitUserSelect: "none",
            zIndex: 999
          }), this.panel.appendChild(this.leftHandle), this.initHandle(this.leftHandle, 1)), this.rightHandle ? O(this.rightHandle, {
            height: this.navigator.height + "px",
            width: this.handleWidth + 10 + "px",
            position: "absolute",
            right: "-" + (this.handleWidth / 2 + 8) + "px",
            top: 0,
            cursor: "ew-resize",
            borderStyle: "solid",
            borderWidth: this.handleBorderThickness + "px",
            borderColor: "transparent",
            outline: "none",
            padding: "0px",
            backgroundColor: "white",
            filter: "alpha(opacity = 0)",
            opacity: 0,
            color: "transparent",
            fontSize: "12px",
            fontFamily: "Arial",
            userSelect: "none",
            MozUserSelect: "none",
            WebkitUserSelect: "none",
            msUserSelect: "none",
            zIndex: "999"
          }) : (this.rightHandle = w("button", "canvasjs-slider-handle", "button"), this.rightHandle.innerHTML = "||", O(this.rightHandle, {
            height: this.navigator.height + "px",
            width: this.handleWidth + 10 + "px",
            position: "absolute",
            right: "-" + (this.handleWidth / 2 + 8) + "px",
            top: 0,
            cursor: "ew-resize",
            borderStyle: "solid",
            borderWidth: this.handleBorderThickness + "px",
            borderColor: "transparent",
            outline: "none",
            padding: "0px",
            backgroundColor: "white",
            filter: "alpha(opacity = 0)",
            opacity: 0,
            color: "transparent",
            fontSize: "12px",
            fontFamily: "Arial",
            userSelect: "none",
            MozUserSelect: "none",
            WebkitUserSelect: "none",
            msUserSelect: "none",
            zIndex: "999"
          }), this.panel.appendChild(this.rightHandle), this.initHandle(this.rightHandle, -1)), O(this.panel, { position: "absolute", height: this.navigator.height + "px", width: "100%", cursor: "move", backgroundColor: "white", filter: "alpha(opacity = 0)", opacity: 0 }), this.fullWidth = this.panel.clientWidth, this._left = this.navigator.panel.offsetLeft, D(document, "mousedown", function(f3) {
            if (d2.stockChart.rangeSelector && d2.stockChart.rangeSelector.inputFields && d2.stockChart.rangeSelector.inputFields.enabled)
              for (var k4 = 0; k4 < d2.stockChart.rangeSelector.inputFields.elements.length; k4++)
                f3.target != d2.stockChart.rangeSelector.inputFields.elements[k4] && d2.stockChart.rangeSelector.inputFields.elements[k4].focused && d2.stockChart.rangeSelector.inputFields.elements[k4].blur();
          }, this.navigator.stockChart.allDOMEventHandlers), D(
            document,
            window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart",
            function(d3) {
              a: {
                var f3 = d3.changedTouches, f3 = f3 ? f3[0] : d3, a = "";
                switch (d3.type) {
                  case "touchstart":
                  case "MSPointerDown":
                    a = "mousedown";
                    break;
                  case "touchmove":
                  case "MSPointerMove":
                    a = "mousemove";
                    break;
                  case "touchend":
                  case "MSPointerUp":
                    a = "mouseup";
                    break;
                  default:
                    break a;
                }
                d3 = document.createEvent("MouseEvent");
                d3.initMouseEvent(a, true, true, window, 1, f3.screenX, f3.screenY, f3.clientX, f3.clientY, false, false, false, false, 0, null);
                f3.target.dispatchEvent(d3);
              }
            },
            this.navigator.stockChart.allDOMEventHandlers
          ), D(document, "mouseup", function(s) {
            d2.panMode = false;
            d2.navigator.stockChart.isDrag = false;
            if (d2.stockChart.navigatorClicked) {
              s = Math.min(d2.stockChart.sessionVariables._axisXMin, d2.stockChart.sessionVariables._axisXMax);
              var r2 = Math.max(d2.stockChart.sessionVariables._axisXMin, d2.stockChart.sessionVariables._axisXMax);
              f2(d2.stockChart._rangeEventParameter) && (d2.stockChart._rangeEventParameter = { stockChart: d2.stockChart, source: "navigator", index: null, minimum: s, maximum: r2 });
              if (2 < Math.abs(d2.startLeft - d2.left) || 2 < Math.abs(d2.startWidth - parseFloat(d2.width))) {
                d2.navigator.dynamicUpdate || (d2.stockChart._rangeEventParameter.type = "rangeChanging", d2.stockChart.dispatchEvent("rangeChanging", d2.stockChart._rangeEventParameter, d2.stockChart));
                for (var a = 0; a < d2.stockChart.charts.length; a++) {
                  k3 = d2.stockChart.charts[a];
                  k3.toolTip && k3.toolTip.enabled && k3.toolTip.hide();
                  for (var h2 = 0; h2 < k3.axisX.length; h2++)
                    k3.axisX[h2].setViewPortRange(s, r2);
                  for (h2 = 0; h2 < k3.axisX2.length; h2++)
                    k3.axisX2[h2].setViewPortRange(s, r2);
                  k3.render();
                }
                d2.stockChart.rangeSelector && (d2.stockChart.rangeSelector.enabled && d2.stockChart.rangeSelector.inputFields && d2.stockChart.rangeSelector.inputFields.enabled) && d2.stockChart.rangeSelector._updateInputFields(s, r2);
                d2.navigator.dynamicUpdate || (d2.stockChart._rangeEventParameter.type = "rangeChanged", d2.stockChart.dispatchEvent("rangeChanged", d2.stockChart._rangeEventParameter, d2.stockChart));
              }
            }
            d2.stockChart.navigatorClicked = d2.currentHandle = d2.startPosition = d2.startWidth = d2.startLeft = null;
          }, this.navigator.stockChart.allDOMEventHandlers), D(document, window.navigator.msPointerEnabled ? "MSPointerUp" : "touchend", function(s) {
            d2.panMode = false;
            d2.navigator.stockChart.isDrag = false;
            if (d2.stockChart.navigatorClicked) {
              s = Math.min(d2.stockChart.sessionVariables._axisXMin, d2.stockChart.sessionVariables._axisXMax);
              var r2 = Math.max(d2.stockChart.sessionVariables._axisXMin, d2.stockChart.sessionVariables._axisXMax);
              f2(d2.stockChart._rangeEventParameter) && (d2.stockChart._rangeEventParameter = { stockChart: d2.stockChart, source: "navigator", index: null, minimum: s, maximum: r2 });
              d2.navigator.dynamicUpdate || (d2.stockChart._rangeEventParameter.type = "rangeChanging", d2.stockChart.dispatchEvent("rangeChanging", d2.stockChart._rangeEventParameter, d2.stockChart));
              for (var a = 0; a < d2.stockChart.charts.length; a++) {
                k3 = d2.stockChart.charts[a];
                k3.toolTip && k3.toolTip.enabled && k3.toolTip.hide();
                for (var h2 = 0; h2 < k3.axisX.length; h2++)
                  k3.axisX[h2].setViewPortRange(s, r2);
                for (h2 = 0; h2 < k3.axisX2.length; h2++)
                  k3.axisX2[h2].setViewPortRange(s, r2);
                k3.render();
              }
              d2.stockChart.rangeSelector && (d2.stockChart.rangeSelector.enabled && d2.stockChart.rangeSelector.inputFields && d2.stockChart.rangeSelector.inputFields.enabled) && d2.stockChart.rangeSelector._updateInputFields(s, r2);
              d2.navigator.dynamicUpdate || (d2.stockChart._rangeEventParameter.type = "rangeChanged", d2.stockChart.dispatchEvent("rangeChanged", d2.stockChart._rangeEventParameter, d2.stockChart));
            }
            d2.stockChart.navigatorClicked = d2.currentHandle = d2.startPosition = d2.startWidth = d2.startLeft = null;
          }, this.navigator.stockChart.allDOMEventHandlers));
        };
        M2.prototype.initHandle = function(d2, f3) {
          var k3 = this;
          d2 && (D(d2, "mousedown", function(d3) {
            k3.stockChart.navigatorClicked = true;
            k3.currentHandle = this;
            k3.startPosition = Aa(d3);
            d3.target === k3.currentHandle ? k3.startPosition.x += k3.currentHandle.offsetLeft + k3.currentHandle.clientWidth / 2 + k3.panel.offsetLeft : d3.target === k3.panel && (k3.startPosition.x += k3.panel.offsetLeft);
            k3.startWidth = k3.panel.clientWidth;
            k3.startLeft = k3.panel.offsetLeft;
            d3.preventDefault && d3.preventDefault();
            d3.stopPropagation && d3.stopPropagation();
          }, this.navigator.stockChart.allDOMEventHandlers), D(d2, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", function(d3) {
            k3.stockChart._touchEventHandler(d3);
          }, this.navigator.stockChart.allDOMEventHandlers));
        };
        ga(R2, $);
        R2.prototype._updateOptions = function() {
          this.updateOption("enabled");
          this.updateOption("verticalAlign");
          this.updateOption("horizontalAlign");
          this.updateOption("width");
          this.updateOption("height");
          this.updateOption("label");
          this.updateOption("selectedRangeButtonIndex");
        };
        R2.prototype._initialize = function() {
          var d2 = 0;
          this._updateOptions();
          this._label = {};
          this.buttons = [];
          if (aa2 && this.enabled) {
            if (this.options.buttons)
              for (var k3 = 0; k3 < this.options.buttons.length; k3++)
                this.buttons.push(new Q(
                  this.stockChart,
                  k3,
                  this.options.buttons[k3]
                ));
            else {
              for (k3 = 0; 6 > k3; k3++)
                this.buttons.push(new Q(this.stockChart, k3));
              this.buttonLabels = "1m 3m 6m YTD 1y All".split(" ");
            }
            this._wrapElements = false;
            var s = this.stockChart.layoutManager.getFreeSpace(), r2 = s.x1, k3 = s.y1;
            this.width = this.options.width ? this.width : s.width;
            f2(this.buttonStyle.options.labelFontSize) && (this.buttonStyle.labelFontSize = this.stockChart.getAutoFontSize(this.buttonStyle.labelFontSize));
            this.rangeButtonsWidth = 0;
            this.buttonStyle.maxWidth = this.buttonStyle.options.maxWidth ? this.buttonStyle.options.maxWidth : this.stockChart.width / this.buttons.length;
            if (this.buttons && 0 < this.buttons.length) {
              var a = new ma(this.ctx, {
                x: 0,
                y: 0,
                backgroundColor: this.stockChart.backgroundColor,
                borderThickness: 0,
                cornerRadius: 0,
                maxWidth: 0.2 * this.stockChart.width,
                maxHeight: 2 * this.buttonStyle.labelFontSize,
                angle: 0,
                padding: { left: 5, right: 5, top: 2, bottom: 2 },
                text: f2(this.stockChart.options.culture) || f2(this.stockChart._cultureInfo.rangeSelector.rangeText) ? this.label : this.stockChart._cultureInfo.rangeSelector.rangeText,
                horizontalAlign: "left",
                fontSize: this.buttonStyle.labelFontSize,
                fontFamily: this.buttonStyle.labelFontFamily,
                fontWeight: this.buttonStyle.labelFontWeight,
                fontColor: this.buttonStyle.labelFontColor,
                fontStyle: this.buttonStyle.labelFontStyle,
                textBaseline: "middle"
              });
              this._label.textBlock = a;
            }
            for (k3 = 0; k3 < this.buttons.length; k3++) {
              var h2 = this.buttons[k3];
              h2._index = k3;
              a = new ma(this.ctx, {
                x: 0,
                y: 0,
                backgroundColor: this.buttonStyle.backgroundColor,
                borderColor: this.buttonStyle.borderColor,
                borderThickness: this.buttonStyle.borderThickness,
                cornerRadius: 0,
                maxWidth: this.buttonStyle.options.width ? this.buttonStyle.width : this.buttonStyle.maxWidth,
                maxHeight: 2 * this.buttonStyle.labelFontSize,
                angle: 0,
                padding: this.buttonStyle.padding,
                text: this.options.buttons && this.options.buttons.length ? f2(h2.label) ? "" : h2.label : this.buttonLabels[k3],
                horizontalAlign: "center",
                textAlign: "center",
                fontSize: this.buttonStyle.labelFontSize,
                fontFamily: this.buttonStyle.labelFontFamily,
                fontWeight: this.buttonStyle.labelFontWeight,
                fontColor: this.buttonStyle.labelFontColor,
                fontStyle: this.buttonStyle.labelFontStyle,
                textBaseline: "middle"
              });
              h2.state = f2(this.selectedRangeButtonIndex) || this.selectedRangeButtonIndex !== k3 ? "off" : "on";
              h2.textBlock = a;
              h2.bounds = { x1: null, x2: null, y1: null, y2: null, width: null, height: null };
              a.measureText();
              this.rangeButtonsWidth += a.width + this.buttonStyle.spacing;
              this.rangeButtonsHeight = a.height;
              d2 = d2 < a.height ? a.height : d2;
              h2 = this.buttons[k3];
              h2.id = ++this.stockChart._eventManager.lastObjectId;
              this.stockChart._eventManager.objectMap[h2.id] = { id: h2.id, objectType: "rangeButton", rangeButtonIndex: k3 };
            }
            this.height < this.inputFieldsHeight + 2 * this.inputFields.style.borderThickness && (this.height = this.inputFieldsHeight + 2 * this.inputFields.style.borderThickness);
            this.height < d2 + 2 * this.buttonStyle.borderThickness + 5 && (this.height = d2 + 2 * this.buttonStyle.borderThickness + 5);
            this._label && (this._label.textBlock && this.rangeButtonsWidth && this.inputFieldsWidth) && this.rangeButtonsWidth + this._label.textBlock.measureText().width + this.inputFieldsWidth >= this.stockChart.width && (this.height = this.options.height ? this.height : 2 * this.height, this._wrapElements = true);
            "bottom" === this.verticalAlign ? (k3 = s.y2 - this.height, d2 = "bottom") : (k3 = s.y1, d2 = "top");
            "left" === this.horizontalAlign ? r2 = s.x1 + 2 : "center" === this.horizontalAlign ? r2 = s.x1 + s.width / 2 - this.width / 2 : "right" === this.horizontalAlign && (r2 = s.x2 - 2 - this.width);
            this.stockChart.layoutManager.registerSpace(d2, { width: this.width, height: this.height });
            this.bounds = { x1: r2, y1: k3, x2: r2 + this.width, y2: k3 + this.height, width: this.width, height: this.height };
            for (k3 = 0; k3 < this.buttons.length; k3++)
              this.buttons[k3]._initialize(k3);
          }
        };
        R2.prototype.render = function() {
          var d2;
          this.setButtonsLayout();
          ba(this.ctx, this.bounds.x1, this.bounds.y1, this.bounds.x2, this.bounds.y2, this.stockChart.backgroundColor, 0, null, 0, 0, 0, 0, 1);
          this._label && this._label.textBlock && this._label.textBlock.render(true);
          for (d2 = 0; d2 < this.buttons.length; d2++)
            this.buttons[d2].enabled || (this.buttons[d2].textBlock.backgroundColor = this.buttons[d2].backgroundColorDisabled, this.buttons[d2].textBlock.borderColor = this.buttons[d2].backgroundColorDisabled), this.buttons[d2].render(true);
          this.inputFields && this.inputFields.enabled && this.renderInputFields(true);
        };
        R2.prototype.setButtonsLayout = function() {
          var d2, f3, k3 = this.bounds.x1 + 5, r2, a;
          this._label && (this._label.textBlock && 0 < this.buttons.length) && (this._label.textBlock.x = k3, this._label.textBlock.y = a = this.bounds.y1 + this._label.textBlock.measureText().height / 2 + 2 * this.buttons[0].textBlock.borderThickness, this._label.bounds = {
            x1: k3,
            y1: a - this._label.textBlock.fontSize / 2,
            x2: k3 + this._label.textBlock.measureText().width,
            y2: a + this._label.textBlock.measureText().height,
            width: this._label.textBlock.measureText().width,
            height: this._label.textBlock.measureText().height
          }, k3 += this._label.bounds.width);
          for (d2 = 0; d2 < this.buttons.length; d2++)
            f3 = this.buttons[d2], f3.textBlock.width = f3.textBlock.maxWidth = this.buttonStyle.width = this.buttonStyle.options.width ? this.buttonStyle.width : f3.textBlock.width, r2 = k3 + f3.textBlock.width, f3.textBlock.x = f3.bounds.x1 = 1 === f3.textBlock.borderThickness % 2 ? (k3 << 0) + 0.5 : k3, f3.bounds.x2 = r2, a = 1 === f3.textBlock.borderThickness % 2 ? this.bounds.y1 + f3.textBlock.height / 2 + 2 * f3.textBlock.borderThickness << 0.5 : this.bounds.y1 + f3.textBlock.height / 2 + 2 * f3.textBlock.borderThickness, f3.textBlock.y = a, f3.bounds.y1 = a - f3.textBlock.height / 2, f3.bounds.y2 = f3.bounds.y1 + f3.textBlock.height, f3.bounds.width = r2 - k3, f3.bounds.height = f3.bounds.y2 - f3.bounds.y1, k3 = r2 + this.buttonStyle.spacing, f3.textBlock.maxWidth = this.buttonStyle.maxWidth;
        };
        R2.prototype.resetRangeButtons = function() {
          for (var d2 = 0; d2 < this.buttons.length; d2++)
            this.buttons[d2].enabled && (this.buttons[d2].state = "off", this.buttons[d2].textBlock.backgroundColor = this.buttonStyle.backgroundColor, this.buttons[d2].textBlock.fontColor = this.buttonStyle.labelFontColor, this.buttons[d2].textBlock.fontWeight = this.buttonStyle.labelFontWeight, this.buttons[d2].textBlock.render(true));
        };
        R2.prototype.renderInputFields = function() {
          this.inputFields._textBlocks[0].text = "dateTime" === this.inputFields.valueType && isFinite(this.inputFields.startValue) ? ea(this.inputFields.startValue, this.inputFields.valueFormatString, this.stockChart._cultureInfo) : da(this.inputFields.startValue, this.inputFields.valueFormatString, this.stockChart._cultureInfo);
          this.inputFields._textBlocks[1].text = "dateTime" === this.inputFields.valueType && isFinite(this.inputFields.endValue) ? ea(this.inputFields.endValue, this.inputFields.valueFormatString, this.stockChart._cultureInfo) : da(this.inputFields.endValue, this.inputFields.valueFormatString, this.stockChart._cultureInfo);
          this.inputFields._labels[0].text = f2(this.stockChart._cultureInfo.rangeSelector.fromText) ? "From" : this.stockChart._cultureInfo.rangeSelector.fromText;
          this.inputFields._labels[1].text = f2(this.stockChart._cultureInfo.rangeSelector.toText) ? "To" : this.stockChart._cultureInfo.rangeSelector.toText;
          var d2 = 0, k3 = true;
          if (this.stockChart.title && this.stockChart.title.text && ("top" === this.stockChart.title.verticalAlign || "right" === this.stockChart.title.horizontalAlign && "center" === this.stockChart.title.verticalAlign && this.stockChart.exportEnabled) || "bottom" === this.verticalAlign)
            k3 = false;
          if (this.stockChart.subtitles)
            for (var s = 0; s < this.stockChart.subtitles.length; s++)
              this.stockChart.subtitles[s] && (this.stockChart.subtitles[s].text && ("top" === this.stockChart.subtitles[s].verticalAlign || "right" === this.stockChart.subtitles[s].horizontalAlign && "center" === this.stockChart.subtitles[s].verticalAlign && this.stockChart.exportEnabled)) && (k3 = false);
          for (s = this.inputFields._textBlocks.length - 1; 0 <= s; s--) {
            var r2 = this.inputFields._textBlocks[s], a = r2.measureText();
            r2._width = this.inputFields.style.options.width ? this.inputFields.style.width : Math.abs(a.width - r2._width) <= ("dateTime" === this.inputFields.valueType ? 10 : 5) ? r2._width : a.width + 10;
            d2 += r2._width + this.inputFields.style.spacing;
            this.inputFields.elements[s].style.width = r2._width - this.inputFields.style.spacing - 2 * this.inputFields.style.borderThickness - 5 + "px";
            r2.x = r2.bounds.x1 = 1 === r2.borderThickness % 2 ? (this.bounds.x2 - d2 - (this.stockChart.exportEnabled && k3 ? 40 : 0) << 0) + 0.5 : this.bounds.x2 - d2 - (this.stockChart.exportEnabled && k3 ? 40 : 0);
            r2.bounds.x2 = r2.bounds.x1 + r2._width;
            this.inputFields.elements[s].style.left = this.bounds.x2 - d2 - (this.stockChart.exportEnabled && k3 ? 40 : 0) + this.inputFields.style.borderThickness + "px";
            d2 += this.inputFields._labels[s].measureText().width;
            this.inputFields._labels[s].x = this.inputFields._labels[s].bounds.x1 = this.bounds.x2 - d2 - (this.stockChart.exportEnabled && k3 ? 40 : 0);
            this.inputFields._labels[s].bounds.x2 = this.inputFields._labels[s].bounds.x1 + this.inputFields._labels[s].measureText().width;
            r2.width = r2._width;
            r2.y = 1 === r2.borderThickness % 2 ? (this._wrapElements ? this.bounds.y1 + this.rangeButtonsHeight + 10 : this.bounds.y1) + a.height / 2 + 2 * r2.borderThickness << 0.5 : (this._wrapElements ? this.bounds.y1 + this.rangeButtonsHeight + 10 : this.bounds.y1) + a.height / 2 + 2 * r2.borderThickness;
            this.inputFields._labels[s].y = (this._wrapElements ? this.bounds.y1 + this.rangeButtonsHeight + 10 : this.bounds.y1) + a.height / 2 + 2 * r2.borderThickness;
            r2.bounds.y1 = this.inputFields._labels[s].bounds.y1 = r2.y - a.height / 2 + 2 * r2.borderThickness;
            r2.bounds.y2 = this.inputFields._labels[s].bounds.y2 = r2.bounds.y1 + a.height;
            this.inputFields.elements[s].style.top = this.inputFields._labels[s].bounds.y1 + "px";
            r2.render(true);
            this.inputFields._labels[s].render(true);
          }
        };
        R2.prototype._updateInputFields = function(d2, f3) {
          !this.inputFields.elements[0].focused && isFinite(d2) && (this.inputFields.elements[0].value = "dateTime" === this.inputFields.valueType ? ea(d2, "YYYY-MM-DD") : da(d2, this.inputFields.valueFormatString));
          !this.inputFields.elements[1].focused && isFinite(f3) && (this.inputFields.elements[1].value = "dateTime" === this.inputFields.valueType ? ea(f3, "YYYY-MM-DD") : da(f3, this.inputFields.valueFormatString));
          for (var k3 = 0; k3 < this.inputFields.elements.length; k3++)
            this.inputFields.elements[k3].focused && this.inputFields.elements[k3].focus();
          this.inputFields.startValue = d2;
          this.inputFields.endValue = f3;
          this.render();
        };
        ga(Q, $);
        Q.prototype._updateOptions = function() {
          this.updateOption("style");
          this.updateOption("label");
          this.updateOption("range");
          this.updateOption("rangeType");
        };
        Q.prototype._initialize = function(d2) {
          this._updateOptions();
          var k3 = "1m 3m 6m YTD 1y All".split(" "), r2 = [1, 3, 6, null, 1, null], v = "month month month ytd year all".split(" ");
          this.range = "undefined" !== typeof this.options.range ? this.range : f2(r2[d2]) ? null : r2[d2];
          this.rangeType = "undefined" !== typeof this.options.rangeType ? this.rangeType : v[d2];
          this.label = this.textBlock.text = f2(this.options.label) ? k3[d2] : this.label;
        };
        Q.prototype.render = function() {
          this.textBlock.render(true);
        };
        ga(T2, $);
        T2.prototype._updateOptions = function() {
          this.updateOption("enabled");
          this.updateOption("startValue");
          this.updateOption("endValue");
          this.updateOption("valueType");
          this.updateOption("valueFormatString");
        };
        T2.prototype._initialize = function() {
          this._updateOptions();
          f2(this.style.options.fontSize) && (this.style.fontSize = this.stockChart.getAutoFontSize(this.style.fontSize));
          if (this.enabled) {
            for (var d2 = 0; d2 < this.elements.length; d2++)
              this.elements[d2].style.position = "absolute", this.elements[d2].style.display = this.elements[d2].focused ? "inline" : "none", this.elements[d2].style.backgroundColor = this.style.backgroundColor, this.elements[d2].style.border = "none", this.elements[d2].style.outline = "none", this.elements[d2].style.outlineOffset = 0, this.elements[d2].style.textAlign = "center", this.elements[d2].style.color = this.style.fontColor, this.elements[d2].style.fontSize = this.elements[d2].style.height = this.style.fontSize + "px", this.elements[d2].style.fontStyle = this.style.fontStyle, this.elements[d2].style.fontFamily = this.style.fontFamily, this.elements[d2].style.fontWeight = this.style.fontWeight, this.elements[d2].style.lineHeight = 1, isNaN(this.style.padding) ? (this.elements[d2].style.paddingTop = this.style.padding.top + "px", this.elements[d2].style.paddingRight = this.style.padding.right + "px", this.elements[d2].style.paddingBottom = this.style.padding.bottom + "px", this.elements[d2].style.paddingLeft = this.style.padding.left + "px") : this.elements[d2].style.padding = this.style.padding + "px", this.elements[d2].style.mozAppearance = this.elements[d2].style.webkitAppearance = this.elements[d2].style.appearance = "none", this.elements[d2].style.webkitBorderRadius = 0, this.elements[d2].style.mozBorderRadius = 0, this.elements[d2].style.borderRadius = 0, this.elements[d2].style.boxSizing = "content-box";
            this.parent = this.rangeSelector = this.stockChart.rangeSelector;
          }
        };
        ga(V2, $);
        V2.prototype._updateOptions = function() {
          this.updateOption("backgroundColor");
          this.updateOption("backgroundColorOnHover");
          this.updateOption("backgroundColorOnSelect");
          this.updateOption("borderColor");
          this.updateOption("borderThickness");
          this.updateOption("labelFontColor");
          this.updateOption("labelFontColorOnHover");
          this.updateOption("labelFontSize");
          this.updateOption("labelFontStyle");
          this.updateOption("labelFontFamily");
          this.updateOption("labelFontWeight");
          this.updateOption("width");
          this.updateOption("maxWidth");
          this.updateOption("padding");
          this.updateOption("spacing");
          this.updateOption("cursor");
        };
        ga(X2, $);
        X2.prototype._updateOptions = function() {
          this.updateOption("backgroundColor");
          this.updateOption("borderColor");
          this.updateOption("borderThickness");
          this.updateOption("borderColorOnFocus");
          this.updateOption("fontColor");
          this.updateOption("fontSize");
          this.updateOption("fontStyle");
          this.updateOption("fontFamily");
          this.updateOption("fontWeight");
          this.updateOption("width");
          this.updateOption("maxWidth");
          this.updateOption("padding");
          this.updateOption("spacing");
          this.updateOption("cursor");
        };
        return F2;
      }();
      T.version = "v1.8.3 GA";
      window.CanvasJS && (T && (!window.CanvasJS.StockChart && window.CanvasJS.Chart) && (window.CanvasJS.StockChart = T), T && !window.CanvasJS.Chart && (window.CanvasJS.Chart = Ja, window.CanvasJS.StockChart = T));
    })();
    document.createElement("canvas").getContext || function() {
      function V() {
        return this.context_ || (this.context_ = new C2(this));
      }
      function W(a, b, c2) {
        var g = M.call(arguments, 2);
        return function() {
          return a.apply(b, g.concat(M.call(arguments)));
        };
      }
      function N(a) {
        return String(a).replace(/&/g, "&amp;").replace(/"/g, "&quot;");
      }
      function O(a) {
        a.namespaces.g_vml_ || a.namespaces.add("g_vml_", "urn:schemas-microsoft-com:vml", "#default#VML");
        a.namespaces.g_o_ || a.namespaces.add("g_o_", "urn:schemas-microsoft-com:office:office", "#default#VML");
        a.styleSheets.ex_canvas_ || (a = a.createStyleSheet(), a.owningElement.id = "ex_canvas_", a.cssText = "canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}");
      }
      function X(a) {
        var b = a.srcElement;
        switch (a.propertyName) {
          case "width":
            b.getContext().clearRect();
            b.style.width = b.attributes.width.nodeValue + "px";
            b.firstChild.style.width = b.clientWidth + "px";
            break;
          case "height":
            b.getContext().clearRect(), b.style.height = b.attributes.height.nodeValue + "px", b.firstChild.style.height = b.clientHeight + "px";
        }
      }
      function Y(a) {
        a = a.srcElement;
        a.firstChild && (a.firstChild.style.width = a.clientWidth + "px", a.firstChild.style.height = a.clientHeight + "px");
      }
      function D() {
        return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
      }
      function t(a, b) {
        for (var c2 = D(), g = 0; 3 > g; g++)
          for (var e = 0; 3 > e; e++) {
            for (var f2 = 0, d3 = 0; 3 > d3; d3++)
              f2 += a[g][d3] * b[d3][e];
            c2[g][e] = f2;
          }
        return c2;
      }
      function P(a, b) {
        b.fillStyle = a.fillStyle;
        b.lineCap = a.lineCap;
        b.lineJoin = a.lineJoin;
        b.lineWidth = a.lineWidth;
        b.miterLimit = a.miterLimit;
        b.shadowBlur = a.shadowBlur;
        b.shadowColor = a.shadowColor;
        b.shadowOffsetX = a.shadowOffsetX;
        b.shadowOffsetY = a.shadowOffsetY;
        b.strokeStyle = a.strokeStyle;
        b.globalAlpha = a.globalAlpha;
        b.font = a.font;
        b.textAlign = a.textAlign;
        b.textBaseline = a.textBaseline;
        b.arcScaleX_ = a.arcScaleX_;
        b.arcScaleY_ = a.arcScaleY_;
        b.lineScale_ = a.lineScale_;
      }
      function Q(a) {
        var b = a.indexOf("(", 3), c2 = a.indexOf(")", b + 1), b = a.substring(b + 1, c2).split(",");
        if (4 != b.length || "a" != a.charAt(3))
          b[3] = 1;
        return b;
      }
      function E(a, b, c2) {
        return Math.min(c2, Math.max(b, a));
      }
      function F(a, b, c2) {
        0 > c2 && c2++;
        1 < c2 && c2--;
        return 1 > 6 * c2 ? a + 6 * (b - a) * c2 : 1 > 2 * c2 ? b : 2 > 3 * c2 ? a + 6 * (b - a) * (2 / 3 - c2) : a;
      }
      function G(a) {
        if (a in H)
          return H[a];
        var b, c2 = 1;
        a = String(a);
        if ("#" == a.charAt(0))
          b = a;
        else if (/^rgb/.test(a)) {
          c2 = Q(a);
          b = "#";
          for (var g, e = 0; 3 > e; e++)
            g = -1 != c2[e].indexOf("%") ? Math.floor(255 * (parseFloat(c2[e]) / 100)) : +c2[e], b += v[E(g, 0, 255)];
          c2 = +c2[3];
        } else if (/^hsl/.test(a)) {
          e = c2 = Q(a);
          b = parseFloat(e[0]) / 360 % 360;
          0 > b && b++;
          g = E(parseFloat(e[1]) / 100, 0, 1);
          e = E(parseFloat(e[2]) / 100, 0, 1);
          if (0 == g)
            g = e = b = e;
          else {
            var f2 = 0.5 > e ? e * (1 + g) : e + g - e * g, d3 = 2 * e - f2;
            g = F(d3, f2, b + 1 / 3);
            e = F(d3, f2, b);
            b = F(d3, f2, b - 1 / 3);
          }
          b = "#" + v[Math.floor(255 * g)] + v[Math.floor(255 * e)] + v[Math.floor(255 * b)];
          c2 = c2[3];
        } else
          b = Z[a] || a;
        return H[a] = { color: b, alpha: c2 };
      }
      function C2(a) {
        this.m_ = D();
        this.mStack_ = [];
        this.aStack_ = [];
        this.currentPath_ = [];
        this.fillStyle = this.strokeStyle = "#000";
        this.lineWidth = 1;
        this.lineJoin = "miter";
        this.lineCap = "butt";
        this.miterLimit = 1 * q;
        this.globalAlpha = 1;
        this.font = "10px sans-serif";
        this.textAlign = "left";
        this.textBaseline = "alphabetic";
        this.canvas = a;
        var b = "width:" + a.clientWidth + "px;height:" + a.clientHeight + "px;overflow:hidden;position:absolute", c2 = a.ownerDocument.createElement("div");
        c2.style.cssText = b;
        a.appendChild(c2);
        b = c2.cloneNode(false);
        b.style.backgroundColor = "red";
        b.style.filter = "alpha(opacity=0)";
        a.appendChild(b);
        this.element_ = c2;
        this.lineScale_ = this.arcScaleY_ = this.arcScaleX_ = 1;
      }
      function R(a, b, c2, g) {
        a.currentPath_.push({ type: "bezierCurveTo", cp1x: b.x, cp1y: b.y, cp2x: c2.x, cp2y: c2.y, x: g.x, y: g.y });
        a.currentX_ = g.x;
        a.currentY_ = g.y;
      }
      function S2(a, b) {
        var c2 = G(a.strokeStyle), g = c2.color, c2 = c2.alpha * a.globalAlpha, e = a.lineScale_ * a.lineWidth;
        1 > e && (c2 *= e);
        b.push(
          "<g_vml_:stroke",
          ' opacity="',
          c2,
          '"',
          ' joinstyle="',
          a.lineJoin,
          '"',
          ' miterlimit="',
          a.miterLimit,
          '"',
          ' endcap="',
          $[a.lineCap] || "square",
          '"',
          ' weight="',
          e,
          'px"',
          ' color="',
          g,
          '" />'
        );
      }
      function T(a, b, c2, g) {
        var e = a.fillStyle, f2 = a.arcScaleX_, d3 = a.arcScaleY_, k3 = g.x - c2.x, n = g.y - c2.y;
        if (e instanceof w) {
          var h2 = 0, l2 = g = 0, u2 = 0, m = 1;
          if ("gradient" == e.type_) {
            h2 = e.x1_ / f2;
            c2 = e.y1_ / d3;
            var p = s(a, e.x0_ / f2, e.y0_ / d3), h2 = s(a, h2, c2), h2 = 180 * Math.atan2(h2.x - p.x, h2.y - p.y) / Math.PI;
            0 > h2 && (h2 += 360);
            1e-6 > h2 && (h2 = 0);
          } else
            p = s(a, e.x0_, e.y0_), g = (p.x - c2.x) / k3, l2 = (p.y - c2.y) / n, k3 /= f2 * q, n /= d3 * q, m = x.max(k3, n), u2 = 2 * e.r0_ / m, m = 2 * e.r1_ / m - u2;
          f2 = e.colors_;
          f2.sort(function(a2, b2) {
            return a2.offset - b2.offset;
          });
          d3 = f2.length;
          p = f2[0].color;
          c2 = f2[d3 - 1].color;
          k3 = f2[0].alpha * a.globalAlpha;
          a = f2[d3 - 1].alpha * a.globalAlpha;
          for (var n = [], r2 = 0; r2 < d3; r2++) {
            var t2 = f2[r2];
            n.push(t2.offset * m + u2 + " " + t2.color);
          }
          b.push('<g_vml_:fill type="', e.type_, '"', ' method="none" focus="100%"', ' color="', p, '"', ' color2="', c2, '"', ' colors="', n.join(","), '"', ' opacity="', a, '"', ' g_o_:opacity2="', k3, '"', ' angle="', h2, '"', ' focusposition="', g, ",", l2, '" />');
        } else
          e instanceof I ? k3 && n && b.push("<g_vml_:fill", ' position="', -c2.x / k3 * f2 * f2, ",", -c2.y / n * d3 * d3, '"', ' type="tile"', ' src="', e.src_, '" />') : (e = G(a.fillStyle), b.push('<g_vml_:fill color="', e.color, '" opacity="', e.alpha * a.globalAlpha, '" />'));
      }
      function s(a, b, c2) {
        a = a.m_;
        return { x: q * (b * a[0][0] + c2 * a[1][0] + a[2][0]) - r, y: q * (b * a[0][1] + c2 * a[1][1] + a[2][1]) - r };
      }
      function z(a, b, c2) {
        isFinite(b[0][0]) && (isFinite(b[0][1]) && isFinite(b[1][0]) && isFinite(b[1][1]) && isFinite(b[2][0]) && isFinite(b[2][1])) && (a.m_ = b, c2 && (a.lineScale_ = aa(ba(b[0][0] * b[1][1] - b[0][1] * b[1][0]))));
      }
      function w(a) {
        this.type_ = a;
        this.r1_ = this.y1_ = this.x1_ = this.r0_ = this.y0_ = this.x0_ = 0;
        this.colors_ = [];
      }
      function I(a, b) {
        if (!a || 1 != a.nodeType || "IMG" != a.tagName)
          throw new A("TYPE_MISMATCH_ERR");
        if ("complete" != a.readyState)
          throw new A("INVALID_STATE_ERR");
        switch (b) {
          case "repeat":
          case null:
          case "":
            this.repetition_ = "repeat";
            break;
          case "repeat-x":
          case "repeat-y":
          case "no-repeat":
            this.repetition_ = b;
            break;
          default:
            throw new A("SYNTAX_ERR");
        }
        this.src_ = a.src;
        this.width_ = a.width;
        this.height_ = a.height;
      }
      function A(a) {
        this.code = this[a];
        this.message = a + ": DOM Exception " + this.code;
      }
      var x = Math, k2 = x.round, J = x.sin, K = x.cos, ba = x.abs, aa = x.sqrt, q = 10, r = q / 2;
      navigator.userAgent.match(/MSIE ([\d.]+)?/);
      var M = Array.prototype.slice;
      O(document);
      var U = { init: function(a) {
        a = a || document;
        a.createElement("canvas");
        a.attachEvent("onreadystatechange", W(this.init_, this, a));
      }, init_: function(a) {
        a = a.getElementsByTagName("canvas");
        for (var b = 0; b < a.length; b++)
          this.initElement(a[b]);
      }, initElement: function(a) {
        if (!a.getContext) {
          a.getContext = V;
          O(a.ownerDocument);
          a.innerHTML = "";
          a.attachEvent("onpropertychange", X);
          a.attachEvent("onresize", Y);
          var b = a.attributes;
          b.width && b.width.specified ? a.style.width = b.width.nodeValue + "px" : a.width = a.clientWidth;
          b.height && b.height.specified ? a.style.height = b.height.nodeValue + "px" : a.height = a.clientHeight;
        }
        return a;
      } };
      U.init();
      for (var v = [], d2 = 0; 16 > d2; d2++)
        for (var B = 0; 16 > B; B++)
          v[16 * d2 + B] = d2.toString(16) + B.toString(16);
      var Z = {
        aliceblue: "#F0F8FF",
        antiquewhite: "#FAEBD7",
        aquamarine: "#7FFFD4",
        azure: "#F0FFFF",
        beige: "#F5F5DC",
        bisque: "#FFE4C4",
        black: "#000000",
        blanchedalmond: "#FFEBCD",
        blueviolet: "#8A2BE2",
        brown: "#A52A2A",
        burlywood: "#DEB887",
        cadetblue: "#5F9EA0",
        chartreuse: "#7FFF00",
        chocolate: "#D2691E",
        coral: "#FF7F50",
        cornflowerblue: "#6495ED",
        cornsilk: "#FFF8DC",
        crimson: "#DC143C",
        cyan: "#00FFFF",
        darkblue: "#00008B",
        darkcyan: "#008B8B",
        darkgoldenrod: "#B8860B",
        darkgray: "#A9A9A9",
        darkgreen: "#006400",
        darkgrey: "#A9A9A9",
        darkkhaki: "#BDB76B",
        darkmagenta: "#8B008B",
        darkolivegreen: "#556B2F",
        darkorange: "#FF8C00",
        darkorchid: "#9932CC",
        darkred: "#8B0000",
        darksalmon: "#E9967A",
        darkseagreen: "#8FBC8F",
        darkslateblue: "#483D8B",
        darkslategray: "#2F4F4F",
        darkslategrey: "#2F4F4F",
        darkturquoise: "#00CED1",
        darkviolet: "#9400D3",
        deeppink: "#FF1493",
        deepskyblue: "#00BFFF",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1E90FF",
        firebrick: "#B22222",
        floralwhite: "#FFFAF0",
        forestgreen: "#228B22",
        gainsboro: "#DCDCDC",
        ghostwhite: "#F8F8FF",
        gold: "#FFD700",
        goldenrod: "#DAA520",
        grey: "#808080",
        greenyellow: "#ADFF2F",
        honeydew: "#F0FFF0",
        hotpink: "#FF69B4",
        indianred: "#CD5C5C",
        indigo: "#4B0082",
        ivory: "#FFFFF0",
        khaki: "#F0E68C",
        lavender: "#E6E6FA",
        lavenderblush: "#FFF0F5",
        lawngreen: "#7CFC00",
        lemonchiffon: "#FFFACD",
        lightblue: "#ADD8E6",
        lightcoral: "#F08080",
        lightcyan: "#E0FFFF",
        lightgoldenrodyellow: "#FAFAD2",
        lightgreen: "#90EE90",
        lightgrey: "#D3D3D3",
        lightpink: "#FFB6C1",
        lightsalmon: "#FFA07A",
        lightseagreen: "#20B2AA",
        lightskyblue: "#87CEFA",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#B0C4DE",
        lightyellow: "#FFFFE0",
        limegreen: "#32CD32",
        linen: "#FAF0E6",
        magenta: "#FF00FF",
        mediumaquamarine: "#66CDAA",
        mediumblue: "#0000CD",
        mediumorchid: "#BA55D3",
        mediumpurple: "#9370DB",
        mediumseagreen: "#3CB371",
        mediumslateblue: "#7B68EE",
        mediumspringgreen: "#00FA9A",
        mediumturquoise: "#48D1CC",
        mediumvioletred: "#C71585",
        midnightblue: "#191970",
        mintcream: "#F5FFFA",
        mistyrose: "#FFE4E1",
        moccasin: "#FFE4B5",
        navajowhite: "#FFDEAD",
        oldlace: "#FDF5E6",
        olivedrab: "#6B8E23",
        orange: "#FFA500",
        orangered: "#FF4500",
        orchid: "#DA70D6",
        palegoldenrod: "#EEE8AA",
        palegreen: "#98FB98",
        paleturquoise: "#AFEEEE",
        palevioletred: "#DB7093",
        papayawhip: "#FFEFD5",
        peachpuff: "#FFDAB9",
        peru: "#CD853F",
        pink: "#FFC0CB",
        plum: "#DDA0DD",
        powderblue: "#B0E0E6",
        rosybrown: "#BC8F8F",
        royalblue: "#4169E1",
        saddlebrown: "#8B4513",
        salmon: "#FA8072",
        sandybrown: "#F4A460",
        seagreen: "#2E8B57",
        seashell: "#FFF5EE",
        sienna: "#A0522D",
        skyblue: "#87CEEB",
        slateblue: "#6A5ACD",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#FFFAFA",
        springgreen: "#00FF7F",
        steelblue: "#4682B4",
        tan: "#D2B48C",
        thistle: "#D8BFD8",
        tomato: "#FF6347",
        turquoise: "#40E0D0",
        violet: "#EE82EE",
        wheat: "#F5DEB3",
        whitesmoke: "#F5F5F5",
        yellowgreen: "#9ACD32"
      }, H = {}, L = {}, $ = { butt: "flat", round: "round" }, d2 = C2.prototype;
      d2.clearRect = function() {
        this.textMeasureEl_ && (this.textMeasureEl_.removeNode(true), this.textMeasureEl_ = null);
        this.element_.innerHTML = "";
      };
      d2.beginPath = function() {
        this.currentPath_ = [];
      };
      d2.moveTo = function(a, b) {
        var c2 = s(this, a, b);
        this.currentPath_.push({ type: "moveTo", x: c2.x, y: c2.y });
        this.currentX_ = c2.x;
        this.currentY_ = c2.y;
      };
      d2.lineTo = function(a, b) {
        var c2 = s(this, a, b);
        this.currentPath_.push({ type: "lineTo", x: c2.x, y: c2.y });
        this.currentX_ = c2.x;
        this.currentY_ = c2.y;
      };
      d2.bezierCurveTo = function(a, b, c2, g, e, f2) {
        e = s(this, e, f2);
        a = s(this, a, b);
        c2 = s(this, c2, g);
        R(this, a, c2, e);
      };
      d2.quadraticCurveTo = function(a, b, c2, g) {
        a = s(this, a, b);
        c2 = s(this, c2, g);
        g = { x: this.currentX_ + 2 / 3 * (a.x - this.currentX_), y: this.currentY_ + 2 / 3 * (a.y - this.currentY_) };
        R(this, g, { x: g.x + (c2.x - this.currentX_) / 3, y: g.y + (c2.y - this.currentY_) / 3 }, c2);
      };
      d2.arc = function(a, b, c2, g, e, f2) {
        c2 *= q;
        var d3 = f2 ? "at" : "wa", k3 = a + K(g) * c2 - r, n = b + J(g) * c2 - r;
        g = a + K(e) * c2 - r;
        e = b + J(e) * c2 - r;
        k3 != g || f2 || (k3 += 0.125);
        a = s(this, a, b);
        k3 = s(this, k3, n);
        g = s(this, g, e);
        this.currentPath_.push({
          type: d3,
          x: a.x,
          y: a.y,
          radius: c2,
          xStart: k3.x,
          yStart: k3.y,
          xEnd: g.x,
          yEnd: g.y
        });
      };
      d2.rect = function(a, b, c2, g) {
        this.moveTo(a, b);
        this.lineTo(a + c2, b);
        this.lineTo(a + c2, b + g);
        this.lineTo(a, b + g);
        this.closePath();
      };
      d2.strokeRect = function(a, b, c2, g) {
        var e = this.currentPath_;
        this.beginPath();
        this.moveTo(a, b);
        this.lineTo(a + c2, b);
        this.lineTo(a + c2, b + g);
        this.lineTo(a, b + g);
        this.closePath();
        this.stroke();
        this.currentPath_ = e;
      };
      d2.fillRect = function(a, b, c2, g) {
        var e = this.currentPath_;
        this.beginPath();
        this.moveTo(a, b);
        this.lineTo(a + c2, b);
        this.lineTo(a + c2, b + g);
        this.lineTo(a, b + g);
        this.closePath();
        this.fill();
        this.currentPath_ = e;
      };
      d2.createLinearGradient = function(a, b, c2, g) {
        var e = new w("gradient");
        e.x0_ = a;
        e.y0_ = b;
        e.x1_ = c2;
        e.y1_ = g;
        return e;
      };
      d2.createRadialGradient = function(a, b, c2, g, e, f2) {
        var d3 = new w("gradientradial");
        d3.x0_ = a;
        d3.y0_ = b;
        d3.r0_ = c2;
        d3.x1_ = g;
        d3.y1_ = e;
        d3.r1_ = f2;
        return d3;
      };
      d2.drawImage = function(a, b) {
        var c2, g, e, d3, r2, y2, n, h2;
        e = a.runtimeStyle.width;
        d3 = a.runtimeStyle.height;
        a.runtimeStyle.width = "auto";
        a.runtimeStyle.height = "auto";
        var l2 = a.width, u2 = a.height;
        a.runtimeStyle.width = e;
        a.runtimeStyle.height = d3;
        if (3 == arguments.length)
          c2 = arguments[1], g = arguments[2], r2 = y2 = 0, n = e = l2, h2 = d3 = u2;
        else if (5 == arguments.length)
          c2 = arguments[1], g = arguments[2], e = arguments[3], d3 = arguments[4], r2 = y2 = 0, n = l2, h2 = u2;
        else if (9 == arguments.length)
          r2 = arguments[1], y2 = arguments[2], n = arguments[3], h2 = arguments[4], c2 = arguments[5], g = arguments[6], e = arguments[7], d3 = arguments[8];
        else
          throw Error("Invalid number of arguments");
        var m = s(this, c2, g), p = [];
        p.push(
          " <g_vml_:group",
          ' coordsize="',
          10 * q,
          ",",
          10 * q,
          '"',
          ' coordorigin="0,0"',
          ' style="width:',
          10,
          "px;height:",
          10,
          "px;position:absolute;"
        );
        if (1 != this.m_[0][0] || this.m_[0][1] || 1 != this.m_[1][1] || this.m_[1][0]) {
          var t2 = [];
          t2.push("M11=", this.m_[0][0], ",", "M12=", this.m_[1][0], ",", "M21=", this.m_[0][1], ",", "M22=", this.m_[1][1], ",", "Dx=", k2(m.x / q), ",", "Dy=", k2(m.y / q), "");
          var v2 = s(this, c2 + e, g), w2 = s(this, c2, g + d3);
          c2 = s(this, c2 + e, g + d3);
          m.x = x.max(m.x, v2.x, w2.x, c2.x);
          m.y = x.max(m.y, v2.y, w2.y, c2.y);
          p.push("padding:0 ", k2(m.x / q), "px ", k2(m.y / q), "px 0;filter:progid:DXImageTransform.Microsoft.Matrix(", t2.join(""), ", sizingmethod='clip');");
        } else
          p.push(
            "top:",
            k2(m.y / q),
            "px;left:",
            k2(m.x / q),
            "px;"
          );
        p.push(' ">', '<g_vml_:image src="', a.src, '"', ' style="width:', q * e, "px;", " height:", q * d3, 'px"', ' cropleft="', r2 / l2, '"', ' croptop="', y2 / u2, '"', ' cropright="', (l2 - r2 - n) / l2, '"', ' cropbottom="', (u2 - y2 - h2) / u2, '"', " />", "</g_vml_:group>");
        this.element_.insertAdjacentHTML("BeforeEnd", p.join(""));
      };
      d2.stroke = function(a) {
        var b = [];
        b.push(
          "<g_vml_:shape",
          ' filled="',
          !!a,
          '"',
          ' style="position:absolute;width:',
          10,
          "px;height:",
          10,
          'px;"',
          ' coordorigin="0,0"',
          ' coordsize="',
          10 * q,
          ",",
          10 * q,
          '"',
          ' stroked="',
          !a,
          '"',
          ' path="'
        );
        for (var c2 = { x: null, y: null }, d3 = { x: null, y: null }, e = 0; e < this.currentPath_.length; e++) {
          var f2 = this.currentPath_[e];
          switch (f2.type) {
            case "moveTo":
              b.push(" m ", k2(f2.x), ",", k2(f2.y));
              break;
            case "lineTo":
              b.push(" l ", k2(f2.x), ",", k2(f2.y));
              break;
            case "close":
              b.push(" x ");
              f2 = null;
              break;
            case "bezierCurveTo":
              b.push(" c ", k2(f2.cp1x), ",", k2(f2.cp1y), ",", k2(f2.cp2x), ",", k2(f2.cp2y), ",", k2(f2.x), ",", k2(f2.y));
              break;
            case "at":
            case "wa":
              b.push(" ", f2.type, " ", k2(f2.x - this.arcScaleX_ * f2.radius), ",", k2(f2.y - this.arcScaleY_ * f2.radius), " ", k2(f2.x + this.arcScaleX_ * f2.radius), ",", k2(f2.y + this.arcScaleY_ * f2.radius), " ", k2(f2.xStart), ",", k2(f2.yStart), " ", k2(f2.xEnd), ",", k2(f2.yEnd));
          }
          if (f2) {
            if (null == c2.x || f2.x < c2.x)
              c2.x = f2.x;
            if (null == d3.x || f2.x > d3.x)
              d3.x = f2.x;
            if (null == c2.y || f2.y < c2.y)
              c2.y = f2.y;
            if (null == d3.y || f2.y > d3.y)
              d3.y = f2.y;
          }
        }
        b.push(' ">');
        a ? T(this, b, c2, d3) : S2(this, b);
        b.push("</g_vml_:shape>");
        this.element_.insertAdjacentHTML("beforeEnd", b.join(""));
      };
      d2.fill = function() {
        this.stroke(true);
      };
      d2.closePath = function() {
        this.currentPath_.push({ type: "close" });
      };
      d2.save = function() {
        var a = {};
        P(this, a);
        this.aStack_.push(a);
        this.mStack_.push(this.m_);
        this.m_ = t(D(), this.m_);
      };
      d2.restore = function() {
        this.aStack_.length && (P(this.aStack_.pop(), this), this.m_ = this.mStack_.pop());
      };
      d2.translate = function(a, b) {
        z(this, t([[1, 0, 0], [0, 1, 0], [a, b, 1]], this.m_), false);
      };
      d2.rotate = function(a) {
        var b = K(a);
        a = J(a);
        z(this, t([[b, a, 0], [-a, b, 0], [0, 0, 1]], this.m_), false);
      };
      d2.scale = function(a, b) {
        this.arcScaleX_ *= a;
        this.arcScaleY_ *= b;
        z(this, t([[a, 0, 0], [0, b, 0], [0, 0, 1]], this.m_), true);
      };
      d2.transform = function(a, b, c2, d3, e, f2) {
        z(this, t([[
          a,
          b,
          0
        ], [c2, d3, 0], [e, f2, 1]], this.m_), true);
      };
      d2.setTransform = function(a, b, c2, d3, e, f2) {
        z(this, [[a, b, 0], [c2, d3, 0], [e, f2, 1]], true);
      };
      d2.drawText_ = function(a, b, c2, d3, e) {
        var f2 = this.m_;
        d3 = 0;
        var r2 = 1e3, t2 = 0, n = [], h2;
        h2 = this.font;
        if (L[h2])
          h2 = L[h2];
        else {
          var l2 = document.createElement("div").style;
          try {
            l2.font = h2;
          } catch (u2) {
          }
          h2 = L[h2] = { style: l2.fontStyle || "normal", variant: l2.fontVariant || "normal", weight: l2.fontWeight || "normal", size: l2.fontSize || 10, family: l2.fontFamily || "sans-serif" };
        }
        var l2 = h2, m = this.element_;
        h2 = {};
        for (var p in l2)
          h2[p] = l2[p];
        p = parseFloat(m.currentStyle.fontSize);
        m = parseFloat(l2.size);
        "number" == typeof l2.size ? h2.size = l2.size : -1 != l2.size.indexOf("px") ? h2.size = m : -1 != l2.size.indexOf("em") ? h2.size = p * m : -1 != l2.size.indexOf("%") ? h2.size = p / 100 * m : -1 != l2.size.indexOf("pt") ? h2.size = m / 0.75 : h2.size = p;
        h2.size *= 0.981;
        p = h2.style + " " + h2.variant + " " + h2.weight + " " + h2.size + "px " + h2.family;
        m = this.element_.currentStyle;
        l2 = this.textAlign.toLowerCase();
        switch (l2) {
          case "left":
          case "center":
          case "right":
            break;
          case "end":
            l2 = "ltr" == m.direction ? "right" : "left";
            break;
          case "start":
            l2 = "rtl" == m.direction ? "right" : "left";
            break;
          default:
            l2 = "left";
        }
        switch (this.textBaseline) {
          case "hanging":
          case "top":
            t2 = h2.size / 1.75;
            break;
          case "middle":
            break;
          default:
          case null:
          case "alphabetic":
          case "ideographic":
          case "bottom":
            t2 = -h2.size / 2.25;
        }
        switch (l2) {
          case "right":
            d3 = 1e3;
            r2 = 0.05;
            break;
          case "center":
            d3 = r2 = 500;
        }
        b = s(this, b + 0, c2 + t2);
        n.push('<g_vml_:line from="', -d3, ' 0" to="', r2, ' 0.05" ', ' coordsize="100 100" coordorigin="0 0"', ' filled="', !e, '" stroked="', !!e, '" style="position:absolute;width:1px;height:1px;">');
        e ? S2(this, n) : T(
          this,
          n,
          { x: -d3, y: 0 },
          { x: r2, y: h2.size }
        );
        e = f2[0][0].toFixed(3) + "," + f2[1][0].toFixed(3) + "," + f2[0][1].toFixed(3) + "," + f2[1][1].toFixed(3) + ",0,0";
        b = k2(b.x / q) + "," + k2(b.y / q);
        n.push('<g_vml_:skew on="t" matrix="', e, '" ', ' offset="', b, '" origin="', d3, ' 0" />', '<g_vml_:path textpathok="true" />', '<g_vml_:textpath on="true" string="', N(a), '" style="v-text-align:', l2, ";font:", N(p), '" /></g_vml_:line>');
        this.element_.insertAdjacentHTML("beforeEnd", n.join(""));
      };
      d2.fillText = function(a, b, c2, d3) {
        this.drawText_(a, b, c2, d3, false);
      };
      d2.strokeText = function(a, b, c2, d3) {
        this.drawText_(a, b, c2, d3, true);
      };
      d2.measureText = function(a) {
        this.textMeasureEl_ || (this.element_.insertAdjacentHTML("beforeEnd", '<span style="position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;"></span>'), this.textMeasureEl_ = this.element_.lastChild);
        var b = this.element_.ownerDocument;
        this.textMeasureEl_.innerHTML = "";
        this.textMeasureEl_.style.font = this.font;
        this.textMeasureEl_.appendChild(b.createTextNode(a));
        return { width: this.textMeasureEl_.offsetWidth };
      };
      d2.clip = function() {
      };
      d2.arcTo = function() {
      };
      d2.createPattern = function(a, b) {
        return new I(a, b);
      };
      w.prototype.addColorStop = function(a, b) {
        b = G(b);
        this.colors_.push({ offset: a, color: b.color, alpha: b.alpha });
      };
      d2 = A.prototype = Error();
      d2.INDEX_SIZE_ERR = 1;
      d2.DOMSTRING_SIZE_ERR = 2;
      d2.HIERARCHY_REQUEST_ERR = 3;
      d2.WRONG_DOCUMENT_ERR = 4;
      d2.INVALID_CHARACTER_ERR = 5;
      d2.NO_DATA_ALLOWED_ERR = 6;
      d2.NO_MODIFICATION_ALLOWED_ERR = 7;
      d2.NOT_FOUND_ERR = 8;
      d2.NOT_SUPPORTED_ERR = 9;
      d2.INUSE_ATTRIBUTE_ERR = 10;
      d2.INVALID_STATE_ERR = 11;
      d2.SYNTAX_ERR = 12;
      d2.INVALID_MODIFICATION_ERR = 13;
      d2.NAMESPACE_ERR = 14;
      d2.INVALID_ACCESS_ERR = 15;
      d2.VALIDATION_ERR = 16;
      d2.TYPE_MISMATCH_ERR = 17;
      G_vmlCanvasManager = U;
      CanvasRenderingContext2D = C2;
      CanvasGradient = w;
      CanvasPattern = I;
      DOMException = A;
    }();
  }
});

// node_modules/@canvasjs/vue-stockcharts/dist/vue-stockcharts.js
var h = __toESM(require_canvasjs_stock_min());
var c = (t, s) => {
  const r = t.__vccOpts || t;
  for (const [i, e] of s)
    r[i] = e;
  return r;
};
var l = "Chart" in h ? h : window.CanvasJS;
var d = {
  props: {
    styles: {
      type: Object,
      default: () => ({})
    },
    options: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["chart-ref"],
  data() {
    return {
      chart: null,
      updateChart: true,
      containerStyle: {
        width: this.styles && this.styles.width ? this.styles.width : "100%",
        height: this.styles && this.styles.height ? this.styles.height : "360px",
        ...this.styles
      }
    };
  },
  watch: {
    options: {
      handler(t, s) {
        this.updateChart = t !== s;
      }
    }
  },
  updated() {
    this.chart && this.updateChart && (this.chart.options = this.options, this.chart.render());
  },
  mounted() {
    this.chart = new l.Chart(this.$refs.chartContainer, this.options), this.chart.render(), this.$emit("chart-ref", this.chart);
  },
  unmounted() {
    this.chart && this.chart.destroy();
  }
};
function C(t, s, r, i, e, p) {
  return openBlock(), createElementBlock("div", {
    ref: "chartContainer",
    style: normalizeStyle(e.containerStyle)
  }, null, 4);
}
var u = c(d, [["render", C]]);
var y = "Chart" in h && "StockChart" in h ? h : window.CanvasJS;
var f = {
  props: {
    styles: {
      type: Object,
      default: () => ({})
    },
    options: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["stockchart-ref"],
  data() {
    return {
      stockChart: null,
      updateStockChart: true,
      containerStyle: {
        width: this.styles && this.styles.width ? this.styles.width : "100%",
        height: this.styles && this.styles.height ? this.styles.height : "400px",
        ...this.styles
      }
    };
  },
  watch: {
    options: {
      handler(t, s) {
        this.updateStockChart = t !== s;
      }
    }
  },
  updated() {
    this.stockChart && this.updateStockChart && (this.stockChart.options = this.options, this.stockChart.render());
  },
  mounted() {
    this.stockChart = new y.StockChart(this.$refs.stockChartContainer, this.options), this.stockChart.render(), this.$emit("stockchart-ref", this.stockChart);
  },
  unmounted() {
    this.stockChart && this.stockChart.destroy();
  }
};
function k(t, s, r, i, e, p) {
  return openBlock(), createElementBlock("div", {
    ref: "stockChartContainer",
    style: normalizeStyle(e.containerStyle)
  }, null, 4);
}
var S = c(f, [["render", k]]);
var _ = {
  install: (t, s) => {
    t.component("CanvasJSChart", u).component("CanvasJSStockChart", S);
  }
};
export {
  _ as default
};
//# sourceMappingURL=@canvasjs_vue-stockcharts.js.map
